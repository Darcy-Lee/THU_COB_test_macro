var contents = new Array("/**  ******************************************************************************  * @file    can_bootloader.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   can bootloader相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __CAN_BOOTLOADER_H_#define __CAN_BOOTLOADER_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//函数返回错误代码定义#define CAN_SUCCESS             (0)   //函数执行成功#define CAN_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define CAN_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define CAN_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define CAN_ERR_CMD_FAIL        (-4)  //命令执行失败#define CAN_BOOT_ERR_CONFIG       (-30) //配置设备错误#define CAN_BOOT_ERR_SEND         (-31) //发送数据出错#define CAN_BOOT_ERR_TIME_OUT     (-32) //超时错误#define CAN_BOOT_ERR_CMD          (-33) //执行命令失败#define CAN_BOOT_ERR_BAUD         (-34) //波特率参数自动获取失败#define CAN_BOOT_ERR_BUFFER       (-35) //从设备返回接收数据缓冲区大小为0#define CAN_BOOT_ERR_DSIZE        (-36) //单次传输数据量大于了4093字节#define CAN_BOOT_ERR_ERASE          1   //固件擦除出错#define CAN_BOOT_ERR_ERASE_IN_APP   2   //当前模式为APP，不能擦除固件#define CAN_BOOT_ERR_WRITE_OUTRANGE 3   //当前地址超出了正常的地址范围#define CAN_BOOT_ERR_WRITE_IN_APP   4   //当前模式不能写入固件数据#define CAN_BOOT_ERR_WRITE          5   //数据写入程序存储器出错#define CAN_BOOT_ERR_WRITE_OUT_ADDR 6   //数据长度超出了程序存储器范围 #define CAN_BOOT_ERR_WRITE_CRC      7   //数据CRC校验出错//CAN Bootloader固件类型#define FW_TYPE_BOOT     0x55#define FW_TYPE_APP      0xAA//CAN Bootloader数据收发ID类型#define ID_TYPE_EXT     0x01#define ID_TYPE_STD     0x00#ifdef __cplusplusextern &quot;C&quot;{#endifint WINAPI CAN_BOOT_Init(int DevHandle,int CANIndex,unsigned int SendDataID,unsigned int ReceiveDataID,unsigned char IDType,int BaudRate);int WINAPI CAN_BOOT_GetFWInfo(int DevHandle,int CANIndex,unsigned char NAD,unsigned char *pFWType,unsigned int *pFWVersion,unsigned int TimeOutOfMs);int WINAPI CAN_BOOT_EnterBootMode(int DevHandle,int CANIndex,unsigned char NAD);int WINAPI CAN_BOOT_EraseApp(int DevHandle,int CANIndex,unsigned char NAD,unsigned int AppSizeOfByte,unsigned int TimeOutOfMs);int WINAPI CAN_BOOT_SetAddrOffset(int DevHandle,int CANIndex,unsigned char NAD,unsigned int AddrOffset,unsigned short *pBufferSize,unsigned int TimeOutOfMs);int WINAPI CAN_BOOT_SendAppData(int DevHandle,int CANIndex,unsigned char NAD,unsigned char *pData,unsigned short DataLen,unsigned short *pCRC16);int WINAPI CAN_BOOT_WriteAppData(int DevHandle,int CANIndex,unsigned char NAD,unsigned short CRC16,unsigned int TimeOutOfMs);int WINAPI CAN_BOOT_ExecuteApp(int DevHandle,int CANIndex,unsigned char NAD);int WINAPI CAN_BOOT_SetFrameTime(int DevHandle,int CANIndex,int TimeOfMs);#ifdef __cplusplus}#endif#endif","can_bootloader.h","topics\\API函数接口定义原型/C/can_bootloader.htm","/**  ******************************************************************************  * @file    can_uds.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   can_uds相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __CAN_UDS_H_#define __CAN_UDS_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//函数返回值错误定义#define CAN_UDS_OK            0#define CAN_UDS_TRAN_USB      -98#define CAN_UDS_TRAN_CAN      -99#define CAN_UDS_TIMEOUT_A     -100#define CAN_UDS_TIMEOUT_Bs    -101#define CAN_UDS_TIMEOUT_Cr    -102#define CAN_UDS_WRONG_SN      -103#define CAN_UDS_INVALID_FS    -104#define CAN_UDS_UNEXP_PDU     -105#define CAN_UDS_WFT_OVRN      -106#define CAN_UDS_BUFFER_OVFLW  -107#define CAN_UDS_ERROR         -108//CAN UDS地址定义typedef  struct  _CAN_UDS_ADDR{    unsigned int    ReqID;        //请求报文ID。    unsigned int    ResID;        //应答报文ID。    unsigned char   Flag;          //bit[0]-帧类型(0-标准帧，1-扩展帧),bit[1]-FDF(0-普通CAN帧，1-CANFD帧),bit[2]-BRS(0-CANFD帧不加速，1-CANFD帧加速)    unsigned char   AddrFormats;  //0-normal, 1-extended ,2-mixed    unsigned char   AddrExt;      //当AddrFormats不为normal时，该数据放到CAN数据域第1字节    unsigned char   MaxDLC;       //普通CAN设置为8，CANFD帧可以最大设置为64}CAN_UDS_ADDR;#ifdef __cplusplusextern &quot;C&quot;{#endif    int WINAPI CAN_UDS_Request(int DevHandle,unsigned char CANIndex,CAN_UDS_ADDR *pUDSAddr,unsigned char *pReqData,int DataLen);    int WINAPI CAN_UDS_Response(int DevHandle,unsigned char CANIndex,CAN_UDS_ADDR *pUDSAddr,unsigned char *pResData,int TimeOutMs);#ifdef __cplusplus}#endif#endif","can_uds.htm","topics\\API函数接口定义原型/C/can_uds.htm","/**  ******************************************************************************  * @file    ControlCAN.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   Ginkgo USB-CAN适配器底层控制相关API函数定义.  ******************************************************************************  * @attention  *  *&lt;h3&gt;&lt;center&gt;&amp;copy; Copyright 2009-2012, ViewTool&lt;/center&gt;  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *  ******************************************************************************  */#ifndef _CONTROLCAN_H_#define _CONTROLCAN_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#ifndef WINAPI#define WINAPI#endif#endif//适配器类型定义#define VCI_USBCAN1     3#define VCI_USBCAN2     4//CAN错误码#define ERR_CAN_OVERFLOW        0x0001  //CAN 控制器内部FIFO溢出#define ERR_CAN_ERRALARM        0x0002  //CAN 控制器错误报警#define ERR_CAN_PASSIVE         0x0004  //CAN 控制器消极错误#define ERR_CAN_LOSE            0x0008  //CAN 控制器仲裁丢失#define ERR_CAN_BUSERR          0x0010  //CAN 控制器总线错误#define ERR_CAN_BUSOFF          0x0020  //CAN 控制器总线关闭//通用错误码#define ERR_DEVICEOPENED        0x0100  //设备已经打开#define ERR_DEVICEOPEN          0x0200  //打开设备错误#define ERR_DEVICENOTOPEN       0x0400  //设备没有打开#define ERR_BUFFEROVERFLOW      0x0800  //缓冲区溢出#define ERR_DEVICENOTEXIST      0x1000  //此设备不存在#define ERR_LOADKERNELDLL       0x2000  //装载动态库失败#define ERR_CMDFAILED           0x4000  //执行命令失败错误码#define ERR_BUFFERCREATE        0x8000  //内存不足//函数调用返回状态值#define STATUS_OK   1#define STATUS_ERR  0//1.兼容ZLGCAN系列接口卡信息的数据类型。typedef  struct  _VCI_BOARD_INFO{    unsigned short  hw_Version;         //硬件版本号，用16 进制表示。比如0x0100 表示V1.00。    unsigned short  fw_Version;         //固件版本号，用16 进制表示。    unsigned short  dr_Version;         //驱动程序版本号，用16 进制表示。    unsigned short  in_Version;         //接口库版本号，用16 进制表示。    unsigned short  irq_Num;            //板卡所使用的中断号。    unsigned char   can_Num;            //表示有几路CAN 通道。    unsigned char   str_Serial_Num[20]; //此板卡的序列号。    unsigned char   str_hw_Type[40];    //硬件类型，比如“USBCAN V1.00”（注意：包括字符串结束符‘\\0’）。    unsigned short  Reserved[4];        //系统保留。} VCI_BOARD_INFO,*PVCI_BOARD_INFO;//1.Ginkgo系列接口卡信息的数据类型。typedef  struct  _VCI_BOARD_INFO_EX{    unsigned char   ProductName[32];    //硬件名称（注意：包括字符串结束符‘\\0’）    unsigned char   FirmwareVersion[4]; //固件版本    unsigned char   HardwareVersion[4]; //硬件版本    unsigned char   SerialNumber[12];   //适配器序列号} VCI_BOARD_INFO_EX,*PVCI_BOARD_INFO_EX;//2.定义CAN信息帧的数据类型。typedef  struct  _VCI_CAN_OBJ{    unsigned int    ID;         //报文ID。    unsigned int    TimeStamp;  //接收到信息帧时的时间标识，从CAN 控制器初始化开始计时。    unsigned char   TimeFlag;   //是否使用时间标识，为1 时TimeStamp 有效，TimeFlag 和TimeStamp 只在此帧为接收帧时有意义。    unsigned char   SendType;   //发送帧类型，=0 时为正常发送，=1 时为单次发送，=2 时为自发自收，=3 时为单次自发自收，只在此                                //帧为发送帧时有意义。（当设备类型为EG20T-CAN 时，发送方式在VCI_InitCan 中通过设置，此处的                                //设置无效，设置为自发自收模式后EG20T-CAN 不能从总线上接收数据，只能收到自己发出的数据）    unsigned char   RemoteFlag; //是否是远程帧    unsigned char   ExternFlag; //是否是扩展帧    unsigned char   DataLen;    //数据长度(&lt;=8)，即Data 的长度。    unsigned char   Data[8];    //报文的数据。    unsigned char   Reserved[3];//系统保留。}VCI_CAN_OBJ,*PVCI_CAN_OBJ;//3.定义CAN控制器状态的数据类型。typedef struct _VCI_CAN_STATUS{    unsigned char   ErrInterrupt;   //中断记录，读操作会清除。    unsigned char   regMode;        //CAN 控制器模式寄存器。    unsigned char   regStatus;      //CAN 控制器状态寄存器。    unsigned char   regALCapture;   //CAN 控制器仲裁丢失寄存器。    unsigned char   regECCapture;   //CAN 控制器错误寄存器。    unsigned char   regEWLimit;     //CAN 控制器错误警告限制寄存器。    unsigned char   regRECounter;   //CAN 控制器接收错误寄存器。    unsigned char   regTECounter;   //CAN 控制器发送错误寄存器。    unsigned int    regESR;         //CAN 控制器错误状态寄存器。    unsigned int    regTSR;         //CAN 控制器发送状态寄存器    unsigned int    BufferSize;     //CAN 控制器接收缓冲区大小    unsigned int    Reserved;}VCI_CAN_STATUS,*PVCI_CAN_STATUS;//4.定义错误信息的数据类型。typedef struct _ERR_INFO{    unsigned int    ErrCode;            //错误码    unsigned char   Passive_ErrData[3]; //当产生的错误中有消极错误时表示为消极错误的错误标识数据。    unsigned char   ArLost_ErrData;     //当产生的错误中有仲裁丢失错误时表示为仲裁丢失错误的错误标识数据。} VCI_ERR_INFO,*PVCI_ERR_INFO;//5.定义初始化CAN的数据类型typedef struct _INIT_CONFIG{    unsigned int    AccCode;    //验收码    unsigned int    AccMask;    //屏蔽码    unsigned int    Reserved;   //保留    unsigned char   Filter;     //滤波方式,0-双滤波，接收所有的帧，1-单滤波，根据AccCode和AccMask来设置过滤器     unsigned char   Timing0;    //定时器0（BTR0）。    unsigned char   Timing1;    //定时器1（BTR1）。    unsigned char   Mode;       //模式，0-正常模式，1-监听模式，2-自发自收默认，若最高位设置为1，比如按位或上0x80，则表示接入120欧的终端电阻到CAN总线，否则不接入。}VCI_INIT_CONFIG,*PVCI_INIT_CONFIG;//6.定义了CAN 滤波器的设置typedef struct _VCI_FILTER_CONFIG{    unsigned char   Enable;         //使能该过滤器，1-使能，0-禁止    unsigned char   FilterIndex;    //过滤器索引号，取值范围为0到13    unsigned char   FilterMode;     //过滤器模式，0-屏蔽位模式，1-标识符列表模式    unsigned char   ExtFrame;       //过滤的帧类型标志，为1 代表要过滤的为扩展帧，为0 代表要过滤的为标准帧。    unsigned int    ID_Std_Ext;     //验收码ID    unsigned int    ID_IDE;         //验收码IDE    unsigned int    ID_RTR;         //验收码RTR    unsigned int    MASK_Std_Ext;   //屏蔽码ID，该项只有在过滤器模式为屏蔽位模式时有用    unsigned int    MASK_IDE;       //屏蔽码IDE，该项只有在过滤器模式为屏蔽位模式时有用    unsigned int    MASK_RTR;       //屏蔽码RTR，该项只有在过滤器模式为屏蔽位模式时有用    unsigned int    Reserved;       //系统保留} VCI_FILTER_CONFIG,*PVCI_FILTER_CONFIG;#ifdef __cplusplusextern &quot;C&quot;{#endif#ifdef __OS_ANDROID_BACKunsigned int WINAPI VCI_ScanDevice(int *fd,int devNum);#elseunsigned int WINAPI VCI_ScanDevice(unsigned char NeedInit);#endif#ifdef __OS_ANDROID_BACKunsigned int WINAPI VCI_OpenDevice(unsigned int DevType, unsigned int DevIndex,int *pFd,int DevNum);#elseunsigned int WINAPI VCI_OpenDevice(unsigned int DevType, unsigned int DevIndex,unsigned int Reserved);#endifunsigned int WINAPI VCI_CloseDevice(unsigned int DevType,unsigned int DevIndex);unsigned int WINAPI VCI_InitCAN(unsigned int DevType, unsigned int DevIndex, unsigned int CANIndex, PVCI_INIT_CONFIG pInitConfig);unsigned int WINAPI VCI_ReadBoardInfo(unsigned int DevType,unsigned int DevIndex,PVCI_BOARD_INFO pInfo);unsigned int WINAPI VCI_ReadErrInfo(unsigned int DevType,unsigned int DevIndex,unsigned int CANIndex,PVCI_ERR_INFO pErrInfo);unsigned int WINAPI VCI_ReadCANStatus(unsigned int DevType,unsigned int DevIndex,unsigned int CANIndex,PVCI_CAN_STATUS pCANStatus);unsigned int WINAPI VCI_GetReference(unsigned int DevType,unsigned int DevIndex,unsigned int CANIndex,unsigned int RefType,void *pData);unsigned int WINAPI VCI_SetReference(unsigned int DevType,unsigned int DevIndex,unsigned int CANIndex,unsigned int RefType,void *pData);unsigned int WINAPI VCI_SetFilter(unsigned int DevType,unsigned int DevIndex,unsigned int CANIndex,PVCI_FILTER_CONFIG pFilter);unsigned int WINAPI VCI_GetReceiveNum(unsigned int DevType,unsigned int DevIndex,unsigned int CANIndex);unsigned int WINAPI VCI_ClearBuffer(unsigned int DevType,unsigned int DevIndex,unsigned int CANIndex);unsigned int WINAPI VCI_StartCAN(unsigned int DevType,unsigned int DevIndex,unsigned int CANIndex);unsigned int WINAPI VCI_ResetCAN(unsigned int DevType,unsigned int DevIndex,unsigned int CANIndex);unsigned int WINAPI VCI_Transmit(unsigned int DevType,unsigned int DevIndex,unsigned int CANIndex,PVCI_CAN_OBJ pSend,unsigned int Len);unsigned int WINAPI VCI_Receive(unsigned int DevType,unsigned int DevIndex,unsigned int CANIndex,PVCI_CAN_OBJ pReceive,unsigned int Len,int WaitTime=-1);#ifdef __cplusplus}#endif#endif","ControlCAN.h","topics\\API函数接口定义原型/C/ControlCAN.htm","/**  ******************************************************************************  * @file    elmos_programer.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   elmos_programer相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __ELMOS_PROGRAMER_H_#define __ELMOS_PROGRAMER_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义函数返回错误代码#define ELMOS_SUCCESS             (0)     //函数执行成功#define ELMOS_ERR_OPEN_DEV        (-1)    //打开设备失败#define ELMOS_ERR_INIT_DEV        (-2)    //初始化设备失败#define ELMOS_ERR_FILE_FORMAT     (-3)    //文件格式错误#define ELMOS_ERR_BEGIN_PROG      (-4)    //进入编程模式错误#define ELMOS_ERR_CMD_FAIL        (-5)    //命令执行失败#define ELMOS_ERR_PRG_FAILD       (-6)    //编程失败#define ELMOS_ERR_FIND_CHIP       (-7)    //寻找芯片失败#ifdef __cplusplusextern &quot;C&quot;{#endif    int WINAPI ELMOS_StartProg(int DeviceHandle, unsigned char LINChannel,const char* AppFileName);#ifdef __cplusplus}#endif#endif","elmos_programer.h","topics\\API函数接口定义原型/C/elmos_programer.htm","/**  ******************************************************************************  * @file    i2c_sniffer.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   i2c sniffer相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __I2C_SNIFFER_H_#define __I2C_SNIFFER_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//I2C数据类型定义typedef enum{     UNKNOWN = 0x00,    START,    ADDR,    DATA,    STOP}I2C_DATA_TYPE;//I2C数据结构定义typedef struct{    unsigned char DataType; //当前数据类型    unsigned char ACK;      //0-当前ACK为低电平，1-当前ACK为高电平    unsigned char WriteRead;//1-读操作，0-写操作    unsigned char Data;     //当DataType为DATA时对应的数据    unsigned short Addr;    //数据对应的从机地址    long long Timestamp;    //时间戳，单位为ns}I2C_DATA;//解析到I2C数据后的回调函数typedef  int (WINAPI I2C_GET_DATA_HANDLE)(int DevHandle,int Channel,I2C_DATA *pI2CData,int I2CDataNum);//定义函数返回错误代码#define SUCCESS             (0)   //函数执行成功#define ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define ERR_CMD_FAIL        (-4)  //命令执行失败#ifdef __cplusplusextern &quot;C&quot;{#endif    int WINAPI I2C_SnifferStart(int DevHandle,int Channel,unsigned int SampleRateHz,I2C_GET_DATA_HANDLE *pGetI2CDataHandle);    int WINAPI I2C_SnifferStop(int DevHandle);#ifdef __cplusplus}#endif#endif","i2c_sniffer.h","topics\\API函数接口定义原型/C/i2c_sniffer.htm","/**  ******************************************************************************  * @file    ir_sniffer.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   ir sniffer相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __IR_SNIFFER_H_#define __IR_SNIFFER_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif#include &quot;usb2ir.h&quot;typedef struct _IR_RESULTS{    ir_type_t              decode_type;  // UNKNOWN, NEC, SONY, RC5, ...    unsigned int           address;      // Used by Panasonic &amp; Sharp [16-bits]    unsigned int           value;        // Decoded value [max 32-bits]    int                    bits;         // Number of bits in decoded value    volatile unsigned int  *rawbuf;      // Raw intervals in 1uS ticks    int                    rawlen;       // Number of records in rawbuf    int                    overflow;     // true iff IR raw code too long}IR_RESULTS,*PIR_RESULTS;//解析到I2C数据后的回调函数typedef  int (WINAPI IR_GET_DATA_HANDLE)(int DevHandle,int ChannelIndex,IR_RESULTS *pIRResults);//定义函数返回错误代码#define SUCCESS             (0)   //函数执行成功#define ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define ERR_CMD_FAIL        (-4)  //命令执行失败#ifdef __cplusplusextern &quot;C&quot;{#endif    int WINAPI IR_SnifferStart(int DevHandle,unsigned char Channel,IR_GET_DATA_HANDLE *pGetIRDataHandle);    int WINAPI IR_SnifferStop(int DevHandle);#ifdef __cplusplus}#endif#endif","ir_sniffer.h","topics\\API函数接口定义原型/C/ir_sniffer.htm","/*******************************************************************************  * @file    ldf_parser.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   LDF文件解析相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __LDF_PARSER_H_#define __LDF_PARSER_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif#define LDF_PARSER_OK                   0//没有错误#define LDF_PARSER_FILE_OPEN         (-1)//打开文件出错#define LDF_PARSER_FILE_FORMAT       (-2)//文件格式错误#define LDF_PARSER_DEV_DISCONNECT    (-3)//设备未连接#define LDF_PARSER_HANDLE_ERROR      (-4)//LDF Handle错误#define LDF_PARSER_GET_INFO_ERROR    (-5)//获取解析后的数据出错#define LDF_PARSER_DATA_ERROR        (-6)//数据处理错误#define LDF_PARSER_SLAVE_NACK        (-7)//从机未响应数据#ifdef __cplusplusextern &quot;C&quot;{#endif    long long WINAPI LDF_ParserFile(int DevHandle, int LINIndex, unsigned char isMaster, char* pLDFFileName);    int WINAPI LDF_GetProtocolVersion(long long LDFHandle);    int WINAPI LDF_GetLINSpeed(long long LDFHandle);    int WINAPI LDF_GetFrameQuantity(long long LDFHandle);    int WINAPI LDF_GetFrameName(long long LDFHandle, int index, char* pFrameName);    int WINAPI LDF_GetFrameSignalQuantity(long long LDFHandle, char* pFrameName);    int WINAPI LDF_GetFrameSignalName(long long LDFHandle, char* pFrameName, int index, char* pSignalName);    int WINAPI LDF_SetSignalValue(long long LDFHandle, char* pFrameName, char* pSignalName, double Value);    int WINAPI LDF_GetSignalValue(long long LDFHandle, char* pFrameName, char* pSignalName, double *pValue);    int WINAPI LDF_GetSignalValueStr(long long LDFHandle, char* pFrameName, char* pSignalName, char* pValueStr);    int WINAPI LDF_SetFrameRawValue(long long LDFHandle, char* pFrameName, unsigned char* pRawData);    int WINAPI LDF_GetFrameRawValue(long long LDFHandle, char* pFrameName, unsigned char* pRawData);    int WINAPI LDF_GetFramePublisher(long long LDFHandle, char* pFrameName, char* pPublisher);    int WINAPI LDF_GetMasterName(long long LDFHandle,  char* pMasterName);    int WINAPI LDF_GetSchQuantity(long long LDFHandle);    int WINAPI LDF_GetSchName(long long LDFHandle, int index, char* pSchName);    int WINAPI LDF_GetSchFrameQuantity(long long LDFHandle, char* pSchName);    int WINAPI LDF_GetSchFrameName(long long LDFHandle, char* pSchName, int index, char* pFrameName);    int WINAPI LDF_ExeFrameToBus(long long LDFHandle, char* pFrameName);    int WINAPI LDF_ExeSchToBus(long long LDFHandle, char* pSchName);#ifdef __cplusplus}#endif#endif","ldf_parser.h","topics\\API函数接口定义原型/C/ldf_parser.htm","/*******************************************************************************  * @file    LDFDecoder.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   LDF文件解析相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __LDFDECODER_H_#define __LDFDECODER_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif#define LDF_SUCCESS                 0   //操作成功#define LDF_ERROR_FILE_OPEN         (-1)//打开文件出错#define LDF_ERROR_FILE_FORMAT       (-2)//文件格式错误#define LDF_ERROR_DEV_DISCONNECT    (-3)//设备未连接//逻辑类型编码值typedef struct _LDF_CODING_LOGICAL{    int RawValue;       //实际值    char *pDescription; //逻辑值编码字符串}LDF_CODING_LOGICAL;//物理类型编码值，信号物理值=信号实际值*Factor+Offsettypedef struct _LDF_CODING_PHYSICAL{    double Offset;   //信号物理值偏移量    double Factor;   //信号缩放因子    long long Minimum;    //信号实际最小值，注意不是物理值    long long Maximum;    //信号实际最大值，注意不是物理值    char *pUnit;    //信号物理值单位}LDF_CODING_PHYSICAL;//信号中的值类型enum LDF_SIGNAL_VALUE_TYPE{    LDF_SIGNAL_VALUE_TYPE_SCALAR,   //标量值    LDF_SIGNAL_VALUE_TYPE_ARRAY     //数组值};//信号值编码类型enum LDF_SIGNAL_CODING_TYPE{    LDF_SIGNAL_CODING_TYPE_NONE,    LDF_SIGNAL_CODING_TYPE_PHYSICAL,//物理值    LDF_SIGNAL_CODING_TYPE_LOGICAL  //逻辑值};//信号类型enum LDF_SIGNAL_TYPE{    LDF_SIGNAL_TYPE_NORMAL,    LDF_SIGNAL_TYPE_DIAGNOSTIC};//帧类型enum LDF_FRAME_TYPE{    LDF_FRAME_TYPE_NORMAL,    LDF_FRAME_TYPE_DIAGNOSTIC};//信号编码typedef struct _LDF_SIGNAL_CODING{    char *pName;                            //信号编码名称    int LogicalValueLen;                    //逻辑值长度    int PhysicalValueLen;                   //物理值长度    LDF_CODING_LOGICAL *pLogicalValues;     //逻辑值列表指针    LDF_CODING_PHYSICAL *pPhysicalValues;   //物理值列表指针}LDF_SIGNAL_CODING;//信号和信号编码对应值typedef struct _LDF_SIGNAL_REPRESENTATION{    char *pSignalName;  //信号名称    char *pCodingName;  //编码名称}LDF_SIGNAL_REPRESENTATION;//信号值结构体，结构体里面的值二取一，并不是同时存在typedef struct _LDF_SIGNAL_VALUE{    long long ScalarValue;      //物理值    unsigned char ArrayValue[8];//数组}LDF_SIGNAL_VALUE;//信号编码typedef struct _LDF_LIN_SIGNAL{    char *pName;                    //信号名称    int Size;                       //信号大小，单位为bit    LDF_SIGNAL_TYPE Type;           //普通信号或者诊断信号    LDF_SIGNAL_VALUE_TYPE ValueType;//数值或者数组    LDF_SIGNAL_VALUE Value;         //信号值    char *pPublisher;               //信号发布者名称，可能为主机或者从机    int SubscriberLen;              //接收该信号节点长度    char *pSubscribers[16];         //接收该信号的节点名称数组    int Offset;                     //该信号在8字节数据中的偏移量    LDF_SIGNAL_CODING SignalCodings;//信号编码}LDF_LIN_SIGNAL;//帧，每帧数据包含多个信号typedef struct _LDF_LIN_FRAME{    char *pName;                //帧名称    unsigned char ID;           //帧ID    char *pPublisher;           //发布者名称    unsigned char Size;         //帧长度，单位为字节    LDF_FRAME_TYPE Type;        //帧类型    int SignalListLen;          //信号长度    LDF_LIN_SIGNAL *pSignalList;//信号指针}LDF_LIN_FRAME;//节点结构体typedef struct _LDF_LIN_NODE{    char *pMasterName;      //主机名称    float time_base;    float jitter;    int SlaveLen;           //从机数量    char *pSlaveNames[16];  //从机名称数组}LDF_LIN_NODE;//调度表命令typedef struct _LDF_LIN_SCH_CMD{    LDF_LIN_FRAME Frame;    //LIN帧    float DelayOfMs;        //延时时间，单位为毫秒}LDF_LIN_SCH_CMD;//调度表typedef struct _LDF_LIN_SCH{    char *pName;                        //调度表名称    int ScheduleCmdLen;                 //该表下面包含的帧数    LDF_LIN_SCH_CMD *pScheduleCmdList;  //改表下面的帧列表}LDF_LIN_SCH;//节点属性typedef struct _LDF_NODE_ATTR{    char *pName;    unsigned short LIN_protocol;    unsigned char configured_NAD;    unsigned char initial_NAD;    struct {        unsigned int supplier_id;        unsigned int function_id;        unsigned int variant;    }product_id;    char *response_error;//signal_name    char *fault_state_signals[64];    int fault_state_signal_len;    float P2_min;    float ST_min;    float N_As_timeout;    float N_Cr_timeout;    char *configurable_frames[64];    int configurable_frame_len;}LDF_NODE_ATTR;//解析后的LDF文件内容typedef struct _LDF_CODING{    int ProtocolVersion;        //LIN protocol version,实际版本号的一百倍值，比如当前值为210，那么实际版本为2.1    int LanguageVersion;        //LIN language version,实际版本号的一百倍值，比如当前值为210，那么实际版本为2.1    int DevHandle;    int LINSpeed;               //LIN总线波特率，单位为bps    int LINIndex;               //LIN通道号    bool isMaster;              //当前节点为主节点还是从节点    bool HaveInit;              //已经成功初始化    LDF_LIN_NODE *pNode;        //节点指针    int FrameLen;               //帧长度    LDF_LIN_FRAME *pFrames;     //帧指针    int NodeAttrLen;            //节点属性长度    LDF_NODE_ATTR *pNodeAttrs;  //节点属性指针    int LINSchLen;              //调度表长度    LDF_LIN_SCH *pLINSch;       //调度表指针}LDF_CODING;#ifdef __cplusplusextern &quot;C&quot;{#endif    int WINAPI LDF_Decode(int DevHandle,char *pLDFFileName,LDF_CODING *pLDFCoding);    int WINAPI LDF_DataRawToFrame(LDF_LIN_FRAME *pFrame,unsigned char *pRawData);    int WINAPI LDF_DataFrameToRaw(LDF_LIN_FRAME *pFrame,unsigned char *pRawData);#ifdef __cplusplus}#endif#endif","LDFDecoder.h","topics\\API函数接口定义原型/C/LDFDecoder.htm","/**  ******************************************************************************  * @file    lin_uds.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   lin_uds相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __LIN_UDS_H_#define __LIN_UDS_H_#include &lt;stdint.h&gt;#include &quot;usb2lin_ex.h&quot;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif#define LIN_UDS_OK            0#define LIN_UDS_TRAN_USB      -98#define LIN_UDS_TRAN_LIN      -99#define LIN_UDS_TIMEOUT_A     -100#define LIN_UDS_TIMEOUT_Bs    -101#define LIN_UDS_TIMEOUT_Cr    -102#define LIN_UDS_WRONG_SN      -103#define LIN_UDS_INVALID_FS    -104#define LIN_UDS_UNEXP_PDU     -105#define LIN_UDS_WFT_OVRN      -106#define LIN_UDS_BUFFER_OVFLW  -107#define LIN_UDS_ERROR         -108//1.LIN UDS地址定义typedef  struct  _LIN_UDS_ADDR{    unsigned char   ReqID; //请求报文ID。    unsigned char   ResID; //应答报文ID。    unsigned char   NAD;   //节点地址，0x7F为广播地址    unsigned char   CheckType;//0-标准，1-增强    unsigned char   STmin;  //连续帧时间间隔，单位为毫秒}LIN_UDS_ADDR;#ifdef __cplusplusextern &quot;C&quot;{#endif    int WINAPI LIN_UDS_Request(int DevHandle,unsigned char LINIndex,LIN_UDS_ADDR *pUDSAddr,unsigned char *pReqData,int DataLen);    int WINAPI LIN_UDS_Response(int DevHandle,unsigned char LINIndex,LIN_UDS_ADDR *pUDSAddr,unsigned char *pResData,int TimeOutMs);    int WINAPI LIN_UDS_GetMsgFromUDSBuffer(int DevHandle,unsigned char LINIndex,LIN_EX_MSG *pLINMsg,int BufferSize);#ifdef __cplusplus}#endif#endif","lin_uds.htm","topics\\API函数接口定义原型/C/lin_uds.htm","/**  ******************************************************************************  * @file    mlx_programer.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   mlx_programer相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __MLX_PROGRAMER_H_#define __MLX_PROGRAMER_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义函数返回错误代码#define MLX_SUCCESS             (0)     //函数执行成功#define MLX_ERR_OPEN_DEV        (-1)    //打开设备失败#define MLX_ERR_INIT_DEV        (-2)    //初始化设备失败#define MLX_ERR_FILE_FORMAT     (-3)    //文件格式错误#define MLX_ERR_BEGIN_PROG      (-4)    //进入编程模式错误#define MLX_ERR_CMD_FAIL        (-5)    //命令执行失败#define MLX_ERR_WRITE_FLASH     (-6)    //写Flash失败#ifdef __cplusplusextern &quot;C&quot;{#endif    int WINAPI MLX_ProgInit(int DeviceHandle, unsigned char LINChannel,unsigned char BaudRateOfKbps,unsigned char UseFastLIN);    int WINAPI MLX_ProgNVRAM(int DeviceHandle, unsigned char LINChannel, const char* nvramFileName, uint8_t nad);    int WINAPI MLX_ProgFlash(int DeviceHandle, unsigned char LINChannel, const char* LoaderFileName, const char* AppFileName, uint8_t nad);#ifdef __cplusplus}#endif#endif","mlx_programer.h","topics\\API函数接口定义原型/C/mlx_programer.htm","/**  ******************************************************************************  * @file    uart_sniffer.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   uart sniffer相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __UART_SNIFFER_H_#define __UART_SNIFFER_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endiftypedef enum{     IDLE = 0x00,    START,    DATA,    PARITY,    STOP,}UART_DATA_TYPE;typedef unsigned short UART_DATA;typedef struct{    int BaudRate;    int WordLength;    int StopBits;    int Parity;}UART_SNIFFER_CONFIG;//解析到UART数据后的回调函数typedef  int (WINAPI UART_GET_DATA_HANDLE)(int DevHandle,int Channel,UART_DATA *pUARTData,int UartDataNum);//识别到波特率后的回调函数typedef  int (WINAPI UART_GET_BAUDRATE_HANDLE)(int DevHandle,int Channel,int BaudRateHz);//定义函数返回错误代码#define SUCCESS             (0)   //函数执行成功#define ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define ERR_CMD_FAIL        (-4)  //命令执行失败#ifdef __cplusplusextern &quot;C&quot;{#endif    int WINAPI UART_SnifferGetBaudRate(int DevHandle,int Channel,unsigned int SampleRateHz,UART_GET_BAUDRATE_HANDLE *pGetBaudRateHandle);    int WINAPI UART_SnifferStart(int DevHandle,unsigned char ChannelMask,UART_SNIFFER_CONFIG *pUartSnifferConfig,UART_GET_DATA_HANDLE *pGetUartDataHandle);    int WINAPI UART_SnifferStop(int DevHandle);#ifdef __cplusplus}#endif#endif","uart_sniffer.h","topics\\API函数接口定义原型/C/uart_sniffer.htm","/**  ******************************************************************************  * @file    usb_device.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   设备操作相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB_DEVICE_H_#define __USB_DEVICE_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义设备信息typedef struct _DEVICE_INFO{    char    FirmwareName[32];   //固件名称字符串    char    BuildDate[32];      //固件编译时间字符串    int     HardwareVersion;    //硬件版本号    int     FirmwareVersion;    //固件版本号    int     SerialNumber[3];    //适配器序列号    int     Functions;          //适配器当前具备的功能}DEVICE_INFO,*PDEVICE_INFO;//定义电压输出值#define POWER_LEVEL_NONE    0   //不输出#define POWER_LEVEL_1V8     1   //输出1.8V#define POWER_LEVEL_2V5     2   //输出2.5V#define POWER_LEVEL_3V3     3   //输出3.3V#define POWER_LEVEL_5V0     4   //输出5.0V#ifdef __cplusplusextern &quot;C&quot;{#endif/**  * @brief  初始化USB设备，并扫描设备连接数，必须调用  * @param  pDevHandle 每个设备的设备号存储地址  * @retval 扫描到的设备数量  */#ifdef __OS_ANDROID_BACKint WINAPI USB_ScanDevice(int *pDevHandle,int *pFd,int DevNum);#elseint  WINAPI USB_ScanDevice(int *pDevHandle);#endif/**  * @brief  打开设备，必须调用  * @param  DevHandle 设备索引号  * @retval 打开设备的状态  */bool WINAPI USB_OpenDevice(int DevHandle);/**  * @brief  关闭设备  * @param  DevHandle 设备索引号  * @retval 关闭设备的状态  */bool WINAPI USB_CloseDevice(int DevHandle);/**  * @brief  复位设备程序，复位后需要重新调用USB_ScanDevice，USB_OpenDevice函数  * @param  DevHandle 设备索引号  * @retval 复位设备的状态  */bool WINAPI USB_ResetDevice(int DevHandle);/**  * @brief  获取设备信息，比如设备名称，固件版本号，设备序号，设备功能说明字符串等  * @param  DevHandle 设备索引号  * @param  pDevInfo 设备信息存储结构体指针  * @param  pFunctionStr 设备功能说明字符串  * @retval 获取设备信息的状态  */bool WINAPI DEV_GetDeviceInfo(int DevHandle,PDEVICE_INFO pDevInfo,char *pFunctionStr);/**  * @brief  擦出用户区数据  * @param  DevHandle 设备索引号  * @retval 用户区数据擦出状态  */bool WINAPI DEV_EraseUserData(int DevHandle);/**  * @brief  向用户区域写入用户自定义数据，写入数据之前需要调用擦出函数将数据擦出  * @param  DevHandle 设备索引号  * @param  OffsetAddr 数据写入偏移地址，起始地址为0x00，用户区总容量为0x10000字节，也就是64KBye  * @param  pWriteData 用户数据缓冲区首地址  * @param  DataLen 待写入的数据字节数  * @retval 写入用户自定义数据状态  */bool WINAPI DEV_WriteUserData(int DevHandle,int OffsetAddr,unsigned char *pWriteData,int DataLen);/**  * @brief  从用户自定义数据区读出数据  * @param  DevHandle 设备索引号  * @param  OffsetAddr 数据写入偏移地址，起始地址为0x00，用户区总容量为0x10000字节，也就是64KBye  * @param  pReadData 用户数据缓冲区首地址  * @param  DataLen 待读出的数据字节数  * @retval 读出用户自定义数据的状态  */bool WINAPI DEV_ReadUserData(int DevHandle,int OffsetAddr,unsigned char *pReadData,int DataLen);/**  * @brief  设置可变电压输出引脚输出电压值  * @param  DevHandle 设备索引号  * @param  PowerLevel 输出电压值  * @retval 设置输出电压状态  */bool WINAPI DEV_SetPowerLevel(int DevHandle,char PowerLevel);/**  * @brief  或者CAN或者LIN的时间戳原始值  * @param  DevHandle 设备索引号  * @param  pTimestamp 时间戳指针  * @retval 获取时间戳状态  */bool WINAPI DEV_GetTimestamp(int DevHandle,char BusType,unsigned int *pTimestamp);/**  * @brief  复位CAN/LIN时间戳，需要在初始化CAN/LIN之后调用  * @param  DevHandle 设备索引号  * @retval 复位时间戳状态  */bool WINAPI DEV_ResetTimestamp(int DevHandle);bool WINAPI DEV_EraseSchData(int DevHandle,unsigned int Addr);bool WINAPI DEV_WriteSchData(int DevHandle,int OffsetAddr,unsigned char *pWriteData,int DataLen);bool WINAPI DEV_ReadSchData(int DevHandle,int OffsetAddr,unsigned char *pReadData,int DataLen);#ifdef __cplusplus}#endif#endif","usb_device.h","topics\\API函数接口定义原型/C/usb_device.htm","/**  ******************************************************************************  * @file    usb2adc.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2adc相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2ADC_H_#define __USB2ADC_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义函数返回错误代码#define ADC_SUCCESS             (0)   //函数执行成功#define ADC_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define ADC_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define ADC_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define ADC_ERR_CMD_FAIL        (-4)  //命令执行失败#define ADC_ERR_CH_NO_INIT      (-5)  //该通道未初始化//定义连续采集数据模式下的回调函数typedef  int (WINAPI *PADC_GET_DATA_HANDLE)(int DevHandle,unsigned short *pData,int DataNum);//接收数据回掉函数#ifdef __cplusplusextern &quot;C&quot;{#endif/**  * @brief  初始化配置ADC  * @param  DevHandle 设备索引号  * @param  Channel 需要配置的ADC通道，每个bit为对应一个通道，为1时则需要配置该通道，最低位代表通道0  * @param  SampleRateHz ADC采样率，单通道最大2.5MHz，单位为Hz  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI ADC_Init(int DevHandle,char Channel,int SampleRateHz);/**  * @brief  启动并驱动ADC转换值  * @param  DevHandle 设备索引号  * @param  pData 数据存储缓冲区首地址  * @param  DataNum 获取转换的数据数，每个数据之间的时间间隔为初始化配置时候的采样频率决定  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI ADC_Read(int DevHandle,short *pData,int DataNum);/**  * @brief  启动ADC连续转换模式  * @param  DevHandle 设备索引号  * @param  Channel 需要配置的ADC通道，每个bit为对应一个通道，为1时则需要配置该通道，最低位代表通道0  * @param  SampleRateHz ADC采样率，单通道最大2.5MHz，单位为Hz  * @param  FrameSize 连续采样时每次传输数据个数SampleRateHz*1000/FrameSize最好大于或者等于20  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI ADC_StartContinueRead(int DevHandle,char Channel,int SampleRateHz,int FrameSize,PADC_GET_DATA_HANDLE pGetDataHandle);/**  * @brief  停止ADC连续转换模式  * @param  DevHandle 设备索引号  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI ADC_StopContinueRead(int DevHandle);/**  * @brief  获取ADC连续转换模式下存储在数据缓冲区中的数据值  * @param  DevHandle 设备索引号  * @param  pDataBuffer 数据存储缓冲区首地址  * @param  BufferSize 数据存储缓冲区大下，注意单位为短整型，不是字节，缓冲区最小为10240，否则获取不到数据  * @retval 成功获取到的数据数（单位为短整型）  */int WINAPI ADC_GetData(int DevHandle,unsigned short *pDataBuffer,int BufferSize);#ifdef __cplusplus}#endif#endif","usb2adc.h","topics\\API函数接口定义原型/C/usb2adc.htm","/**  ******************************************************************************  * @file    usb2ads1256.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2ads1256相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2ADS1256_H_#define __USB2ADS1256_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义函数返回错误代码#define ADS1256_SUCCESS             (0)   //函数执行成功#define ADS1256_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define ADS1256_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define ADS1256_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define ADS1256_ERR_CMD_FAIL        (-4)  //命令执行失败#define ADS1256_ERR_CH_NO_INIT      (-5)  //该通道未初始化//定义ADS采样率#define ADS1256_DRATE_30000SPS   0xF0 #define ADS1256_DRATE_15000SPS   0xE0 #define ADS1256_DRATE_7500SPS   0xD0 #define ADS1256_DRATE_3750SPS   0xC0 #define ADS1256_DRATE_2000SPS   0xB0 #define ADS1256_DRATE_1000SPS   0xA1 #define ADS1256_DRATE_500SPS    0x92 #define ADS1256_DRATE_100SPS    0x82 #define ADS1256_DRATE_60SPS     0x72 #define ADS1256_DRATE_50SPS     0x63 #define ADS1256_DRATE_30SPS     0x53 #define ADS1256_DRATE_25SPS     0x43 #define ADS1256_DRATE_15SPS     0x33 #define ADS1256_DRATE_10SPS     0x23 #define ADS1256_DRATE_5SPS      0x13 #define ADS1256_DRATE_2_5SPS    0x03//定义初始化ADS1256的数据类型typedef struct _ADS1256_CONFIG{  unsigned short  SampleRate;   //采样率  unsigned char   PGA;          //内部增益，2^n  unsigned char   BufferEn;     //1：使能Buffer,0：禁止Buffer  unsigned int    SampleMode;   //两个bit控制一个通道，00：不使用该通道，01：该通道为单端模式，10：该通道为差分负极，11：该通道为差分正极}ADS1256_CONFIG,*PADS1256_CONFIG;#ifdef __cplusplusextern &quot;C&quot;{#endif/**  * @brief  初始化配置ADS1256  * @param  DevHandle 设备索引号  * @param  Channel 需要配置的ADS通道号，取值0或者1  * @param  pConfig ADS1256配置参数指针  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI ADS1256_Init(int DevHandle,char Channel,ADS1256_CONFIG *pConfig);/**  * @brief  启动ADS转换，调用该函数后，适配器会自动读取ADS转换数据  * @param  DevHandle 设备索引号  * @param  Channel 需要启动的ADS通道号，取值0或者1  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI ADS1256_Start(int DevHandle,char Channel);/**  * @brief  启动ADC连续转换模式  * @param  DevHandle 设备索引号  * @param  Channel 需要读取数据的ADS通道号，取值0或者1  * @param  pData 数据存储缓冲区首地址  * @retval 函数执行状态，小于0函数执行出错，大于0为实际采集到的ADC数据  */int WINAPI ADS1256_Read(int DevHandle,char Channel,int *pData);/**  * @brief  停止ADS转换，调用该函数后，适配器会自动停止ADS转换数据  * @param  DevHandle 设备索引号  * @param  Channel 需要启动的ADS通道号，取值0或者1  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI ADS1256_Stop(int DevHandle,char Channel);#ifdef __cplusplus}#endif#endif","usb2ads1256.h","topics\\API函数接口定义原型/C/usb2ads1256.htm","/**  ******************************************************************************  * @file    usb2can.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2can相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2CAN_H_#define __USB2CAN_H_#include &lt;stdint.h&gt;#include &quot;offline_type.h&quot;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//1.CAN信息帧的数据类型定义typedef  struct  _CAN_MSG{    unsigned int    ID;           //报文ID。    unsigned int    TimeStamp;    //接收到信息帧时的时间标识，从CAN 控制器初始化开始计时。    unsigned char   RemoteFlag;   //是否是远程帧    unsigned char   ExternFlag;   //是否是扩展帧    unsigned char   DataLen;      //数据长度(&lt;=8)，即Data 的长度。    unsigned char   Data[8];      //报文的数据。    unsigned char   TimeStampHigh;//时间戳高位}CAN_MSG,*PCAN_MSG;//2.初始化CAN的数据类型定义typedef struct _CAN_INIT_CONFIG{    //CAN波特率 = 100MHz/(CAN_BRP)/(CAN_SJW+CAN_BS1+CAN_BS2)    unsigned int    CAN_BRP;    //取值范围1~1024    unsigned char   CAN_SJW;    //取值范围1~4    unsigned char   CAN_BS1;    //取值范围1~16    unsigned char   CAN_BS2;    //取值范围1~8    unsigned char   CAN_Mode;   //CAN工作模式，0-正常模式，1-环回模式，2-静默模式，3-静默环回模式，bit7为1则接入适配器内部终端电阻，否则不接入    unsigned char   CAN_ABOM;   //自动离线管理，0-禁止，1-使能    unsigned char   CAN_NART;   //报文重发管理，0-使能报文重传，1-禁止报文重传    unsigned char   CAN_RFLM;   //FIFO锁定管理，0-新报文覆盖旧报文，1-丢弃新报文    unsigned char   CAN_TXFP;   //发送优先级管理，0-标识符决定，1-发送请求顺序决定}CAN_INIT_CONFIG,*PCAN_INIT_CONFIG;//3.CAN 滤波器设置数据类型定义typedef struct _CAN_FILTER_CONFIG{    unsigned char   Enable;         //使能该过滤器，1-使能，0-禁止    unsigned char   FilterIndex;    //过滤器索引号，取值范围为0到13    unsigned char   FilterMode;     //过滤器模式，0-屏蔽位模式，1-标识符列表模式    unsigned char   ExtFrame;       //过滤的帧类型标志，为1 代表要过滤的为扩展帧，为0 代表要过滤的为标准帧。    unsigned int    ID_Std_Ext;     //验收码ID    unsigned int    ID_IDE;         //验收码IDE    unsigned int    ID_RTR;         //验收码RTR    unsigned int    MASK_Std_Ext;   //屏蔽码ID，该项只有在过滤器模式为屏蔽位模式时有用    unsigned int    MASK_IDE;       //屏蔽码IDE，该项只有在过滤器模式为屏蔽位模式时有用    unsigned int    MASK_RTR;       //屏蔽码RTR，该项只有在过滤器模式为屏蔽位模式时有用} CAN_FILTER_CONFIG,*PCAN_FILTER_CONFIG;//4.CAN总线状态数据类型定义typedef struct _CAN_STATUS{    unsigned int    TSR;    unsigned int    ESR;    unsigned char   RECounter;  //CAN 控制器接收错误寄存器。    unsigned char   TECounter;  //CAN 控制器发送错误寄存器。    unsigned char   LECode;     //最后的错误代码}CAN_STATUS,*PCAN_STATUS;//5.定义CAN Bootloader命令列表typedef  struct  _CBL_CMD_LIST{    //Bootloader相关命令    unsigned char   Erase;          //擦出APP储存扇区数据    unsigned char   WriteInfo;      //设置多字节写数据相关参数（写起始地址，数据量）    unsigned char   Write;          //以多字节形式写数据    unsigned char   Check;          //检测节点是否在线，同时返回固件信息    unsigned char   SetBaudRate;    //设置节点波特率    unsigned char   Excute;         //执行固件    //节点返回状态    unsigned char    CmdSuccess;      //命令执行成功    unsigned char    CmdFaild;        //命令执行失败} CBL_CMD_LIST,*PCBL_CMD_LIST; //6.函数返回错误代码定义#define CAN_SUCCESS             (0)   //函数执行成功#define CAN_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define CAN_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define CAN_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define CAN_ERR_CMD_FAIL        (-4)  //命令执行失败#define CAN_BL_ERR_CONFIG       (-20) //配置设备错误#define CAN_BL_ERR_SEND         (-21) //发送数据出错#define CAN_BL_ERR_TIME_OUT     (-22) //超时错误#define CAN_BL_ERR_CMD          (-23) //执行命令失败#define CAN_BOOT_ERR_CONFIG       (-30) //配置设备错误#define CAN_BOOT_ERR_SEND         (-31) //发送数据出错#define CAN_BOOT_ERR_TIME_OUT     (-32) //超时错误#define CAN_BOOT_ERR_CMD          (-33) //执行命令失败#define CAN_BOOT_ERR_BAUD         (-34) //波特率参数自动获取失败#define CAN_BOOT_ERR_BUFFER       (-35) //从设备返回接收数据缓冲区大小为0//7.CAN Bootloader固件类型#define CAN_BL_BOOT     0x55555555#define CAN_BL_APP      0xAAAAAAAA//8.中继模式定义#define CAN_RELAY_NONE      0x00    //关闭中继功能#define CAN_RELAY_CAN1TO2   0x01    //CAN1 --&gt; CAN2 CAN1收到数据后通过CAN2转发出去#define CAN_RELAY_CAN2TO1   0x10    //CAN2 --&gt; CAN1 CAN2收到数据后通过CAN1转发出去#define CAN_RELAY_CANALL    0x11    //CAN1 &lt;-&gt; CAN2 CAN1收到数据后通过CAN2转发出去,CAN2收到数据后通过CAN1转发出去#define CAN_RELAY_ONLINE    0x88	//根据中继数据进行在线转换，需要调用CAN_SetOnlineRelayData函数#ifdef __cplusplusextern &quot;C&quot;{#endifint WINAPI CAN_Init(int DevHandle, unsigned char CANIndex, PCAN_INIT_CONFIG pCanConfig);int WINAPI CAN_Filter_Init(int DevHandle, unsigned char CANIndex, PCAN_FILTER_CONFIG pFilterConfig);int WINAPI CAN_StartGetMsg(int DevHandle, unsigned char CANIndex);int WINAPI CAN_StopGetMsg(int DevHandle, unsigned char CANIndex);int WINAPI CAN_SendMsg(int DevHandle, unsigned char CANIndex, PCAN_MSG pCanSendMsg,unsigned int SendMsgNum);int WINAPI CAN_GetMsg(int DevHandle, unsigned char CANIndex, PCAN_MSG pCanGetMsg);int WINAPI CAN_GetMsgWithSize(int DevHandle, unsigned char CANIndex, CAN_MSG *pCanGetMsg,int BufferSize);int WINAPI CAN_ClearMsg(int DevHandle, unsigned char CANIndex);int WINAPI CAN_GetStatus(int DevHandle, unsigned char CANIndex, PCAN_STATUS pCANStatus);//以调度表的方式发送数据，可以精确的控制每帧之间的间隔时间/**  * @brief  设置CAN调度表数据  * @param  DevHandle 设备索引号  * @param  CANIndex CAN通道号，取值0或者1  * @param  pCanMsgTab CAN调度表列表首地址  * @param  pMsgNum 调度表列表中每个调度表包含消息帧数  * @param  pSendTimes 每个调度表里面帧发送次数，若为0xFFFF，则循环发送，通过调用CAN_StopSchedule函数停止调用  * @param  MsgTabNum 调度表数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI CAN_SetSchedule(int DevHandle, unsigned char CANIndex, PCAN_MSG pCanMsgTab,unsigned char *pMsgNum,unsigned short *pSendTimes,unsigned char MsgTabNum);/**  * @brief  启动调度表  * @param  DevHandle 设备索引号  * @param  CANIndex CAN通道号，取值0或者1  * @param  MsgTabIndex CAN调度表索引号  * @param  TimePrecMs 调度表时间精度，比如调度表里面最小帧周期为10ms，那么就建议设置为10  * @param  OrderSend 设置为1则顺序发送调度表里面的帧，设置为0则并行发送调度表里面的帧   * @retval 函数执行状态，小于0函数执行出错  */int WINAPI CAN_StartSchedule(int DevHandle, unsigned char CANIndex, unsigned char MsgTabIndex,unsigned char TimePrecMs,unsigned char OrderSend);/**  * @brief  停止调度方式发送数据  * @param  DevHandle 设备索引号  * @param  CANIndex CAN通道号，取值0或者1  * @param  MsgTabIndex CAN调度表索引号  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI CAN_StopSchedule(int DevHandle, unsigned char CANIndex);//CAN中继相关函数int WINAPI CAN_SetRelayData(int DevHandle, CAN_RELAY_HEAD *pCANRelayHead, CAN_RELAY_DATA *pCANRelayData);int WINAPI CAN_GetRelayData(int DevHandle, CAN_RELAY_HEAD *pCANRelayHead, CAN_RELAY_DATA *pCANRelayData);int WINAPI CAN_SetRelay(int DevHandle, unsigned char RelayState);//老版本接口函数，不建议再使用int WINAPI CAN_BL_Init(int DevHandle,int CANIndex,PCAN_INIT_CONFIG pInitConfig,PCBL_CMD_LIST pCmdList);int WINAPI CAN_BL_NodeCheck(int DevHandle,int CANIndex,unsigned short NodeAddr,unsigned int *pVersion,unsigned int *pType,unsigned int TimeOut);int WINAPI CAN_BL_Erase(int DevHandle,int CANIndex,unsigned short NodeAddr,unsigned int FlashSize,unsigned int TimeOut);int WINAPI CAN_BL_Write(int DevHandle,int CANIndex,unsigned short NodeAddr,unsigned int AddrOffset,unsigned char *pData,unsigned int DataNum,unsigned int TimeOut);int WINAPI CAN_BL_Excute(int DevHandle,int CANIndex,unsigned short NodeAddr,unsigned int Type);int WINAPI CAN_BL_SetNewBaudRate(int DevHandle,int CANIndex,unsigned short NodeAddr,PCAN_INIT_CONFIG pInitConfig,unsigned int NewBaudRate,unsigned int TimeOut);int WINAPI  CAN_DecodeListFile(char *pFileName,unsigned int *pIgnoreIDList,int IgnoreIDListLen);int WINAPI  CAN_GetListFileMsg(int MsgIndex,int MsgLen,CAN_MSG *pCANMsg);#ifdef __cplusplus}#endif#endif","usb2can.h","topics\\API函数接口定义原型/C/usb2can.htm","/**  ******************************************************************************  * @file    usb2canfd.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2canfd相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2CANFD_H_#define __USB2CANFD_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//函数返回值错误信息定义#define CANFD_SUCCESS             (0)   //函数执行成功#define CANFD_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define CANFD_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define CANFD_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define CANFD_ERR_CMD_FAIL        (-4)  //命令执行失败//CANFD_MSG.ID定义#define CANFD_MSG_FLAG_RTR      (0x40000000)#define CANFD_MSG_FLAG_IDE      (0x80000000)#define CANFD_MSG_FLAG_ID_MASK  (0x1FFFFFFF)//CANFD_MSG.Flags定义#define CANFD_MSG_FLAG_BRS      (0x01)  //CANFD加速帧标志#define CANFD_MSG_FLAG_ESI      (0x02)#define CANFD_MSG_FLAG_FDF      (0x04)  //CANFD帧标志#define CANFD_MSG_FLAG_TXD      (0x80)//CANFD_DIAGNOSTIC.Flags定义#define CANFD_DIAGNOSTIC_FLAG_NBIT0_ERR     (0x0001)//在发送报文（或应答位、主动错误标志或过载标志）期间，器件要发送显性电平（逻辑值为0的数据或标识符位），但监视的总线值为隐性。#define CANFD_DIAGNOSTIC_FLAG_NBIT1_ERR     (0x0002)//在发送报文（仲裁字段除外）期间，器件要发送隐性电平（逻辑值为1的位），但监视到的总线值为显性。#define CANFD_DIAGNOSTIC_FLAG_NACK_ERR      (0x0004)//发送报文未应答。#define CANFD_DIAGNOSTIC_FLAG_NFORM_ERR     (0x0008)//接收报文的固定格式部分格式错误。#define CANFD_DIAGNOSTIC_FLAG_NSTUFF_ERR    (0x0010)//在接收报文的一部分中，序列中包含了5个以上相等位，而报文中不允许出现这种序列。#define CANFD_DIAGNOSTIC_FLAG_NCRC_ERR      (0x0020)//接收的报文的CRC校验和不正确。输入报文的CRC与通过接收到的数据计算得到的CRC不匹配。#define CANFD_DIAGNOSTIC_FLAG_TXBO_ERR      (0x0080)//器件进入离线状态（且自动恢复）。#define CANFD_DIAGNOSTIC_FLAG_DBIT0_ERR     (0x0100)//见NBIT0_ERR#define CANFD_DIAGNOSTIC_FLAG_DBIT1_ERR     (0x0200)//见NBIT1_ERR#define CANFD_DIAGNOSTIC_FLAG_DFORM_ERR     (0x0800)//见NFORM_ERR#define CANFD_DIAGNOSTIC_FLAG_DSTUFF_ERR    (0x1000)//见NSTUFF_ERR#define CANFD_DIAGNOSTIC_FLAG_DCRC_ERR      (0x2000)//见NCRC_ERR#define CANFD_DIAGNOSTIC_FLAG_ESI_ERR       (0x4000)//接收的CAN FD报文的ESI标志置1#define CANFD_DIAGNOSTIC_FLAG_DLC_MISMATCH  (0x8000)//DLC不匹配,在发送或接收期间，指定的DLC大于FIFO元素的PLSIZE//CANFD_BUS_ERROR.Flags定义#define CANFD_BUS_ERROR_FLAG_TX_RX_WARNING   (0x01)#define CANFD_BUS_ERROR_FLAG_RX_WARNING      (0x02)#define CANFD_BUS_ERROR_FLAG_TX_WARNING      (0x04)#define CANFD_BUS_ERROR_FLAG_RX_BUS_PASSIVE  (0x08)#define CANFD_BUS_ERROR_FLAG_TX_BUS_PASSIVE  (0x10)#define CANFD_BUS_ERROR_FLAG_TX_BUS_OFF      (0x20)//1.CANFD信息帧的数据类型定义typedef  struct  _CANFD_MSG{    unsigned int    ID;           //报文ID,bit[30]-RTR,bit[31]-IDE,bit[28..0]-ID    unsigned char   DLC;          //数据字节长度，可设置为-0,1,2,3,4,5,6,7,8,12,16,20,24,32,48,64    unsigned char   Flags;        //bit[0]-BRS,bit[1]-ESI,bit[2]-FDF,bit[6..5]-Channel,bit[7]-RXD    unsigned char   __Res0;       //保留    unsigned char   TimeStampHigh;//时间戳高位    unsigned int    TimeStamp;    //帧接收或者发送时的时间戳，单位为10us    unsigned char   Data[64];     //报文的数据。}CANFD_MSG;//2.CANFD初始化配置数据类型定义typedef  struct  _CANFD_INIT_CONFIG{    unsigned char Mode; //0-正常模式，1-自发自收模式    unsigned char ISOCRCEnable;//0-禁止ISO CRC,1-使能ISO CRC    unsigned char RetrySend;//0-禁止重发，1-无限制重发    unsigned char ResEnable;//0-不接入内部120欧终端电阻，1-接入内部120欧终端电阻    //波特率参数可以用TCANLINPro软件里面的波特率计算工具计算    //仲裁段波特率参数,波特率=40M/NBT_BRP*(1+NBT_SEG1+NBT_SEG2)    unsigned char NBT_BRP;    unsigned char NBT_SEG1;    unsigned char NBT_SEG2;    unsigned char NBT_SJW;    //数据段波特率参数,波特率=40M/DBT_BRP*(1+DBT_SEG1+DBT_SEG2)    unsigned char DBT_BRP;    unsigned char DBT_SEG1;    unsigned char DBT_SEG2;    unsigned char DBT_SJW;    unsigned char __Res0[8];}CANFD_INIT_CONFIG;//3.CANFD诊断帧信息结构体定义typedef struct _CANFD_DIAGNOSTIC {    unsigned char NREC;//标称比特率接收错误计数    unsigned char NTEC;//标称比特率发送错误计数    unsigned char DREC;//数据比特率接收错误计数    unsigned char DTEC;//数据比特率发送错误计数    unsigned short ErrorFreeMsgCount;//无错误帧计数    unsigned short Flags;//参考诊断标志定义}CANFD_DIAGNOSTIC;//4.CANFD总线错误信息结构体定义typedef struct _CANFD_BUS_ERROR {    unsigned char TEC;//发送错误计数    unsigned char REC;//接收错误计数    unsigned char Flags;//参考总线错误标志定义    unsigned char __Res0;}CANFD_BUS_ERROR;//5.CAN 滤波器设置数据类型定义typedef struct _CANFD_FILTER_CONFIG{    unsigned char   Enable;   //使能该过滤器，1-使能，0-禁止    unsigned char   Index;    //过滤器索引号，取值范围为0到31    unsigned char __Res0;    unsigned char __Res1;    unsigned int    ID_Accept;//验收码ID,bit[28..0]为有效ID位，bit[31]为IDE    unsigned int    ID_Mask;  //屏蔽码，对应bit位若为1，则需要对比对应验收码bit位，相同才接收}CANFD_FILTER_CONFIG;#ifdef __cplusplusextern &quot;C&quot;{#endifint WINAPI CANFD_Init(int DevHandle, unsigned char CANIndex, CANFD_INIT_CONFIG *pCanConfig);int WINAPI CANFD_StartGetMsg(int DevHandle, unsigned char CANIndex);int WINAPI CANFD_StopGetMsg(int DevHandle, unsigned char CANIndex);int WINAPI CANFD_SendMsg(int DevHandle, unsigned char CANIndex, CANFD_MSG *pCanSendMsg,unsigned int SendMsgNum);int WINAPI CANFD_GetMsg(int DevHandle, unsigned char CANIndex, CANFD_MSG *pCanGetMsg,int BufferSize);int WINAPI CANFD_ClearMsg(int DevHandle, unsigned char CANIndex);int WINAPI CANFD_SetFilter(int DevHandle, unsigned char CANIndex, CANFD_FILTER_CONFIG *pCanFilter,unsigned char Len);int WINAPI CANFD_GetDiagnostic(int DevHandle, unsigned char CANIndex, CANFD_DIAGNOSTIC *pCanDiagnostic);int WINAPI CANFD_GetBusError(int DevHandle, unsigned char CANIndex, CANFD_BUS_ERROR *pCanBusError);/**  * @brief  设置CAN调度表数据  * @param  DevHandle 设备索引号  * @param  CANIndex CAN通道号，取值0或者1  * @param  pCanMsgTab CAN调度表列表首地址  * @param  pMsgNum 调度表列表中每个调度表包含消息帧数  * @param  pSendTimes 每个调度表里面帧发送次数，若为0xFFFF，则循环发送，通过调用CAN_StopSchedule函数停止调用  * @param  MsgTabNum 调度表数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI CANFD_SetSchedule(int DevHandle, unsigned char CANIndex, CANFD_MSG *pCanMsgTab,unsigned char *pMsgNum,unsigned short *pSendTimes,unsigned char MsgTabNum);/**  * @brief  启动调度表  * @param  DevHandle 设备索引号  * @param  CANIndex CAN通道号，取值0或者1  * @param  MsgTabIndex CAN调度表索引号  * @param  TimePrecMs 调度表时间精度，比如调度表里面最小帧周期为10ms，那么就建议设置为10  * @param  OrderSend 设置为1则顺序发送调度表里面的帧，设置为0则并行发送调度表里面的帧   * @retval 函数执行状态，小于0函数执行出错  */int WINAPI CANFD_StartSchedule(int DevHandle, unsigned char CANIndex, unsigned char MsgTabIndex,unsigned char TimePrecMs,unsigned char OrderSend);/**  * @brief  停止调度方式发送数据  * @param  DevHandle 设备索引号  * @param  CANIndex CAN通道号，取值0或者1  * @param  MsgTabIndex CAN调度表索引号  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI CANFD_StopSchedule(int DevHandle, unsigned char CANIndex);int WINAPI CANFD_SetRelay(int DevHandle, unsigned char RelayState);int WINAPI CANFD_SetRelayData(int DevHandle, CAN_RELAY_HEAD *pCANRelayHead, CAN_RELAY_DATA *pCANRelayData);int WINAPI CANFD_GetRelayData(int DevHandle, CAN_RELAY_HEAD *pCANRelayHead, CAN_RELAY_DATA *pCANRelayData);#ifdef __cplusplus}#endif#endif","usb2canfd.h","topics\\API函数接口定义原型/C/usb2canfd.htm","/**  ******************************************************************************  * @file    usb2cnt.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2cnt相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2CNT_H_#define __USB2CNT_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义初始化Counter的数据类型typedef struct _CNT_CONFIG{  unsigned char   CounterMode;      //计数模式，0-Up,1-Down  unsigned char   CounterPolarity;  //计数极性，0-Rising，1-Falling，2-BothEdge  unsigned char   CounterBitWide;   //计数位宽，16-16bit位宽，32-32bit位宽  unsigned char   CounterPinMode;   //计数器输入引脚模式，0-浮空输入，1-上拉输入，2-下拉输入}CNT_CONFIG,*PCNT_CONFIG;//定义函数返回错误代码#define CNT_SUCCESS             (0)   //函数执行成功#define CNT_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define CNT_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define CNT_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define CNT_ERR_CMD_FAIL        (-4)  //命令执行失败//计数器模式#define COUNTER_MODE_UP     0#define COUNTER_MODE_DOWN   1//计数器触发条件#define COUNTER_POL_RISING     0#define COUNTER_POL_FALLING    1#define COUNTER_POL_BOTHEDGE   2//计数器宽度#define COUNTER_BITS16        16#define COUNTER_BITS32        32//计数器输入引脚模式#define  COUNTER_PIN_NOPULL     0x00#define  COUNTER_PIN_UP         0x01#define  COUNTER_PIN_DOWN       0x02//计数器通道定义#define COUNTER_CH0             0x01#define COUNTER_CH1             0x02#define COUNTER_CH2             0x04#define COUNTER_CH3             0x08#ifdef __cplusplusextern &quot;C&quot;{#endifint WINAPI CNT_Init(int DevHandle, unsigned char ChannelMask, PCNT_CONFIG pConfig);int WINAPI CNT_Start(int DevHandle, unsigned char ChannelMask);int WINAPI CNT_Stop(int DevHandle, unsigned char ChannelMask);int WINAPI CNT_SetValue(int DevHandle, unsigned char ChannelMask,unsigned int *pCntValues);int WINAPI CNT_GetValue(int DevHandle, unsigned char ChannelMask,unsigned int *pCntValues);#ifdef __cplusplus}#endif#endif","usb2cnt.h","topics\\API函数接口定义原型/C/usb2cnt.htm","/**  ******************************************************************************  * @file    usb2dac.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2dac相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2DAC_H_#define __USB2DAC_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义函数返回错误代码#define DAC_SUCCESS             (0)   //函数执行成功#define DAC_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define DAC_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define DAC_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define DAC_ERR_CMD_FAIL        (-4)  //命令执行失败#define DAC_ERR_CH_NO_INIT      (-5)  //该通道未初始化#ifdef __cplusplusextern &quot;C&quot;{#endif/**  * @brief  初始化配置DAC并输出信号  * @param  DevHandle 设备索引号  * @param  CycleUs 数据输出时间间隔，单位为0.25us，数据输出总时间=0.25*CycleUs*WaveDataNum us  * @param  pWaveData 待输出的数据缓冲区指针，数据最大值为0xFFF,对应电压为3.3V  * @param  WaveDataNum 输出的数据点数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI DAC_Init(int DevHandle,unsigned short CycleUs,unsigned short *pWaveData,unsigned short WaveDataNum);/**  * @brief  启动DAC并输出信号  * @param  DevHandle 设备索引号  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI DAC_Start(int DevHandle);/**  * @brief  停止DAC输出信号  * @param  DevHandle 设备索引号  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI DAC_Stop(int DevHandle);#ifdef __cplusplus}#endif#endif","usb2dac.h","topics\\API函数接口定义原型/C/usb2dac.htm","/**  ******************************************************************************  * @file    usb2ew.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2ew相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2EW_H_#define __USB2EW_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义函数返回错误代码#define EW_SUCCESS             (0)   //函数执行成功#define EW_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define EW_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define EW_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define EW_ERR_CMD_FAIL        (-4)  //命令执行失败//通道定义#define EW_CH0             (0x01&lt;&lt;0)#define EW_CH1             (0x01&lt;&lt;1)#define EW_CH2             (0x01&lt;&lt;2)#define EW_CH3             (0x01&lt;&lt;3)#define EW_CH4             (0x01&lt;&lt;4)#define EW_CH5             (0x01&lt;&lt;5)#define EW_CH6             (0x01&lt;&lt;6)#define EW_CH7             (0x01&lt;&lt;7)#define EW_CH8             (0x01&lt;&lt;8)#define EW_CH9             (0x01&lt;&lt;9)#define EW_CH10            (0x01&lt;&lt;10)#define EW_CH11            (0x01&lt;&lt;11)#define EW_CH12            (0x01&lt;&lt;12)#define EW_CH13            (0x01&lt;&lt;13)#define EW_CH14            (0x01&lt;&lt;14)#define EW_CH15            (0x01&lt;&lt;15)//时序定义typedef struct __EW_TIMING{  int tDS;          //Data start time  int tEOD_H;       //End of data high time   int tEOD_L;       //End of data low time  int tH_LB;        //High time low bit(0)  int tL_LB;        //Low time low bit(0)  int tH_HB;        //High time high bit(1)  int tL_HB;        //Low time high bit(1)}EW_TIMING,*PEW_TIMING;#ifdef __cplusplusextern &quot;C&quot;{#endifint WINAPI EW_Init(int DevHandle, unsigned int ChannelMask, EW_TIMING *pEWTiming);int WINAPI EW_WriteBytes(int DevHandle, unsigned int ChannelMask,unsigned char Address,unsigned char WriteData);#ifdef __cplusplus}#endif#endif","usb2ew.h","topics\\API函数接口定义原型/C/usb2ew.htm","/**  ******************************************************************************  * @file    usb2gpio.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2gpio相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2GPIO_H_#define __USB2GPIO_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义函数返回错误代码#define GPIO_SUCCESS             (0)   //函数执行成功#define GPIO_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define GPIO_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define GPIO_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define GPIO_ERR_CMD_FAIL        (-4)  //命令执行失败//上下拉电阻配置#define GPIO_PUPD_NOPULL        0x00    //没有上拉下拉#define GPIO_PUPD_UP            0x01    //使能上拉#define GPIO_PUPD_DOWN          0x02    //使能下拉#ifdef __cplusplusextern &quot;C&quot;{#endif/**  * @brief  将GPIO引脚设置为输入模式  * @param  DevHandle 设备索引号  * @param  PinMask 需要设置为输入模式的引脚，每个bit位代表一个引脚，对应bit位为1时改引脚对设置有效，最低位为P0  * @param  PuPd 0-浮空输入，无上拉或者下拉，1-上拉输入，2-下拉输入  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI GPIO_SetInput(int DevHandle,unsigned int PinMask, unsigned char PuPd);/**  * @brief  将GPIO引脚设置为输出模式  * @param  DevHandle 设备索引号  * @param  PinMask 需要设置为输出模式的引脚，每个bit位代表一个引脚，对应bit位为1时改引脚对设置有效，最低位对应P0  * @param  PuPd 0-推挽输出，无上拉或者下拉，1-上拉输出，2-下拉输出  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI GPIO_SetOutput(int DevHandle,unsigned int PinMask, unsigned char PuPd);/**  * @brief  将GPIO引脚设置为开漏模式，该模式下可作为双向引脚  * @param  DevHandle 设备索引号  * @param  PinMask 需要设置为开漏模式的引脚，每个bit位代表一个引脚，对应bit位为1时改引脚对设置有效，最低位对应P0  * @param  PuPd 0-内部无上拉或者下拉，1-使能上拉，2-使能下拉  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI GPIO_SetOpenDrain(int DevHandle,unsigned int PinMask, unsigned char PuPd);/**  * @brief  设置GPIO引脚的输出状态  * @param  DevHandle 设备索引号  * @param  PinMask 需要输出状态的引脚，每个bit位代表一个引脚，对应bit位为1时改引脚对设置有效，最低位对应P0  * @param  PinValue 对应引脚的状态，每个bit位代表一个引脚，对应bit位为1输出高电平，为0输出低电平，最低位对应P0  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI GPIO_Write(int DevHandle,unsigned int PinMask, unsigned int PinValue);/**  * @brief  获取GPIO引脚的输入状态  * @param  DevHandle 设备索引号  * @param  PinMask 需要获取状态的引脚，每个bit位代表一个引脚，对应bit位为1时改引脚对设置有效，最低位对应P0  * @param  pPinValue 对应引脚的状态，每个bit位代表一个引脚，对应bit位为1引脚为高电平，为0引脚为低电平，最低位对应P0  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI GPIO_Read(int DevHandle,unsigned int PinMask, unsigned int *pPinValue);/**  * @brief  控制GPIO输出高脉冲  * @param  DevHandle 设备索引号  * @param  PinMask 需要获取状态的引脚，每个bit位代表一个引脚，对应bit位为1时改引脚对设置有效，最低位对应P0  * @param  PulseWidthUs 高脉冲宽度，单位为微秒  * @param  PulsePeriodUs 脉冲输出周期，单位为为微秒，必须大于等于PulseWidthUs  * @param  PulseNum 脉冲输出个数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI GPIO_SendPulses(int DevHandle,unsigned int PinMask,unsigned int PulseWidthUs,unsigned int PulsePeriodUs,unsigned int PulseNum);#ifdef __cplusplus}#endif#endif","usb2gpio.h","topics\\API函数接口定义原型/C/usb2gpio.htm","/**  ******************************************************************************  * @file    usb2iic.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2iic相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2IIC_H_#define __USB2IIC_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义初始化IIC的数据类型typedef struct _IIC_CONFIG{  unsigned int    ClockSpeedHz; //IIC时钟频率:单位为Hz  unsigned short  OwnAddr;      //USB2XXX为从机时自己的地址  unsigned char   Master;       //主从选择控制:0-从机，1-主机  unsigned char   AddrBits;     //从机地址模式，7-7bit模式，10-10bit模式  unsigned char   EnablePu;     //使能引脚芯片内部上拉电阻，若不使能，则I2C总线上必须接上拉电阻}IIC_CONFIG,*PIIC_CONFIG;//定义函数返回错误代码#define IIC_SUCCESS             (0)   //函数执行成功#define IIC_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define IIC_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define IIC_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define IIC_ERR_CMD_FAIL        (-4)  //命令执行失败#define IIC_ERR_PARA_ERROR      (-5)  //参数传入错误//定义IIC函数返回错误代码#define IIC_ERROR_SUCCESS     0   //操作成功#define IIC_ERROR_CHANNEL     1   //该通道不支持该函数#define IIC_ERROR_BUSY        2   //总线忙#define IIC_ERROR_START_FAILD 3   //启动总线失败#define IIC_ERROR_TIMEOUT     4   //超时#define IIC_ERROR_NACK        5   //从机无应答#define IIC_ERROR_PEC         6   //PEC校验失败#ifdef __cplusplusextern &quot;C&quot;{#endifint WINAPI IIC_Init(int DevHandle,int IICIndex, PIIC_CONFIG pConfig);int WINAPI IIC_GetSlaveAddr(int DevHandle,int IICIndex,short *pSlaveAddr);int WINAPI IIC_WriteBytes(int DevHandle,int IICIndex,short SlaveAddr,unsigned char *pWriteData,int WriteLen,int TimeOutMs);int WINAPI IIC_ReadBytes(int DevHandle,int IICIndex,short SlaveAddr,unsigned char *pReadData,int ReadLen,int TimeOutMs);int WINAPI IIC_WriteReadBytes(int DevHandle,int IICIndex,short SlaveAddr,unsigned char *pWriteData,int WriteLen,unsigned char *pReadData,int ReadLen,int TimeOutMs);int WINAPI IIC_BlockWriteBytes(int DevHandle,int IICIndex,short SlaveAddr,unsigned char *pWriteData,int BlockSize,int BlockNum,int IntervalTimeUs);int WINAPI IIC_BlockReadBytes(int DevHandle,int IICIndex,short SlaveAddr,unsigned char *pReadData,int BlockSize,int BlockNum,int IntervalTimeUs);int WINAPI IIC_SlaveWriteBytes(int DevHandle,int IICIndex,unsigned char *pWriteData,int WriteLen,int TimeOutMs);int WINAPI IIC_SlaveReadBytes(int DevHandle,int IICIndex,unsigned char *pReadData,int TimeOutMs);int WINAPI IIC_SlaveWriteRemain(int DevHandle,int IICIndex);int WINAPI IIC_WriteBytesOfEvent(int DevHandle,int IICIndex,short SlaveAddr,unsigned char *pWriteData,int WriteLen,int EventPin,unsigned char EventType,int TimeOutOfEventMs);int WINAPI IIC_ReadBytesOfEvent(int DevHandle,int IICIndex,short SlaveAddr,unsigned char *pReadData,int ReadLen,int EventPin,unsigned char EventType,int TimeOutOfEventMs);int WINAPI IIC_WriteReadBytesOfEvent(int DevHandle,int IICIndex,short SlaveAddr,unsigned char *pWriteData,int WriteLen,unsigned char *pReadData,int ReadLen,int EventPin,unsigned char EventType,int TimeOutOfEventMs);int WINAPI SMBUS_Init(int DevHandle,int IICIndex,int ClockSpeedHz,unsigned char EnablePu);int WINAPI SMBUS_QuickCommand(int DevHandle,int IICIndex,short SlaveAddr,unsigned char WriteReadFlag);int WINAPI SMBUS_WriteByte(int DevHandle,int IICIndex,short SlaveAddr,unsigned char Data,unsigned char WithPEC);int WINAPI SMBUS_ReadByte(int DevHandle,int IICIndex,short SlaveAddr,unsigned char *pData,unsigned char WithPEC);int WINAPI SMBUS_WriteByteProtocol(int DevHandle,int IICIndex,short SlaveAddr,unsigned char CommandCode, unsigned char Data,unsigned char WithPEC);int WINAPI SMBUS_WriteWordProtocol(int DevHandle,int IICIndex,short SlaveAddr,unsigned char CommandCode, unsigned short Data,unsigned char WithPEC);int WINAPI SMBUS_ReadByteProtocol(int DevHandle,int IICIndex,short SlaveAddr,unsigned char CommandCode, unsigned char *pData,unsigned char WithPEC);int WINAPI SMBUS_ReadWordProtocol(int DevHandle,int IICIndex,short SlaveAddr,unsigned char CommandCode, unsigned short *pData,unsigned char WithPEC);int WINAPI SMBUS_ProcessCall(int DevHandle,int IICIndex,short SlaveAddr,unsigned char CommandCode, unsigned short WriteData, unsigned short *pReadData,unsigned char WithPEC);int WINAPI SMBUS_BlockWrite(int DevHandle,int IICIndex,short SlaveAddr,unsigned char CommandCode, unsigned char *pWriteData,int WriteCount,unsigned char WithPEC);int WINAPI SMBUS_BlockRead(int DevHandle,int IICIndex,short SlaveAddr,unsigned char CommandCode, unsigned char *pReadData,int *pReadCount,unsigned char WithPEC);int WINAPI SMBUS_BlockProcessCall(int DevHandle,int IICIndex,short SlaveAddr,unsigned char CommandCode, unsigned char *pWriteData,int WriteCount, unsigned char *pReadData,int *pReadCount,unsigned char WithPEC);#ifdef __cplusplus}#endif#endif","usb2iic.h","topics\\API函数接口定义原型/C/usb2iic.htm","/**  ******************************************************************************  * @file    usb2ir.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2ir相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2CNT_H_#define __USB2CNT_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//自定义波形输出时序参数struct IRTimeSeries{  unsigned int  DataTime;//输出DataType的时间，单位为0.25us  unsigned char DataType;//1-输出高电平或者调制波，0-输出低电平或者不输出调制波};typedef enum {    UNKNOWN      = -1,    UNUSED       =  0,    RC5,    RC6,    NEC,    SONY,    PANASONIC,    JVC,    SAMSUNG,    WHYNTER,    AIWA_RC_T501,    LG,    SANYO,    MITSUBISHI,    DISH,    SHARP,    DENON,    PRONTO,    LEGO_PF,}ir_type_t;typedef struct{  ir_type_t       Type;     // UNKNOWN, NEC, SONY, RC5, ...  unsigned char   Repeat;  unsigned short  Address;  // Used by Panasonic &amp; Sharp [16-bits]  unsigned int    Value;    // Decoded value [max 32-bits]  unsigned int    Bits;     // Number of bits in decoded value}ir_data_t;//定义函数返回错误代码#define IR_SUCCESS             (0)   //函数执行成功#define IR_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define IR_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define IR_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define IR_ERR_CMD_FAIL        (-4)  //命令执行失败//IR通道定义#define IR_CH0             0x0001#define IR_CH1             0x0002#define IR_CH2             0x0004#define IR_CH3             0x0008#define IR_CH4             0x0010#define IR_CH5             0x0020#define IR_CH6             0x0040#define IR_CH7             0x0080#define IR_CH8             0x0100#define IR_CH9             0x0200#define IR_CH10             0x0400#define IR_CH11             0x0800#define IR_CH12             0x1000#define IR_CH13             0x2000#define IR_CH14             0x4000#define IR_CH15             0x8000#define IR_CHALL            0xFFFF#ifdef __cplusplusextern &quot;C&quot;{#endifint WINAPI IR_NEC_Send(int DevHandle, unsigned int ChannelMask,unsigned char Adress,unsigned char Command,unsigned char HaveNot);int WINAPI IR_NEC_SendRepeat(int DevHandle, unsigned int ChannelMask);int WINAPI IR_ITT_Send(int DevHandle, unsigned int ChannelMask,unsigned char Adress,unsigned char Command);int WINAPI IR_JVC_Send(int DevHandle, unsigned int ChannelMask,unsigned char PrePulse,unsigned char Adress,unsigned char Command);int WINAPI IR_NRC17_Send(int DevHandle, unsigned int ChannelMask,unsigned char Adress,unsigned char Command,unsigned char SubCode);int WINAPI IR_RCA_Send(int DevHandle, unsigned int ChannelMask,unsigned char Adress,unsigned char Command);int WINAPI IR_USER_Send(int DevHandle, unsigned int ChannelMask,unsigned short ModulateHigh,unsigned short ModulateLow,struct IRTimeSeries *pIRTimeSeries,unsigned short TimeSeriesNum);int WINAPI IR_Send(int DevHandle, unsigned int ChannelMask,unsigned int MODFreqKHz,ir_data_t IRData);int WINAPI IR_SendRaw(int DevHandle, unsigned int ChannelMask,unsigned int MODFreqKHz,unsigned int *pIRRawData,unsigned int RawDataLen);#ifdef __cplusplus}#endif#endif","usb2ir.h","topics\\API函数接口定义原型/C/usb2ir.htm","/**  ******************************************************************************  * @file    usb2lin.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2lin相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2LIN_H_#define __USB2LIN_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义函数返回错误代码#define LIN_SUCCESS             (0)   //函数执行成功#define LIN_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define LIN_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define LIN_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define LIN_ERR_CMD_FAIL        (-4)  //命令执行失败#define LIN_ERR_CH_NO_INIT      (-5)  //该通道未初始化#define LIN_ERR_READ_DATA       (-6)  //LIN读数据失败//LIN和校验模式#define LIN_CHECK_MODE_STD     0#define LIN_CHECK_MODE_EXT     1#define LIN_CHECK_MODE_NONE    2//BREAK位数定义#define LIN_BREAK_BITS_10    0x00#define LIN_BREAK_BITS_11    0x20//定义主从模式#define LIN_MASTER          1#define LIN_SLAVE           0//定义从机操作模式#define LIN_SLAVE_WRITE     0#define LIN_SLAVE_READ      1//定义初始化LIN初始化数据类型typedef struct _LIN_CONFIG{  unsigned int  BaudRate;     //波特率,最大20K  unsigned char CheckMode;    //校验模式，0-标准校验模式，1-增强校验模式（包含PID）  unsigned char MasterMode;   //主从模式，0-从模式，1-主模式  unsigned char BreakBits;    //Break长度，0x00-10bit,0x20-11bit}LIN_CONFIG,*PLIN_CONFIG;//LIN数据收发帧格式定义typedef struct _LIN_MSG{    unsigned char ID;       //ID，取值范围0~0x3F    unsigned char DataLen;  //发送数据时，代表发送数据的长度，不含校验数据，接收数据时，数据的长度，包含校验数据    unsigned char Data[9];  //数据存储区}LIN_MSG,*PLIN_MSG;#ifdef __cplusplusextern &quot;C&quot;{#endifint WINAPI LIN_Init(int DevHandle,unsigned char LINIndex,LIN_CONFIG *pConfig);int WINAPI LIN_SendBreak(int DevHandle,unsigned char LINIndex);int WINAPI LIN_Write(int DevHandle,unsigned char LINIndex,LIN_MSG *pLINMsg,unsigned int Len);int WINAPI LIN_Read(int DevHandle,unsigned char LINIndex,LIN_MSG *pLINMsg,unsigned int Len);int WINAPI LIN_SlaveSetIDMode(int DevHandle,unsigned char LINIndex,unsigned char IDMode,LIN_MSG *pLINMsg,unsigned int Len);int WINAPI LIN_SlaveGetData(int DevHandle,unsigned char LINIndex,LIN_MSG *pLINMsg);#ifdef __cplusplus}#endif#endif","usb2lin.h","topics\\API函数接口定义原型/C/usb2lin.htm","/**  ******************************************************************************  * @file    usb2lin_ex.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2lin_ex相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2LIN_EX_H_#define __USB2LIN_EX_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//注意：使用这些函数需要1.5.30及以上的固件才支持//定义函数返回错误代码#define LIN_EX_SUCCESS             (0)   //函数执行成功#define LIN_EX_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define LIN_EX_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define LIN_EX_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define LIN_EX_ERR_CMD_FAIL        (-4)  //命令执行失败#define LIN_EX_ERR_CH_NO_INIT      (-5)  //该通道未初始化#define LIN_EX_ERR_READ_DATA       (-6)  //LIN读数据失败#define LIN_EX_ERR_PARAMETER       (-7)  //函数参数传入有误//校验类型#define LIN_EX_CHECK_STD     0  //标准校验，不含PID#define LIN_EX_CHECK_EXT     1  //增强校验，包含PID#define LIN_EX_CHECK_USER    2  //自定义校验类型，需要用户自己计算并传入Check，不进行自动校验#define LIN_EX_CHECK_NONE    3  //不计算校验数据#define LIN_EX_CHECK_ERROR   4  //接收数据校验错误//主从机定义#define LIN_EX_MASTER        1  //主机#define LIN_EX_SLAVE         0  //从机//VBAT电压输出，LIN_EX_CtrlPowerOut函数使用#define LIN_EX_VBAT_0V      0#define LIN_EX_VBAT_12V     1#define LIN_EX_VBAT_5V      2//帧类型#define LIN_EX_MSG_TYPE_UN      0  //未知类型#define LIN_EX_MSG_TYPE_MW      1  //主机向从机发送数据#define LIN_EX_MSG_TYPE_MR      2  //主机从从机读取数据#define LIN_EX_MSG_TYPE_SW      3  //从机发送数据#define LIN_EX_MSG_TYPE_SR      4  //从机接收数据#define LIN_EX_MSG_TYPE_BK      5  //只发送BREAK信号，若是反馈回来的数据，表明只检测到BREAK信号#define LIN_EX_MSG_TYPE_SY      6  //表明检测到了BREAK，SYNC信号#define LIN_EX_MSG_TYPE_ID      7  //表明检测到了BREAK，SYNC，PID信号#define LIN_EX_MSG_TYPE_DT      8  //表明检测到了BREAK，SYNC，PID,DATA信号#define LIN_EX_MSG_TYPE_CK      9  //表明检测到了BREAK，SYNC，PID,DATA,CHECK信号typedef struct _LIN_EX_MSG{    unsigned int  Timestamp;    //从机接收数据时代表时间戳，单位为0.1ms;主机读写数据时，表示数据读写后的延时时间，单位为ms    unsigned char MsgType;      //帧类型    unsigned char CheckType;    //校验类型    unsigned char DataLen;      //LIN数据段有效数据字节数    unsigned char Sync;         //固定值，0x55    unsigned char PID;          //帧ID    unsigned char Data[8];      //数据    unsigned char Check;        //校验,只有校验数据类型为LIN_EX_CHECK_USER的时候才需要用户传入数据    unsigned char BreakBits;    //该帧的BRAK信号位数，有效值为10到26，若设置为其他值则默认为13位    unsigned char Reserve1;}LIN_EX_MSG,*PLIN_EX_MSG;#ifdef __cplusplusextern &quot;C&quot;{#endif//初始化int WINAPI  LIN_EX_Init(int DevHandle,unsigned char LINIndex,unsigned int BaudRate,unsigned char MasterMode);//主机模式操作函数int WINAPI  LIN_EX_MasterSync(int DevHandle,unsigned char LINIndex,LIN_EX_MSG *pInMsg,LIN_EX_MSG *pOutMsg,unsigned int MsgLen);int WINAPI  LIN_EX_MasterBreak(int DevHandle,unsigned char LINIndex);int WINAPI  LIN_EX_MasterWrite(int DevHandle,unsigned char LINIndex,unsigned char PID,unsigned char *pData,unsigned char DataLen,unsigned char CheckType);int WINAPI  LIN_EX_MasterRead(int DevHandle,unsigned char LINIndex,unsigned char PID,unsigned char *pData);//从机模式操作函数int WINAPI  LIN_EX_SlaveSetIDMode(int DevHandle,unsigned char LINIndex,LIN_EX_MSG *pLINMsg,unsigned int MsgLen);int WINAPI  LIN_EX_SlaveGetIDMode(int DevHandle,unsigned char LINIndex,LIN_EX_MSG *pLINMsg);int WINAPI  LIN_EX_SlaveGetData(int DevHandle,unsigned char LINIndex,LIN_EX_MSG *pLINMsg);//电源控制相关函数int WINAPI  LIN_EX_CtrlPowerOut(int DevHandle,unsigned char LINIndex,unsigned char VbatValue);int WINAPI  LIN_EX_GetVbatValue(int DevHandle,unsigned short *pBatValue);//主机模式自动发送数据相关函数int WINAPI  LIN_EX_MasterStartSch(int DevHandle,unsigned char LINIndex,LIN_EX_MSG *pLINMsg,unsigned int MsgLen);int WINAPI  LIN_EX_MasterStopSch(int DevHandle,unsigned char LINIndex);int WINAPI  LIN_EX_MasterGetSch(int DevHandle,unsigned char LINIndex,LIN_EX_MSG *pLINMsg);int WINAPI  LIN_EX_DecodeListFile(char *pFileName,char CheckType,int BaudRate,char *pReadDataList,char ReadDataListLen,char *pCheckTypeList,char CheckTypeListLen);int WINAPI  LIN_EX_GetListFileMsg(int MsgIndex,int MsgLen,LIN_EX_MSG *pLINMsg);#ifdef __cplusplus}#endif#endif","usb2lin_ex.h","topics\\API函数接口定义原型/C/usb2lin_ex.htm","/**  ******************************************************************************  * @file    usb2nand.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2nand相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2NAND_H_#define __USB2NAND_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义NAND操作时序参数typedef struct _NAND_TIMING_COMFIG{  uint32_t FSMC_SetupTime;  uint32_t FSMC_WaitSetupTime;  uint32_t FSMC_HoldSetupTime;  uint32_t FSMC_HiZSetupTime;}NAND_TIMING_COMFIG,*PNAND_TIMING_COMFIG;//定义函数返回错误代码#define NAND_SUCCESS             (0)   //函数执行成功#define NAND_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define NAND_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define NAND_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define NAND_ERR_CMD_FAIL        (-4)  //命令执行失败#ifdef __cplusplusextern &quot;C&quot;{#endif/**  * @brief  初始化配置NAND接口，该函数必须调用  * @param  DevHandle 设备索引号  * @param  ChipIndex NAND芯片片选号，取值0或者1  * @param  PowerLevel NAND接口电压，1-1.8V，3-3.3V  * @param  pTimeConfig 对NAND进行读写操作的时间参数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_Init(int DevHandle,int ChipIndex,unsigned char PowerLevel,PNAND_TIMING_COMFIG pTimeConfig);//NAND操作底层函数，调用这些函数理论上可以读写控制任何NAND芯片，底层操作函数不会自动输出片选信号，需要程序控制片选信号输出/**  * @brief  控制片选信号输出低电平  * @param  DevHandle 设备索引号  * @param  ChipIndex NAND芯片片选号，取值0或者1  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_Select(int DevHandle,int ChipIndex);/**  * @brief  控制片选信号输出高电平  * @param  DevHandle 设备索引号  * @param  ChipIndex NAND芯片片选号，取值0或者1  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_Unselect(int DevHandle,int ChipIndex);/**  * @brief  NAND接口输出命令数据  * @param  DevHandle 设备索引号  * @param  pCmds 命令存储数据缓冲区  * @param  CmdsLen 需要发送的命令数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_SendCmd(int DevHandle,int ChipIndex,unsigned char *pCmds,unsigned char CmdsLen);/**  * @brief  NAND接口输出地址数据  * @param  DevHandle 设备索引号  * @param  pAddrs 地址存储数据缓冲区  * @param  AddrsLen 需要发送的地址数据字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_SendAddr(int DevHandle,int ChipIndex,unsigned char *pAddrs,unsigned char AddrsLen);/**  * @brief  NAND接口输出数据  * @param  DevHandle 设备索引号  * @param  pWriteData 数据存储缓冲区  * @param  WriteDataLen 需要发送的数据字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_WriteData(int DevHandle,int ChipIndex,unsigned char *pWriteData,unsigned int WriteDataLen);/**  * @brief  NAND接口读取数据  * @param  DevHandle 设备索引号  * @param  pReadData 数据存储缓冲区  * @param  ReadDataLen 需要读取的数据字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_ReadData(int DevHandle,int ChipIndex,unsigned char *pReadData,unsigned int ReadDataLen);/**  * @brief  等待NAND接口的RB信号变高  * @param  DevHandle 设备索引号  * @param  ChipIndex 需要等待的RB通道号，0-RB0，1-RB1  * @param  TimeOutOfMs 等待RB信号变高的超时时间，单位为毫秒，若设置为0则表示一直等待，直到变高后才返回  * @retval 函数执行状态，小于0函数执行出错,0-等待超时且RB为低，1-超时时间范围内检测到RB为高  */int WINAPI NAND_WaitReady(int DevHandle,int ChipIndex,unsigned int TimeOutOfMs);//NAND操作高层函数/**  * @brief  发送RESET(0xFF)命令并等待RB信号变高  * @param  DevHandle 设备索引号  * @param  ChipIndex CE和RB自动输出通道号，0-CE0,RB0;1-CE1,RB1  * @retval 函数执行状态，小于0函数执行出错,0-等待超时且RB为低，1-超时时间范围内检测到RB变高  */int WINAPI NAND_Reset(int DevHandle,int ChipIndex);/**  * @brief  获取NAND Flash芯片的状态信息  * @param  DevHandle 设备索引号  * @param  ChipIndex 自动输出的NAND芯片片选号，取值0或者1  * @param  pStatus 状态信息存储指针  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_ReadStatus(int DevHandle,int ChipIndex,unsigned int *pStatus);/**  * @brief  获取NAND Flash芯片ID信息  * @param  DevHandle 设备索引号  * @param  ChipIndex 自动输出的NAND芯片片选号，取值0或者1  * @param  IDAddr 读取ID的地址信息  * @param  pID 芯片ID存储缓冲区首地址  * @param  IDLen 读取ID数据字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_ReadID(int DevHandle,int ChipIndex,unsigned char IDAddr,unsigned char *pID,unsigned char IDLen);/**  * @brief  向NAND Flash写入数据，建议按照整页写，然后再将该函数返回的ECC写入备用区，以便以后读取的时候将读出数据的ECC和写入ECC做对比，实现对数据的校验  * @param  DevHandle 设备索引号  * @param  ChipIndex NAND芯片片选号，取值0或者1  * @param  pCmds 写数据的命令  * @param  CmdsLen 写数据命令字节数  * @param  pAddrs 写数据的地址  * @param  AddrLen 写数据的地址字节数  * @param  pWriteData 待写入NAND Flash芯片的数据缓冲区首地址  * @param  NumByteToWrite 待写入NAND Flash芯片的数据字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_WritePage(int DevHandle,int ChipIndex,unsigned char *pCmds,unsigned char CmdsLen,unsigned char *pAddrs,unsigned char AddrLen,unsigned char *pWriteData,int NumByteToWrite);/**  * @brief  从NAND Flash读出数据  * @param  DevHandle 设备索引号  * @param  ChipIndex NAND芯片片选号，取值0或者1  * @param  pCmds 读数据的命令  * @param  CmdsLen 读数据命令字节数  * @param  pAddrs 读数据的地址  * @param  AddrLen 读数据的地址字节数  * @param  pReadData 存储读出数据的缓冲区首地址  * @param  NumByteToRead 待读出的数据字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_ReadPage (int DevHandle,int ChipIndex, unsigned char *pCmds,unsigned char CmdsLen,unsigned char *pAddrs,unsigned char AddrLen,unsigned char *pReadData, int NumByteToRead);/**  * @brief  按块擦出NAND Flash数据，擦出后所有数据变成0xFF  * @param  DevHandle 设备索引号  * @param  ChipIndex NAND芯片片选号，取值0或者1  * @param  pCmds 擦除数据的命令  * @param  CmdsLen 擦除数据命令字节数  * @param  pAddrs 擦除数据的地址  * @param  AddrLen 擦除数据的地址字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI NAND_EraseBlock(int DevHandle,int ChipIndex,unsigned char *pCmds,unsigned char CmdsLen,unsigned char *pAddrs,unsigned char AddrLen);#ifdef __cplusplus}#endif#endif","usb2nand.h","topics\\API函数接口定义原型/C/usb2nand.htm","/**  ******************************************************************************  * @file    usb2openbus.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2openbus相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2OPENBUS_H_#define __USB2OPENBUS_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义函数返回错误代码#define OB_SUCCESS             (0)   //函数执行成功#define OB_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define OB_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define OB_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define OB_ERR_CMD_FAIL        (-4)  //命令执行失败//通道定义#define OB_CH0             (0)#define OB_CH1             (1)#define OB_CH2             (2)#define OB_CH3             (3)#define OB_CH4             (4)#define OB_CH5             (5)#define OB_CH6             (6)#define OB_CH7             (7)#define OB_CH8             (8)#define OB_CH9             (9)#define OB_CH10            (10)#define OB_CH11            (11)#define OB_CH12            (12)#define OB_CH13            (13)#define OB_CH14            (14)#define OB_CH15            (15)//内部上拉电阻定义#define OB_INTERNAL_NOPULL        0x00    //没有上拉下拉#define OB_INTERNAL_PULL          0x01    //使能上拉,芯片内部上拉很弱，可能会无法正常工作，建议使用外部上拉//定义数据类型typedef struct _OB_DATA{    char   Id;          //ID,低3bit有效    unsigned int Data;  //32bit}OB_DATA,*POB_DATA;#ifdef __cplusplusextern &quot;C&quot;{#endif/**  * @brief  初始化配置Openbus  * @param  DevHandle 设备索引号,通过调用USB_ScanDevice函数获得  * @param  Channel 总线通道号，取值0~7,P0对应通道0的Data引脚，P1对应通道0的Clk引脚，以此类推  * @param  EnInternalPull 是否使能引脚内部上拉电阻，总线引脚为开漏模式，需要外接上拉电阻才能输出高电平，若没有外接上拉电阻，可以使用内部上拉电阻，1-使用内部上拉，0-不使用内部上拉  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI OB_Init(int DevHandle, unsigned char Channel,unsigned char EnInternalPull);/**  * @brief  Openbus写数据  * @param  DevHandle 设备索引号,通过调用USB_ScanDevice函数获得  * @param  Channel 总线通道号，取值0~7,P0对应通道0的Data引脚，P1对应通道0的Clk引脚，以此类推  * @param  pWriteData 写数据结构体指针  * @param  WriteDataLen 写数据长度  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI OB_Write(int DevHandle, unsigned char Channel,OB_DATA *pWriteData,unsigned int WriteDataLen);/**  * @brief  Openbus读数据  * @param  DevHandle 设备索引号,通过调用USB_ScanDevice函数获得  * @param  Channel 总线通道号，取值0~7,P0对应通道0的Data引脚，P1对应通道0的Clk引脚，以此类推  * @param  pReadData 读数据结构体指针，读数据的时候需要先发送ID，所以在调用该函数的时候需要传入带ID信息的数据，然后才能依次获取每个ID对应的数据  * @param  ReadDataLen 读数据长度  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI OB_Read(int DevHandle, unsigned char Channel,OB_DATA *pReadData,unsigned int ReadDataLen);#ifdef __cplusplus}#endif#endif","usb2openbus.h","topics\\API函数接口定义原型/C/usb2openbus.htm","/**  ******************************************************************************  * @file    usb2ow.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2ow相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2OW_H_#define __USB2OW_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义函数返回错误代码#define OW_SUCCESS             (0)   //函数执行成功#define OW_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define OW_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define OW_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define OW_ERR_CMD_FAIL        (-4)  //命令执行失败#define OW_ERR_NO_ACK          (-5)  //无从设备应答//通道定义#define OW_CH0             (0x01&lt;&lt;0)#define OW_CH1             (0x01&lt;&lt;1)#define OW_CH2             (0x01&lt;&lt;2)#define OW_CH3             (0x01&lt;&lt;3)#define OW_CH4             (0x01&lt;&lt;4)#define OW_CH5             (0x01&lt;&lt;5)#define OW_CH6             (0x01&lt;&lt;6)#define OW_CH7             (0x01&lt;&lt;7)#define OW_CH8             (0x01&lt;&lt;8)#define OW_CH9             (0x01&lt;&lt;9)#define OW_CH10             (0x01&lt;&lt;10)#define OW_CH11             (0x01&lt;&lt;11)#define OW_CH12             (0x01&lt;&lt;12)#define OW_CH13            (0x01&lt;&lt;13)#define OW_CH14             (0x01&lt;&lt;14)#define OW_CH15             (0x01&lt;&lt;15)//内部上拉电阻定义#define OW_INTERNAL_NOPULL        0x00    //没有上拉下拉#define OW_INTERNAL_PULL          0x01    //使能上拉,芯片内部上拉很弱，可能会无法正常工作，建议使用外部上拉#ifdef __cplusplusextern &quot;C&quot;{#endifint WINAPI OW_Init(int DevHandle, unsigned int ChannelMask, unsigned int ResetTimeUs,unsigned char EnInternalPull);int WINAPI OW_Reset(int DevHandle, unsigned int ChannelMask);int WINAPI OW_WriteBytes(int DevHandle, unsigned int ChannelMask,unsigned char *pWriteData,unsigned int WriteDataLen);int WINAPI OW_ReadBytes(int DevHandle, unsigned int ChannelMask,unsigned char *pReadData,unsigned int ReadDataLen);int WINAPI OW_WriteReadBytes(int DevHandle, unsigned int ChannelMask,unsigned char *pWriteData,unsigned int WriteDataLen,unsigned char *pReadData,unsigned int ReadDataLen,unsigned int IntervalTimeUs);#ifdef __cplusplus}#endif#endif","usb2ow.h","topics\\API函数接口定义原型/C/usb2ow.htm","/**  ******************************************************************************  * @file    usb2pwm.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2pwm相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2PWM_H_#define __USB2PWM_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义初始化PWM的数据类型typedef struct _PWM_CONFIG{  unsigned short Prescaler[8];  //预分频器  unsigned short Precision[8];  //占空比调节精度,实际频率 = 200MHz/(Prescaler*Precision)  unsigned short Pulse[8];      //占空比，实际占空比=(Pulse/Precision)*100%  unsigned short Phase[8];      //波形相位，取值0到Precision-1  unsigned char  Polarity[8];   //波形极性，取值0或者1  unsigned char  ChannelMask;   //通道号，若要使能某个通道，则对应位为1，最低位对应通道0}PWM_CONFIG,*PPWM_CONFIG;//定义PWM测量数据typedef struct _PWM_CAP_DATA{  unsigned short LowValue;//低电平时间，单位为us  unsigned short HighValue;//高电平时间，单位为us}PWM_CAP_DATA;//定义函数返回错误代码#define PWM_SUCCESS             (0)   //函数执行成功#define PWM_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define PWM_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define PWM_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define PWM_ERR_CMD_FAIL        (-4)  //命令执行失败#ifdef __cplusplusextern &quot;C&quot;{#endif//UTA0403 UTA0402 UTA0401  LIN1对应的PWM通道为0x40,LIN2对应的PWM通道为0x80//UTA0503  LIN1对应的PWM通道为0x02,LIN2对应的PWM通道为0x04int WINAPI PWM_Init(int DevHandle, PPWM_CONFIG pConfig);int WINAPI PWM_Start(int DevHandle,unsigned char ChannelMask,unsigned int RunTimeUs);int WINAPI PWM_SetPulse(int DevHandle,unsigned char ChannelMask,unsigned short *pPulse);int WINAPI PWM_SetPhase(int DevHandle,unsigned char ChannelMask,unsigned short *pPhase);int WINAPI PWM_SetFrequency(int DevHandle,unsigned char ChannelMask,unsigned short *pPrescaler,unsigned short *pPrecision);int WINAPI PWM_Stop(int DevHandle,unsigned char ChannelMask);//LIN1对应的PWM通道为0,LIN2对应的PWM通道为1int WINAPI PWM_CAP_Init(int DevHandle, unsigned char Channel,unsigned char TimePrecUs);int WINAPI PWM_CAP_GetData(int DevHandle, unsigned char Channel,PWM_CAP_DATA *pPWMData);int WINAPI PWM_CAP_Stop(int DevHandle, unsigned char Channel);#ifdef __cplusplus}#endif#endif","usb2pwm.h","topics\\API函数接口定义原型/C/usb2pwm.htm","/**  ******************************************************************************  * @file    usb2sniffer.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   并口操作相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2SNIFFER_H_#define __USB2SNIFFER_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义函数返回错误代码#define SNIFFER_SUCCESS             (0)   //函数执行成功#define SNIFFER_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define SNIFFER_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define SNIFFER_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define SNIFFER_ERR_CMD_FAIL        (-4)  //命令执行失败#define SNIFFER_ERR_EVENT_TIMEOUT   (-5)  //事件发送超时#define SNIFFER_SAMPLE_MODE_1CH     (1)#define SNIFFER_SAMPLE_MODE_2CH     (2)#define SNIFFER_SAMPLE_MODE_4CH     (4)#define SNIFFER_SAMPLE_MODE_8CH     (8)#define SNIFFER_READ                (0)#define SNIFFER_WRITE               (1)//定义从机模式下连续读取数据的回调函数typedef  int (WINAPI SNIFFER_GET_DATA_HANDLE)(int DevHandle,unsigned char *pData,int DataNum);//接收数据回掉函数#ifdef __cplusplusextern &quot;C&quot;{#endif    int WINAPI SNIFFER_Init(int DevHandle,char WriteFlag,unsigned int SampleRateHz,char SampleMode);    int WINAPI SNIFFER_StartRead(int DevHandle,SNIFFER_GET_DATA_HANDLE *pGetDataHandle);    int WINAPI SNIFFER_StopRead(int DevHandle);    int WINAPI SNIFFER_GetData(int DevHandle,unsigned char *pDataBuffer,int BufferSize);    int WINAPI SNIFFER_WriteData(int DevHandle,unsigned char *pWriteData,int WriteLen);    int WINAPI SNIFFER_ReadData(int DevHandle,unsigned char *pReadData,int ReadLen);    int WINAPI SNIFFER_ContinueWriteData(int DevHandle,unsigned char *pWriteData,int WriteLen);    int WINAPI SNIFFER_ChangeContinueWriteData(int DevHandle,unsigned char *pWriteData,int WriteLen);    int WINAPI SNIFFER_StopContinueWrite(int DevHandle);    //双缓冲模式连续输出数据，WriteLen最大20480    int WINAPI SNIFFER_DBufferWriteDataOfEvent(int DevHandle,unsigned char *pWriteData,int WriteLen,unsigned char EventPin,unsigned char EventType,int TimeOutMs);    //更改双缓冲模式输出缓冲区中数据，WriteLen最大20480    int WINAPI SNIFFER_DBufferChangeDataOfEvent(int DevHandle,unsigned char *pWriteData,int WriteLen,unsigned char EventPin,unsigned char EventType,int TimeOutMs);    //通过事件触发模式输出数据    int WINAPI SNIFFER_WriteDataOfEvent(int DevHandle,unsigned char *pWriteData,int WriteLen,unsigned char EventPin,unsigned char EventType,int TimeOutMs);    //通过事件触发模式读取数据    int WINAPI SNIFFER_ReadDataOfEvent(int DevHandle,unsigned char *pReadData,int ReadLen,unsigned char EventPin,unsigned char EventType,int TimeOutMs);#ifdef __cplusplus}#endif#endif","usb2sniffer.h","topics\\API函数接口定义原型/C/usb2sniffer.htm","/**  ******************************************************************************  * @file    usb2spi.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2spi相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2SPI_H_#define __USB2SPI_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义SPI通道#define SPI1        (0x00)#define SPI1_CS0    (0x00)#define SPI1_CS1    (0x10)#define SPI1_CS2    (0x20)#define SPI1_CS3    (0x30)#define SPI1_CS4    (0x40)#define SPI2        (0x01)#define SPI2_CS0    (0x01)#define SPI2_CS1    (0x11)#define SPI2_CS2    (0x21)#define SPI2_CS3    (0x31)#define SPI2_CS4    (0x41)//定义工作模式#define SPI_MODE_HARD_FDX       0 //硬件控制（全双工模式）#define SPI_MODE_HARD_HDX       1 //硬件控制（半双工模式）#define SPI_MODE_SOFT_HDX       2 //软件控制（半双工模式）#define SPI_MODE_SOFT_ONE_WIRE  3 //单总线模式，数据线输入输出都为MOSI#define SPI_MODE_SOFT_FDX       4 //软件控制（全双工模式）//定义主从机模式#define SPI_MASTER      1 //主机#define SPI_SLAVE       0 //从机//定义数据移位方式#define SPI_MSB         0 //高位在前#define SPI_LSB         1 //低位在前//定义片选输出极性#define SPI_SEL_LOW     0 //片选输出低电平#define SPI_SEL_HIGH    1 //片选输出高电平//定义EVENT引脚,注意EVENT引脚不要跟SPI通信引脚冲突#define SPI_EVENT_P0    (1&lt;&lt;0)#define SPI_EVENT_P1    (1&lt;&lt;1)#define SPI_EVENT_P2    (1&lt;&lt;2)#define SPI_EVENT_P3    (1&lt;&lt;3)#define SPI_EVENT_P4    (1&lt;&lt;4)#define SPI_EVENT_P5    (1&lt;&lt;5)#define SPI_EVENT_P6    (1&lt;&lt;6)#define SPI_EVENT_P7    (1&lt;&lt;7)#define SPI_EVENT_P8    (1&lt;&lt;8)#define SPI_EVENT_P9    (1&lt;&lt;9)#define SPI_EVENT_P10    (1&lt;&lt;10)#define SPI_EVENT_P11    (1&lt;&lt;11)#define SPI_EVENT_P12    (1&lt;&lt;12)#define SPI_EVENT_P13    (1&lt;&lt;13)#define SPI_EVENT_P14    (1&lt;&lt;14)#define SPI_EVENT_P15    (1&lt;&lt;15)//定义事件类型#define EVENT_TYPE_LOW      0x00#define EVENT_TYPE_HIGH     0x11#define EVENT_TYPE_RISING   0x01#define EVENT_TYPE_FALLING  0x10//定义从机模式下连续读取数据的回调函数typedef  int (WINAPI *PSPI_GET_DATA_HANDLE)(int DevHandle,int SPIIndex,unsigned char *pData,int DataNum);//接收数据回掉函数//定义初始化SPI的数据类型typedef struct _SPI_CONFIG{    char   Mode;              //SPI控制方式:0-硬件控制（全双工模式）,1-硬件控制（半双工模式），2-软件控制（半双工模式）,3-单总线模式，数据线输入输出都为MOSI,4-软件控制（全双工模式）    char   Master;            //主从选择控制:0-从机，1-主机    char   CPOL;              //时钟极性控制:0-SCK空闲时为低电平，1-SCK空闲时为高电平    char   CPHA;              //时钟相位控制:0-第一个SCK时钟采样，1-第二个SCK时钟采样    char   LSBFirst;          //数据移位方式:0-MSB在前，1-LSB在前    char   SelPolarity;       //片选信号极性:0-低电平选中，1-高电平选中    unsigned int ClockSpeedHz;//SPI时钟频率:单位为HZ，硬件模式下最大50000000，最小390625，频率按2的倍数改变}SPI_CONFIG,*PSPI_CONFIG;//定义SPI Flash器件配置参数数据类型typedef struct _SPI_FLASH_CONFIG{    unsigned char CMD_WriteEnable;          //使能写命令    unsigned char CMD_WriteDisable;         //禁止写命令    unsigned char CMD_WritePage;            //写数据命令    unsigned char WritePageAddressBytes;    //写数据时的地址宽度，单位为字节    unsigned char CMD_EraseSector;          //扇区擦出命令    unsigned char EraseSectorAddressBytes;  //扇区擦出的地址宽度，单位为字节    unsigned char CMD_EraseBulk;            //块擦出命令    unsigned char CMD_EraseChip;            //整片擦出命令    unsigned char CMD_ReadID;               //读芯片ID命令    unsigned char CMD_ReadData;             //读数据命令    unsigned char ReadDataAddressBytes;     //读数据时的地址宽度，单位为字节    unsigned char CMD_ReadFast;             //快速模式读数据命令    unsigned char ReadFastAddressBytes;     //快速读数据时的地址宽度，单位为字节    unsigned char CMD_ReadStatus;           //读取状态寄存器命令    unsigned char CMD_WriteStatus;          //写状态寄存器命令    unsigned char ID[16];                   //芯片ID存储数组    unsigned char ID_Length;                //ID长度，单位为字节    int PageSize;                           //页大小，单位为字节    int NumPages;                           //芯片总的页数    int SectorSize;                         //扇区大小，单位为字节}SPI_FLASH_CONFIG,*PSPI_FLASH_CONFIG;//定义函数返回错误代码#define SPI_SUCCESS             (0)   //函数执行成功#define SPI_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define SPI_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define SPI_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define SPI_ERR_CMD_FAIL        (-4)  //命令执行失败#define SPI_ERR_PARAMETER       (-5)  //参数错误#define SPI_ERR_EVENT_TIMEOUT   (-6)  //检测Event超时#ifdef __cplusplusextern &quot;C&quot;{#endif/**  * @brief  SPI初始化配置函数  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pConfig SPI初始化配置结构体指针  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_Init(int DevHandle,int SPIIndex, PSPI_CONFIG pConfig);/**  * @brief  SPI发送数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 数据发送缓冲区首地址  * @param  WriteLen 数据发送字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_WriteBytes(int DevHandle,int SPIIndex,unsigned char *pWriteData,int WriteLen);/**  * @brief  SPI异步方式发送数据，函数调用之后不会等待数据发送完毕，该方式可以加大数据发送速率  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 数据发送缓冲区首地址  * @param  WriteLen 数据发送字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_WriteBytesAsync(int DevHandle,int SPIIndex,unsigned char *pWriteData,int WriteLen);/**  * @brief  SPI接收数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pReadData 数据接收缓冲区首地址  * @param  ReadLen 接收数据字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_ReadBytes(int DevHandle,int SPIIndex,unsigned char *pReadData,int ReadLen);/**  * @brief  SPI发送接收数据，全双工模式下发送和接收同时进行，半双工模式下发送和接收分开进行，整个操作过程片选一直有效  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 发送数据缓冲区首地址  * @param  WriteLen 发送数据字节数  * @param  pReadData 数据接收缓冲区首地址  * @param  ReadLen 接收数据字节数  * @param  IntervalTime 半双工模式下，发送数据和接收数据之间的时间间隔，单位为微妙  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_WriteReadBytes(int DevHandle,int SPIIndex,unsigned char *pWriteData,int WriteLen,unsigned char *pReadData,int ReadLen,int IntervalTimeUs);/**  * @brief  等到有效事件后SPI发送数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 数据发送缓冲区首地址  * @param  WriteLen 数据发送字节数  * @param  EventPin 等待事件的GPIO引脚  * @param  EventType 事件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿  * @param  TimeOutOfMs 等待事件超时时间，单位为毫秒  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_WriteBytesOfEvent(int DevHandle,int SPIIndex,unsigned char *pWriteData,int WriteLen,int EventPin,unsigned char EventType,int TimeOutOfMs);/**  * @brief  等到有效事件后SPI接收数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pReadData 数据接收缓冲区首地址  * @param  ReadLen 接收数据字节数  * @param  EventPin 等待事件的GPIO引脚  * @param  EventType 事件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿  * @param  TimeOutOfMs 等待事件超时时间，单位为毫秒  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_ReadBytesOfEvent(int DevHandle,int SPIIndex,unsigned char *pReadData,int ReadLen,int EventPin,unsigned char EventType,int TimeOutOfMs);/**  * @brief  等到有效事件后SPI发送接收数据，全双工模式下发送和接收同时进行，半双工模式下发送和接收分开进行，整个操作过程片选一直有效  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 发送数据缓冲区首地址  * @param  WriteLen 发送数据字节数  * @param  pReadData 数据接收缓冲区首地址  * @param  ReadLen 接收数据字节数  * @param  IntervalTime 半双工模式下，发送数据和接收数据之间的时间间隔，单位为微妙  * @param  EventPin 等待事件的GPIO引脚  * @param  EventType 事件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿  * @param  TimeOutOfMs 等待事件超时时间，单位为毫秒  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_WriteReadBytesOfEvent(int DevHandle,int SPIIndex,unsigned char *pWriteData,int WriteLen,unsigned char *pReadData,int ReadLen,int IntervalTimeUs,int EventPin,unsigned char EventType,int TimeOutOfMs);/**  * @brief  二进制模式写数据，该函数可以发送任意bit数数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteBitStr 二进制数据字符串，如：&quot;100110011&quot;  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_WriteBits(int DevHandle,int SPIIndex,char *pWriteBitStr);/**  * @brief  二进制模式读数据，该函数可以读取任意bit数数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pReadBitStr 读取到的二进制数据字符串，如：&quot;100110011&quot;  * @param  ReadBitsNum 读取数据的二进制bit数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_ReadBits(int DevHandle,int SPIIndex,char *pReadBitStr,int ReadBitsNum);/**  * @brief  二进制模式写读数据，该函数可以写读取任意bit数数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteBitStr 写二进制数据字符串，如：&quot;100110011&quot;  * @param  pReadBitStr 读取到的二进制数据字符串，如：&quot;100110011&quot;  * @param  ReadBitsNum 读取数据的二进制bit数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_WriteReadBits(int DevHandle,int SPIIndex,char *pWriteBitStr,char *pReadBitStr,int ReadBitsNum);/**  * @brief  SPI从机模式下将数据写入数据发送缓冲区，等待主机的时钟信号再将数据发送出去  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 发送数据缓冲区首地址  * @param  WriteLen 发送数据字节数  * @param  TimeOutMs 等待数据发送完毕超时时间，若小于或者等于0则不会等待数据发送完毕，函数立即返回  * @retval 函数执行状态，小于0函数执行出错，大于0表示成功发送的字节数  */int WINAPI SPI_SlaveWriteBytes(int DevHandle,int SPIIndex,unsigned char *pWriteData,int WriteLen,int TimeOutMs);/**  * @brief  SPI从机模式下接收数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pReadData 数据接收缓冲区首地址  * @param  pReadLen 准备接收数据的字节数  * @retval 函数执行状态，小于0函数执行出错，大于0表示接收到的数据字节数  */int WINAPI SPI_SlaveReadBytes(int DevHandle,int SPIIndex,unsigned char *pReadData,int ReadLen,int TimeOutMs);/**  * @brief  SPI从机模式下读写数据，全双工模式下读写数据同时进行，半双工模式下先读数据，然后再写数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pReadData 从机模式下接收数据缓冲区地址  * @param  ReadDataLen 从机模式下接收数据的长度  * @param  pReadReadLen 从机数据收发字节数  * @retval 函数执行状态，小于0函数执行出错，大于0则高16位是成功发送的数据字节数，低16位是成功读取的数据字节数  */int WINAPI SPI_SlaveReadWriteBytes(int DevHandle,int SPIIndex,unsigned char *pReadData,int ReadDataLen,unsigned char *pWriteData,int WriteDataLen,int TimeOutMs);/**  * @brief  SPI从机模式下同时发送接收数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 发送数据缓冲区首地址  * @param  WriteDataLen 从机数据发送字节数  * @param  pReadData 数据接收缓冲区首地址  * @param  pReadReadLen 从机数据读取字节数  * @retval 函数执行状态，小于0函数执行出错，大于0则高16位是成功发送的数据字节数，低16位是成功读取的数据字节数  */int WINAPI SPI_SlaveWriteReadBytes(int DevHandle,int SPIIndex,unsigned char *pWriteData,int WriteDataLen,unsigned char *pReadData,int ReadDataLen,int TimeOutMs);/**  * @brief  SPI从机模式下连续读取数据,SPI在从机模式下接收到数据之后，通过回调函数传出数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pSlaveReadDataHandle 从机模式下接收到数据后的回调函数，若传入NULL，则可以通过调用SPI_SlaveGetBytes函数来获取缓冲区中接收到的数据  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_SlaveContinueRead(int DevHandle,int SPIIndex,PSPI_GET_DATA_HANDLE pSlaveReadDataHandle);/**  * @brief  SPI从机模式下获取接收数据缓冲区的数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pReadData 数据接收缓冲区首地址  * @param  BufferSize 缓冲区长度  * @retval 获取到的数据字节数  */int WINAPI SPI_SlaveGetBytes(int DevHandle,int SPIIndex,unsigned char *pReadData,int BufferSize);/**  * @brief  从SPI数据缓冲区中读取数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pReadData 数据接收缓冲区首地址  * @param  TimeOutMs 等待数据超时时间  * @retval 获取到的数据字节数  */int WINAPI SPI_SlaveReadBytesFromBuffer(int DevHandle,int SPIIndex,unsigned char *pReadData,int TimeOutMs);/**  * @brief  停止SPI从机模式下连续读取数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_SlaveContinueWriteReadStop(int DevHandle,int SPIIndex);/**  * @brief  SPI从机模式下连续发送数据，也就是将数据放到数据缓冲区中，主机来读取的时候会自动循环发送  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 需要循环发送的数据缓冲区指针  * @param  WriteDataNum 待发送的数据字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_SlaveContinueWrite(int DevHandle,int SPIIndex,unsigned char *pWriteData,int WriteLen);/**  * @brief  读写SPI-Flash初始化配置  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  ClockSpeed SPI时钟信号频率，单位为Hz,最大为50MHz，依次成倍递减  * @param  pConfig SPI-Flash相关参数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_FlashInit(int DevHandle,int SPIIndex,int ClockSpeed, PSPI_FLASH_CONFIG pConfig);/**  * @brief  读取SPI-Flash芯片的ID号  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pID 芯片ID号存储首地址，其长度由SPI_FLASH_CONFIG中的ID_Length决定  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_FlashReadID(int DevHandle,int SPIIndex,unsigned char *pID);/**  * @brief  擦除SPI-Flash的扇区数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  StartSector 起始扇区号，注意是扇区号，不是具体的扇区地址  * @param  NumSector 需要擦除的扇区数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_FlashEraseSector(int DevHandle,int SPIIndex,int StartSector,int NumSector,int TimeOutMs);/**  * @brief  擦除SPI-Flash整个芯片的数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_FlashEraseChip(int DevHandle,int SPIIndex,int TimeOutMs);/**  * @brief  擦除SPI-Flash的数据，根据传入的指令不一样，可以是扇区擦除，块擦除，整片擦除  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  StartAddr 擦除数据的起始地址  * @param  AddrBytes 地址字节数，一般是3字节  * @param  EraseCmd 擦除数据命令，不同的擦除方式，命令值不一样  * @param  TimeOutMs 等待擦除完毕超时时间，若超时时间到之后还没擦除完毕，则返回超时错误  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_FlashErase(int DevHandle,int SPIIndex,int StartAddr,unsigned char AddrBytes,unsigned char EraseCmd,int TimeOutMs);/**  * @brief  向SPI-Flash写数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  StartAddr 写数据起始地址  * @param  pWriteData 写数据缓冲区首地址  * @param  WriteLen 写数据字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_FlashWrite(int DevHandle,int SPIIndex,int StartAddr,unsigned char *pWriteData,int WriteLen);/**  * @brief  从SPI-Flash读数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  StartAddr 写数据起始地址  * @param  pReadData 读数据缓冲区首地址  * @param  ReadLen 读数据字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_FlashRead(int DevHandle,int SPIIndex,int StartAddr,unsigned char *pReadData,int ReadLen);/**  * @brief  从SPI-Flash读数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  StartAddr 写数据起始地址  * @param  pReadData 读数据缓冲区首地址  * @param  ReadLen 读数据字节数  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_FlashReadFast(int DevHandle,int SPIIndex,int StartAddr,unsigned char *pReadData,int ReadLen);/**  * @brief  Block模式写数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 写数据起始地址  * @param  BlockSize 每次写数据字节数  * @param  BlockNum 写数据总次数  * @param  IntervalTime 每次写数据之间的时间间隔，单位为微妙  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_BlockWriteBytes(int DevHandle,int SPIIndex,unsigned char *pWriteData,int BlockSize,int BlockNum,int IntervalTimeUs);/**  * @brief  Block模式读数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pReadData 读数据缓冲区首地址  * @param  BlockSize 每次读数据字节数  * @param  BlockNum 读数据总次数  * @param  IntervalTime 每次写数据之间的时间间隔，单位为微妙  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_BlockReadBytes(int DevHandle,int SPIIndex,unsigned char *pReadData,int BlockSize,int BlockNum,int IntervalTimeUs);/**  * @brief  Block模式写读数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 写数据起始地址  * @param  WriteBlockSize 每次读数据字节数  * @param  pReadData 读数据缓冲区首地址  * @param  ReadBlockSize 每次读数据字节数  * @param  BlockNum 读数据总次数  * @param  IntervalTime 每次写数据之间的时间间隔，单位为微妙  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_BlockWriteReadBytes(int DevHandle,int SPIIndex,unsigned char *pWriteData,int WriteBlockSize,unsigned char *pReadData,int ReadBlockSize,int BlockNum,int IntervalTimeUs);/**  * @brief  Block模式写数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 写数据起始地址  * @param  BlockSize 每次写数据字节数  * @param  BlockNum 写数据总次数  * @param  EventPin 等待事件的GPIO引脚  * @param  EventType 事件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿  * @param  TimeOutOfMs 等待事件超时时间，单位为毫秒  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_BlockWriteBytesOfEvent(int DevHandle,int SPIIndex,unsigned char *pWriteData,int BlockSize,int BlockNum,int EventPin,unsigned char EventType,int TimeOutOfMs);/**  * @brief  Block模式读数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pReadData 读数据缓冲区首地址  * @param  BlockSize 每次读数据字节数  * @param  BlockNum 读数据总次数  * @param  EventPin 等待事件的GPIO引脚  * @param  EventType 事件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿  * @param  TimeOutOfMs 等待事件超时时间，单位为毫秒  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_BlockReadBytesOfEvent(int DevHandle,int SPIIndex,unsigned char *pReadData,int BlockSize,int BlockNum,int EventPin,unsigned char EventType,int TimeOutOfMs);/**  * @brief  Block模式写读数据  * @param  DevHandle 设备索引号  * @param  SPIIndex SPI通道号，取值0或者1  * @param  pWriteData 写数据起始地址  * @param  WriteBlockSize 每次读数据字节数  * @param  pReadData 读数据缓冲区首地址  * @param  ReadBlockSize 每次读数据字节数  * @param  BlockNum 读数据总次数  * @param  EventPin 等待事件的GPIO引脚  * @param  EventType 事件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿  * @param  TimeOutOfMs 等待事件超时时间，单位为毫秒  * @retval 函数执行状态，小于0函数执行出错  */int WINAPI SPI_BlockWriteReadBytesOfEvent(int DevHandle,int SPIIndex,unsigned char *pWriteData,int WriteBlockSize,unsigned char *pReadData,int ReadBlockSize,int BlockNum,int EventPin,unsigned char EventType,int TimeOutOfMs);#ifdef __cplusplus}#endif#endif","usb2spi.h","topics\\API函数接口定义原型/C/usb2spi.htm","/**  ******************************************************************************  * @file    usb2uart.h  * $Author: wdluo $  * $Revision: 447 $  * $Date:: 2013-06-29 18:24:57 +0800 #$  * @brief   usb2uart相关函数和数据类型定义.  ******************************************************************************  * @attention  *  *&lt;center&gt;&lt;a href=&quot;http:\\\\www.toomoss.com&quot;&gt;http://www.toomoss.com&lt;/a&gt;&lt;/center&gt;  *&lt;center&gt;All Rights Reserved&lt;/center&gt;&lt;/h3&gt;  *   ******************************************************************************  */#ifndef __USB2UART_H_#define __USB2UART_H_#include &lt;stdint.h&gt;#ifndef OS_UNIX#include &lt;Windows.h&gt;#else#include &lt;unistd.h&gt;#ifndef WINAPI#define WINAPI#endif#endif//定义初始化UART初始化数据类型typedef struct _UART_CONFIG{  unsigned int  BaudRate;     //波特率  unsigned char WordLength;   //数据位宽，0-8bit,1-9bit  unsigned char StopBits;     //停止位宽，0-1bit,1-0.5bit,2-2bit,3-1.5bit  unsigned char Parity;       //奇偶校验，0-No,4-Even,6-Odd  unsigned char TEPolarity;   //TE输出控制，0x80-输出TE信号，且低电平有效，0x81-输出TE信号，且高电平有效，0x00不输出TE信号}UART_CONFIG,*PUART_CONFIG;//定义函数返回错误代码#define UART_SUCCESS             (0)   //函数执行成功#define UART_ERR_NOT_SUPPORT     (-1)  //适配器不支持该函数#define UART_ERR_USB_WRITE_FAIL  (-2)  //USB写数据失败#define UART_ERR_USB_READ_FAIL   (-3)  //USB读数据失败#define UART_ERR_CMD_FAIL        (-4)  //命令执行失败//数据位宽#define UART_WORD_LENGTH_8BIT     0#define UART_WORD_LENGTH_9BIT     1//停止位#define UART_STOP_BITS_1          0//1bit#define UART_STOP_BITS_05         1//0.5bit#define UART_STOP_BITS_2          2//2bit#define UART_STOP_BITS_15         3//1.5bit//奇偶校验位#define UART_PARITY_NO            0#define UART_PARITY_EVEN          4#define UART_PARITY_ODD           6//TE控制信号输出#define UART_TE_DISEN             0x00#define UART_TE_EN_LOW            0x80#define UART_TE_EN_HIGH           0x81//使能内部上拉电阻，CAN&amp;LIN适配器支持#define UART_PPR_DISABLE          0x40#define UART_PPR_ENABLE           0x41#ifdef __cplusplusextern &quot;C&quot;{#endifint WINAPI UART_Init(int DevHandle, unsigned char Channel, PUART_CONFIG pConfig);int WINAPI UART_WriteBytes(int DevHandle,unsigned char Channel,unsigned char *pWriteData,int DataSize);int WINAPI UART_WriteBytesAsync(int DevHandle,unsigned char Channel,unsigned char *pWriteData,int DataSize);int WINAPI UART_WriteBytesInterval(int DevHandle,unsigned char Channel,unsigned char *pWriteData,int DataSize,unsigned char IntervalTimeMs);int WINAPI UART_ReadBytes(int DevHandle,unsigned char Channel,unsigned char *pReadData,int TimeOutMs);int WINAPI UART_ClearData(int DevHandle,unsigned char Channel);#ifdef __cplusplus}#endif#endif","usb2uart.h","topics\\API函数接口定义原型/C/usb2uart.htm","概述\n\r\n\rAPI函数定义原型\n\r\n\r               &nbsp;","函数原型","topics\\API函数接口定义原型/函数原型.htm","目录\n\r  前言  软件安装，驱动安装  硬件连接  软件使用  二次开发\n\r前言\n\r\n\r本文档为USB2XXX使用说明文档，主要介绍软件和驱动的安装，硬件连接，软件使用，二次开发等内容，阅读次文章可以快速的使用USB2XXX产品，若在使用该产品时还有其他问题或者有不明白的地方，可以联系技术支持QQ：188298598。\n\r\n\r软件安装，驱动安装软件下载\n\r\n\rUSB2XXX所有相关软件（I2C,SPI,UART等）和驱动都是做在一个安装包里面的，所以只需要安装一个软件即可。若要使用CAN LIN总线功能，下载安装TCANLINPro软件即可。\n\r\n\rUSB2XXX软件下载地址：http://www.toomoss.com/download/3-cn.html\n\r\n\rTCANLINPro软件下载地址：http://www.toomoss.com/download/7-cn.html\n\r\n\r功耗分析仪软件下载：http://www.toomoss.com/download/8-cn.html软件启动\n\r\n\rWindows系统：双击下载下来的.exe文件，开始安装程序，一路下一步即可，最后会提示安装驱动程序，也是一路下一步，安装过程中有个创建桌面快捷方式的勾选框，勾选上即可创建桌面快捷方式，然后双击桌面快捷方式即可启动程序。\n\r\n\rLinux系统：将.tar.xz文件解压到本地目录(使用“tar xvf TCANLINPro_v1.5.tar.xz“命令 )，然后用控制台进入该目录，若是第一次运行程序，需要用管理员权限运行\"./install.sh\"命令，之后就可以通过”./TCANLINPro.sh“命令启动程序或者在电脑的软件界面双击TCANLINPro软件图标打开软件。\n\r\n\rMac OS系统：直接双击.dmg文件，然后再双击弹出的对话框中的文件即可启动程序。驱动安装\n\r\n\rWindows系统使用我们设备需要安装驱动程序，在软件安装的时候就提前预装了驱动程序，所以只需要通过USB线将USB2XXX接入电脑USB口，系统就会自动安装驱动，驱动安装完成后会在设备管理器里面出现如下图所示图标：\n\r\n\r\n\r\n\r若没有出现这个图标，说明USB2XXX跟电脑连接有问题，请检查USB接线是否牢靠，可以换个USB口，换条USB线试试，若有用USB HUB，可以先不接USB HUB，而是直接连接到电脑的USB口试试，有的台式机前面的USB口供电能力比较若，所以也可以试试接到台式机后面的USB口。\n\r\n\r若在这个图片上有类似于黄色叹号，可能是因为安装了老的驱动程序导致，可以试试将当前的驱动卸载删除，重新安装最新版本的软件，若还不能解决，可以联系技术支持QQ（188298598）。\n\r\n\r除了Windows系统之外，其他系统都不需要安装驱动程序，只需要将USB2XXX接入电脑，然后运行软件即可，对于安卓系统，比如安卓手机，一般都是Micro USB的接口，若要将USB2XXX接入，则需要一个OTG转接头或者OTG转接线才能将我们设备接入安卓系统。硬件连接\n\r\n\rUSB2XXX目前有3个分支产品，主要为不带外壳的，带外壳20 Pin接口的，带外壳8 Pin接口的，其详细引脚功能定义可以参考《引脚定义说明文档  》软件使用 \n\r\n\r 安装好软件后，启动软件，主软件如下图所示：\n\r\n\r \n\r\n\r 然后需要使用什么功能，就点击对应的图标即可。\n\r\n\r 若是使用CAN/LIN功能，软件运行后如下图所示：\n\r\n\r \n\r\n\r 软件具体使用可参考《TCANLINPro软件使用教程 》\n\r\n\r二次开发\n\r\n\r我们适配器开放了二次开发接口，所以客户可以根据自己的实际需求进行二次开发，我们也提供了不同语言，不同平台下的二次开发范例工程和代码。参考《如何快速获取二次开发范例程序源码》文档可以知道如何快速获取二次开发范例程序源码。\n\r\n\r二次开发的时候需要使用到的函数说明可以参考《函数说明》文档。","USB2XXX快速入门","topics\\USB2XXX快速入门.htm","概述\n\r\n\r二次开发相关文档","二次开发","topics\\二次开发/二次开发.htm","\n\r\n\r 本帮助文档包含USB2XXX，USB2CAN&amp;LIN二次开发API函数说明，各个语言平台调用库的方法说明，USB2XXX各个软件使用说明以及其他相关的帮助说明。\n\r\n\r 在阅读此文档有不清楚的地方可以联系作者QQ（188298598）。\n\r\n\r 若文档中有错误或者不明确的地方，也非常欢迎向作者指正。\n\r\n\r &nbsp;\n\r\n\r&nbsp;","概述","topics\\概述.htm","目录\n\r  前言  准备  操作步骤\n\r前言\n\r\n\rUSB2XXX所有产品都带Bootloader功能，也就是说用户可以利用我们提供的固件升级上位机软件实现对USB2XXX设备进行固件升级，如此客户可以很方便的用到我们适配器新增加的功能，或者解决之前固件有问题的地方。\n\r\n\r固件升级操作步骤是非常简单的，基本上就是选择打开固件，然后点击下固件升级按钮就能升级适配器固件了，不过我们还是将详细步骤写出来，方便每个客户能准确无误的实现固件升级。准备\n\r\n\r首先安装我们的软件集合，软件的获取和安装请参考《USB2XXX快速入门》。\n\r\n\r固件下载链接：http://pan.baidu.com/s/1sj9qOnr\n\r\n\r若下载链接失效，可以到我们官网寻找最新下载链接，或者直接联系我们技术支持QQ（188298598）。\n\r\n\r固件文件说明：\n\r\n\r1，若是使用的不带外壳版本的适配器，请选择文件名为“usb2xxx”开头的固件，比如：usb2xxx_firmware_v1.5.30.bin\n\r\n\r2，若是使用带外壳版本的适配器（20 PIN接口的），请选择文件名为“usb2xxxshell”开头的固件，比如：usb2xxxshell_firmware_v1.5.30.bin \n\r\n\r3，若是使用的带外壳版本的CAN/LIN总线适配器（8 PIN接线端子的），请选择文件名为“usb2can”开头的固件，比如：usb2can_firmware_v1.5.30.bin 操作步骤\n\r\n\r1，打开软件集合，点击“固件升级”图标\n\r\n\r\n\r\n\r打开固件升级软件后界面如下图所示：\n\r\n\r\n\r\n\r请确认设备列表中有被识别到的设备，可以点击“信息查询”查询当前设备固件信息，如下图所示：\n\r\n\r\n\r\n\r2，点击“打开固件”按钮，选择保存到本地目录下的固件文件（注意不要把文件选择错了！）\n\r\n\r\n\r\n\r3，点击“升级固件”按钮即可升级适配器固件\n\r\n\r\n\r\n\r固件升级完毕之后会自动查询显示最新的固件信息，通过固件信息可以确认固件是否升级成功。","固件升级教程","topics\\固件升级教程.htm","目录\n\r概述CAN_BOOT_InitCAN_BOOT_GetFWInfoCAN_BOOT_EnterBootModeCAN_BOOT_EraseAppCAN_BOOT_SetAddrOffsetCAN_BOOT_SendAppDataCAN_BOOT_WriteAppDataCAN_BOOT_ExecuteApp\n\r概述\n\r\n\r本文主要介绍关于新版本CAN Bootloader接口函数，推荐使用新版本的接口函数。在调用这些函数前需要调用设备操作相关函数，比如扫描设备，打开设备等，详情请查看《设备操作相关函数说明》。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //函数返回错误代码定义&nbsp;&nbsp;  #define&nbsp;CAN_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;  #define&nbsp;CAN_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;  #define&nbsp;CAN_ERR_USB_WRITE_FAIL&nbsp;&nbsp;(-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;  #define&nbsp;CAN_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;(-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;  #define&nbsp;CAN_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;  &nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_CONFIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-30)&nbsp;//配置设备错误&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_SEND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-31)&nbsp;//发送数据出错&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_TIME_OUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-32)&nbsp;//超时错误&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_CMD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-33)&nbsp;//执行命令失败&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_BAUD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-34)&nbsp;//波特率参数自动获取失败&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_BUFFER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-35)&nbsp;//从设备返回接收数据缓冲区大小为0&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_DSIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-36)&nbsp;//单次传输数据量大于了4093字节&nbsp;&nbsp;  &nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_ERASE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;//固件擦除出错&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_ERASE_IN_APP&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;//当前模式为APP，不能擦除固件&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_WRITE_OUTRANGE&nbsp;3&nbsp;&nbsp;&nbsp;//当前地址超出了正常的地址范围&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_WRITE_IN_APP&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;//当前模式不能写入固件数据&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_WRITE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;//数据写入程序存储器出错&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_WRITE_OUT_ADDR&nbsp;6&nbsp;&nbsp;&nbsp;//数据长度超出了程序存储器范围&nbsp;&nbsp;&nbsp;  #define&nbsp;CAN_BOOT_ERR_WRITE_CRC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;//数据CRC校验出错&nbsp;&nbsp;  &nbsp;&nbsp;  //CAN&nbsp;Bootloader固件类型&nbsp;&nbsp;  #define&nbsp;FW_TYPE_BOOT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x55&nbsp;&nbsp;  #define&nbsp;FW_TYPE_APP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xAA&nbsp;&nbsp;  &nbsp;&nbsp;  //CAN&nbsp;Bootloader数据收发ID类型&nbsp;&nbsp;  #define&nbsp;ID_TYPE_EXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01&nbsp;&nbsp;  #define&nbsp;ID_TYPE_STD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r\n\r\n\rCAN_BOOT_Init\n\r\n\r描述：\n\r\n\r初始化配置CAN Bootloader接口。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_BOOT_Init(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;int&nbsp;SendDataID,unsigned&nbsp;int&nbsp;ReceiveDataID,unsigned&nbsp;char&nbsp;IDType,int&nbsp;BaudRate);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rCANIndex&nbsp; CAN通道号，取值0或者1。 \n\r\n\rSendDataID&nbsp;&nbsp;&nbsp;CAN主节点（USB2CAN适配器）向从节点发送数据的帧ID，可以是标准ID或者扩展ID。 \n\r\n\rReceiveDataID&nbsp; CAN主节点（USB2CAN适配器）接收从节点返回数据的帧ID，可以是标准ID或者扩展ID。 \n\r\n\rIDType&nbsp; 帧ID类型，0-标准帧，1-扩展帧\n\r\n\rBaudRate CAN总线波特率值，单位为Hz，比如要配置为500K，则传入500000。\n\r\n\r返回值：\n\r\n\r函数执行状态，0-函数执行成功，若小于0则该函数调用失败。\n\r\n\r示例：&nbsp;CAN_BOOT_GetFWInfo\n\r\n\r描述：\n\r\n\r获取节点固件信息，\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_BOOT_GetFWInfo(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;char&nbsp;NAD,unsigned&nbsp;char&nbsp;*pFWType,unsigned&nbsp;int&nbsp;*pFWVersion,unsigned&nbsp;int&nbsp;TimeOutOfMs);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rCANIndex&nbsp; CAN通道号，取值0或者1。 \n\r\n\rNAD 节点地址，取值范围0x01~0x7E。\n\r\n\rpFWType&nbsp; 获取到的节点固件类型，0x55-当前节点固件为Bootloader固件，0xAA-当前固件为App固件。\n\r\n\rpFWVersion&nbsp; 固件版本号，比如值为0x0102030A，那么固件的版本为V1.2.3.10。\n\r\n\rTimeOutOfMs&nbsp; 适配器发送获取节点固件信息后，等待从节点返回信息的时间，超过这个时间后函数返回超时错误。\n\r\n\r返回值：\n\r\n\r函数执行状态，0-函数执行成功，若小于0则该函数调用失败。\n\r\n\r示例：&nbsp;CAN_BOOT_EnterBootMode\n\r\n\r描述：\n\r\n\r若当前固件为App固件，从节点收到该指令后开始运行Bootloader固件，准备固件升级。\n\r\n\r原型：\n\r\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_BOOT_EnterBootMode(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;char&nbsp;NAD);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rCANIndex&nbsp; CAN通道号，取值0或者1。 \n\r\n\rNAD 节点地址，取值范围0x01~0x7E。\n\r\n\r返回值：\n\r\n\r函数执行状态，0-函数执行成功，若小于0则该函数调用失败。\n\r\n\r示例：&nbsp;CAN_BOOT_EraseApp\n\r\n\r描述：\n\r\n\r擦除App区域的固件数据，为后面App数据的烧入做准备。\n\r\n\r原型：\n\r\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_BOOT_EraseApp(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;char&nbsp;NAD,unsigned&nbsp;int&nbsp;AppSizeOfByte,unsigned&nbsp;int&nbsp;TimeOutOfMs);&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice 函数获得。 \n\r\n\rCANIndex&nbsp; CAN通道号，取值0或者1。 \n\r\n\rNAD 节点地址，取值范围0x01~0x7E。 \n\r\n\rAppSizeOfByte&nbsp; 需要擦除的App区域大小，单位为字节。 \n\r\n\rTimeOutOfMs&nbsp; 发送固件擦除指令后，等待从节点返回状态信息的超时时间，一般内部存储区域擦除都比较耗时，所以这个超时时间可能得根据实际的情况设置大一点。 \n\r\n\r返回值：\n\r\n\r函数执行状态，0-函数执行成功，若小于0则该函数调用失败。\n\r\n\r示例：&nbsp;CAN_BOOT_SetAddrOffset\n\r\n\r描述：\n\r\n\r设置后续写入App数据的起始偏移地址。并获取从节点每次能接收App数据字节数大小。\n\r\n\r原型：\n\r\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_BOOT_SetAddrOffset(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;char&nbsp;NAD,unsigned&nbsp;int&nbsp;AddrOffset,unsigned&nbsp;short&nbsp;*pBufferSize,unsigned&nbsp;int&nbsp;TimeOutOfMs);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice 函数获得。 \n\r\n\rCANIndex&nbsp; CAN通道号，取值0或者1。 \n\r\n\rNAD 节点地址，取值范围0x01~0x7E。 \n\r\n\rAddrOffset&nbsp; 准备写入App数据的偏移地址，注意这个不是芯片内部的实际数据存储地址，是App数据分包传输的偏移地址。 \n\r\n\rpBufferSize&nbsp; 从节点单次能接收的最大App数据字节数，比如为1024，那么每次传输的数据就不能大于1024。 \n\r\n\rTimeOutOfMs&nbsp; 发送固件擦除指令后，等待从节点返回状态信息的超时时间，一般内部存储区域擦除都比较耗时，所以这个超时时间可能得根据实际的情况设置大一点。 \n\r\n\r返回值：\n\r\n\r函数执行状态，0-函数执行成功，若小于0则该函数调用失败。\n\r\n\r示例：&nbsp;CAN_BOOT_SendAppData\n\r\n\r描述：\n\r\n\r将App数据发送到从节点内部数据缓冲区中。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_BOOT_SendAppData(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;char&nbsp;NAD,unsigned&nbsp;char&nbsp;*pData,unsigned&nbsp;short&nbsp;DataLen,unsigned&nbsp;short&nbsp;*pCRC16);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice 函数获得。 \n\r\n\rCANIndex&nbsp; CAN通道号，取值0或者1。 \n\r\n\rNAD 节点地址，取值范围0x01~0x7E。 \n\r\n\rpData&nbsp; 待发送的数据缓冲区指针。 \n\r\n\rDataLen&nbsp; 待发送的数据字节数，注意不能大于从节点能接收的最大字节数。 \n\r\n\rpCRC16&nbsp; 这些数据的CRC16值，用于后续数据写入时校验。 \n\r\n\r返回值：\n\r\n\r函数执行状态，0-函数执行成功，若小于0则该函数调用失败。\n\r\n\r示例：&nbsp;CAN_BOOT_WriteAppData\n\r\n\r描述：\n\r\n\r将从节点内部数据缓冲区中的数据写入芯片中的程序存储器中，并对数据进行校验。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_BOOT_WriteAppData(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;char&nbsp;NAD,unsigned&nbsp;short&nbsp;CRC16,unsigned&nbsp;int&nbsp;TimeOutOfMs);&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rCANIndex&nbsp; CAN通道号，取值0或者1。 \n\r\n\rNAD 节点地址，取值范围0x01~0x7E。 \n\r\n\rCRC16&nbsp; 从节点内部数据缓冲区中数据的CRC16值，可以通过CAN_BOOT_SendAppData函数获取到。 \n\r\n\rTimeOutOfMs&nbsp; 发送该指令后，等待从节点返回状态数据的超时时间，由于固件写入可能会比较耗时，所以这个超时时间可能得根据实际的情况设置大一点。 \n\r\n\r返回值：\n\r\n\r函数执行状态，0-函数执行成功，若小于0则该函数调用失败。\n\r\n\r示例：&nbsp;CAN_BOOT_ExecuteApp\n\r\n\r描述：\n\r\n\r固件烧写完毕之后，发送该指令让固件程序从Bootloader跳转到App运行，App是否正常运行，可以通过CAN_BOOT_GetFWInfo函数来查询。\n\r\n\r原型：\n\r\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_BOOT_ExecuteApp(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;char&nbsp;NAD);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rCANIndex&nbsp; CAN通道号，取值0或者1。 \n\r\n\rNAD 节点地址，取值范围0x01~0x7E。 \n\r\n\r返回值：\n\r\n\r函数执行状态，0-函数执行成功，若小于0则该函数调用失败。\n\r\n\r示例：&nbsp;","can_bootloader","topics\\函数说明/can_bootloader.htm"," Help &gt; 函数说明 &gt; can_uds目录\n\r    概述    CAN_UDS_Request    CAN_UDS_Response\n\r概述 \n\r\n\r基于UDS协议实现的CAN UDS操作函数，使用这些函数可以实现CAN UDS的所有功能。注意，在调用这些函数之前，需要先调用扫描设备，打开设备，CAN初始化的函数。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //函数返回值错误定义&nbsp;&nbsp;  #define&nbsp;CAN_UDS_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;  #define&nbsp;CAN_UDS_TRAN_USB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-98&nbsp;&nbsp;  #define&nbsp;CAN_UDS_TRAN_CAN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-99&nbsp;&nbsp;  #define&nbsp;CAN_UDS_TIMEOUT_A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-100&nbsp;&nbsp;  #define&nbsp;CAN_UDS_TIMEOUT_Bs&nbsp;&nbsp;&nbsp;&nbsp;-101&nbsp;&nbsp;  #define&nbsp;CAN_UDS_TIMEOUT_Cr&nbsp;&nbsp;&nbsp;&nbsp;-102&nbsp;&nbsp;  #define&nbsp;CAN_UDS_WRONG_SN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-103&nbsp;&nbsp;  #define&nbsp;CAN_UDS_INVALID_FS&nbsp;&nbsp;&nbsp;&nbsp;-104&nbsp;&nbsp;  #define&nbsp;CAN_UDS_UNEXP_PDU&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-105&nbsp;&nbsp;  #define&nbsp;CAN_UDS_WFT_OVRN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-106&nbsp;&nbsp;  #define&nbsp;CAN_UDS_BUFFER_OVFLW&nbsp;&nbsp;-107&nbsp;&nbsp;  #define&nbsp;CAN_UDS_ERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-108&nbsp;&nbsp;  &nbsp;&nbsp;  //CAN&nbsp;UDS地址定义&nbsp;&nbsp;  typedef&nbsp;&nbsp;struct&nbsp;&nbsp;_CAN_UDS_ADDR&nbsp;&nbsp;  {&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ReqID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//请求报文ID。&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ResID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//应答报文ID。&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Flag;&nbsp;&nbsp;&nbsp;//bit[0]-帧类型(0-标准帧，1-扩展帧),bit[1]-FDF(0-普通CAN帧，1-CANFD帧),bit[2]-BRS(0-CANFD帧不加速，1-CANFD帧加速)  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;AddrFormats;&nbsp;&nbsp;//0-normal, 1-extended ,2-mixed  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;AddrExt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//当AddrFormats不为normal时，该数据放到CAN数据域第1字节&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;MaxDLC;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //每帧最大数据字节数，一般设置为8  }CAN_UDS_ADDR;&nbsp;&nbsp;\n\rCAN_UDS_Request\n\r\n\r描述：\n\r\n\r按照UDS协议发送数据，被测设备收到这些数据后，会发送响应数据。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_UDS_Request(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;CANIndex,CAN_UDS_ADDR&nbsp;*pUDSAddr,unsigned&nbsp;char&nbsp;*pReqData,int&nbsp;DataLen);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex 0-对应CAN1,1-对应CAN2。\n\r\n\rpUDSAddr UDS协议发送数据时需要用到的相关ID。\n\r\n\rpReqData  UDS协议里面的SID加上SID所携带的数据。\n\r\n\rDataLen pReqData里面的有效数据。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_UDS_OK表示成功，否则为失败。\n\r\n\r示例：\n\r  uint8_t&nbsp;req_data[]={0x01,0x0C};&nbsp;&nbsp;  uint8_t&nbsp;res_data[4096]={0};&nbsp;&nbsp;  CAN_UDS_ADDR&nbsp;UDSAddr;&nbsp;&nbsp;  UDSAddr.Flag&nbsp;=&nbsp;0;//使用标准帧&nbsp;&nbsp;  UDSAddr.AddrFormats&nbsp;=&nbsp;0;&nbsp;&nbsp;  UDSAddr.ReqID&nbsp;=&nbsp;0x7DF;&nbsp;&nbsp;  UDSAddr.ResID&nbsp;=&nbsp;0x7E8;&nbsp;&nbsp;  UDSAddr.MaxDLC&nbsp;=&nbsp;8;&nbsp;&nbsp;  ret&nbsp;=&nbsp;CAN_UDS_Request(DevHandle[DEVIndex],CANIndex,UDSAddr,req_data,sizeof(req_data));&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;CAN_UDS_OK){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"CAN&nbsp;UDS&nbsp;request&nbsp;failed!&nbsp;%d\\r\\n\",ret);&nbsp;&nbsp;  }else{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Request:\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;sizeof(req_data);i++){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"&nbsp;%02X\",req_data[i]);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\r\\n\");&nbsp;&nbsp;  }&nbsp;&nbsp;\n\rCAN_UDS_Response\n\r\n\r描述：\n\r\n\r按照UDS协议发送数据后，获取设备响应的数据。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_UDS_Response(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;CANIndex,CAN_UDS_ADDR&nbsp;*pUDSAddr,unsigned&nbsp;char&nbsp;*pResData,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex 0-对应CAN1,1-对应CAN2。\n\r\n\rpUDSAddr UDS协议发送数据时需要用到的相关ID。\n\r\n\rpResData&nbsp; 存储设备返回的UDS数据，第一个字节为RSID，后面的为RSID所携带的参数。\n\r\n\rTimeOutMs 获取数据超时时间。\n\r\n\r返回值：\n\r\n\r函数执行状态，大于0，表示获取到的响应字节数，否则为失败。\n\r\n\r示例：\n\r  ret&nbsp;=&nbsp;CAN_UDS_Response(DevHandle[DEVIndex],CANIndex,UDSAddr,res_data,1000);&nbsp;&nbsp;  if(ret&nbsp;&lt;=&nbsp;CAN_UDS_OK){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"CAN&nbsp;UDS&nbsp;response&nbsp;failed!&nbsp;%d\\r\\n\",ret);&nbsp;&nbsp;  }else{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Response:\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;ret;i++){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"&nbsp;%02X\",res_data[i]);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\r\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;if((res_data[0]==(0x40+req_data[0]))&amp;&amp;(req_data[1]==res_data[1])){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"转速&nbsp;=&nbsp;%d&nbsp;Rpm\\r\\n\",((res_data[2]&lt;&lt;8)|res_data[3])/4);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  }&nbsp;&nbsp;\n\r Copyright ? 2018. All rights reserved.","can_uds","topics\\函数说明/can_uds.htm","目录\n\r  概述  VCI_ScanDevice  VCI_OpenDevice  VCI_CloseDevice  VCI_InitCAN  VCI_GetReceiveNum  VCI_ClearBuffer  VCI_StartCAN  VCI_ResetCAN  VCI_Transmit  VCI_Receive\n\r概述\n\r\n\r本文主要介绍兼容ZLG的CAN卡的接口函数。若之前有使用ZLG的接口函数开发应用软件，或者是想使用ZLG的CANTest和CANPro软件，那么只需要将我们的USB2XXX.dll和libusb-1.0.dll文件拷贝到ControlCAN.dll文件所在目录，然后将USB2XXX.dll文件重新命名为ControlCAN.dll，并覆盖原来的文件即可。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //适配器类型定义&nbsp;&nbsp;  #define&nbsp;VCI_USBCAN1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;  #define&nbsp;VCI_USBCAN2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;  &nbsp;&nbsp;  //CAN错误码&nbsp;&nbsp;  #define&nbsp;ERR_CAN_OVERFLOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0001&nbsp;&nbsp;//CAN&nbsp;控制器内部FIFO溢出&nbsp;&nbsp;  #define&nbsp;ERR_CAN_ERRALARM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0002&nbsp;&nbsp;//CAN&nbsp;控制器错误报警&nbsp;&nbsp;  #define&nbsp;ERR_CAN_PASSIVE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0004&nbsp;&nbsp;//CAN&nbsp;控制器消极错误&nbsp;&nbsp;  #define&nbsp;ERR_CAN_LOSE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0008&nbsp;&nbsp;//CAN&nbsp;控制器仲裁丢失&nbsp;&nbsp;  #define&nbsp;ERR_CAN_BUSERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0010&nbsp;&nbsp;//CAN&nbsp;控制器总线错误&nbsp;&nbsp;  #define&nbsp;ERR_CAN_BUSOFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0020&nbsp;&nbsp;//CAN&nbsp;控制器总线关闭&nbsp;&nbsp;  &nbsp;&nbsp;  //通用错误码&nbsp;&nbsp;  #define&nbsp;ERR_DEVICEOPENED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0100&nbsp;&nbsp;//设备已经打开&nbsp;&nbsp;  #define&nbsp;ERR_DEVICEOPEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0200&nbsp;&nbsp;//打开设备错误&nbsp;&nbsp;  #define&nbsp;ERR_DEVICENOTOPEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0400&nbsp;&nbsp;//设备没有打开&nbsp;&nbsp;  #define&nbsp;ERR_BUFFEROVERFLOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x0800&nbsp;&nbsp;//缓冲区溢出&nbsp;&nbsp;  #define&nbsp;ERR_DEVICENOTEXIST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x1000&nbsp;&nbsp;//此设备不存在&nbsp;&nbsp;  #define&nbsp;ERR_LOADKERNELDLL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x2000&nbsp;&nbsp;//装载动态库失败&nbsp;&nbsp;  #define&nbsp;ERR_CMDFAILED&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x4000&nbsp;&nbsp;//执行命令失败错误码&nbsp;&nbsp;  #define&nbsp;ERR_BUFFERCREATE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x8000&nbsp;&nbsp;//内存不足&nbsp;&nbsp;  &nbsp;&nbsp;  //函数调用返回状态值&nbsp;&nbsp;  #define&nbsp;STATUS_OK&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;  #define&nbsp;STATUS_ERR&nbsp;&nbsp;0&nbsp;&nbsp;  &nbsp;&nbsp;  //1.兼容ZLGCAN系列接口卡信息的数据类型。&nbsp;&nbsp;  typedef&nbsp;&nbsp;struct&nbsp;&nbsp;_VCI_BOARD_INFO{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;&nbsp;hw_Version;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//硬件版本号，用16&nbsp;进制表示。比如0x0100&nbsp;表示V1.00。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;&nbsp;fw_Version;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//固件版本号，用16&nbsp;进制表示。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;&nbsp;dr_Version;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//驱动程序版本号，用16&nbsp;进制表示。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;&nbsp;in_Version;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//接口库版本号，用16&nbsp;进制表示。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;&nbsp;irq_Num;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//板卡所使用的中断号。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;can_Num;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//表示有几路CAN&nbsp;通道。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;str_Serial_Num[20];&nbsp;//此板卡的序列号。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;str_hw_Type[40];&nbsp;&nbsp;&nbsp;&nbsp;//硬件类型，比如“USBCAN&nbsp;V1.00”（注意：包括字符串结束符‘\\0’）。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;&nbsp;Reserved[4];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//系统保留。&nbsp;&nbsp;   }&nbsp;VCI_BOARD_INFO,*PVCI_BOARD_INFO;&nbsp;&nbsp;   &nbsp;&nbsp;   //1.Ginkgo系列接口卡信息的数据类型。&nbsp;&nbsp;   typedef&nbsp;&nbsp;struct&nbsp;&nbsp;_VCI_BOARD_INFO_EX{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;ProductName[32];&nbsp;&nbsp;&nbsp;&nbsp;//硬件名称（注意：包括字符串结束符‘\\0’）&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;FirmwareVersion[4];&nbsp;//固件版本&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;HardwareVersion[4];&nbsp;//硬件版本&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;SerialNumber[12];&nbsp;&nbsp;&nbsp;//适配器序列号&nbsp;&nbsp;   }&nbsp;VCI_BOARD_INFO_EX,*PVCI_BOARD_INFO_EX;&nbsp;&nbsp;   &nbsp;&nbsp;   //2.定义CAN信息帧的数据类型。&nbsp;&nbsp;   typedef&nbsp;&nbsp;struct&nbsp;&nbsp;_VCI_CAN_OBJ{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//报文ID。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;TimeStamp;&nbsp;&nbsp;//接收到信息帧时的时间标识，从CAN&nbsp;控制器初始化开始计时。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;TimeFlag;&nbsp;&nbsp;&nbsp;//是否使用时间标识，为1&nbsp;时TimeStamp&nbsp;有效，TimeFlag&nbsp;和TimeStamp&nbsp;只在此帧为接收帧时有意义。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;SendType;&nbsp;&nbsp;&nbsp;//发送帧类型，=0&nbsp;时为正常发送，=1&nbsp;时为单次发送，=2&nbsp;时为自发自收，=3&nbsp;时为单次自发自收，只在此&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//帧为发送帧时有意义。（当设备类型为EG20T-CAN&nbsp;时，发送方式在VCI_InitCan&nbsp;中通过设置，此处的&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置无效，设置为自发自收模式后EG20T-CAN&nbsp;不能从总线上接收数据，只能收到自己发出的数据）&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;RemoteFlag;&nbsp;//是否是远程帧&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;ExternFlag;&nbsp;//是否是扩展帧&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;DataLen;&nbsp;&nbsp;&nbsp;&nbsp;//数据长度(&lt;=8)，即Data&nbsp;的长度。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Data[8];&nbsp;&nbsp;&nbsp;&nbsp;//报文的数据。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Reserved[3];//系统保留。&nbsp;&nbsp;   }VCI_CAN_OBJ,*PVCI_CAN_OBJ;&nbsp;&nbsp;   &nbsp;&nbsp;   //3.定义CAN控制器状态的数据类型。&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_VCI_CAN_STATUS{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;ErrInterrupt;&nbsp;&nbsp;&nbsp;//中断记录，读操作会清除。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;regMode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器模式寄存器。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;regStatus;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器状态寄存器。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;regALCapture;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器仲裁丢失寄存器。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;regECCapture;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器错误寄存器。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;regEWLimit;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器错误警告限制寄存器。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;regRECounter;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器接收错误寄存器。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;regTECounter;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器发送错误寄存器。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;regESR;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器错误状态寄存器。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;regTSR;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器发送状态寄存器&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;BufferSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器接收缓冲区大小&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;Reserved;&nbsp;&nbsp;   }VCI_CAN_STATUS,*PVCI_CAN_STATUS;&nbsp;&nbsp;   &nbsp;&nbsp;   //4.定义错误信息的数据类型。&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_ERR_INFO{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ErrCode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//错误码&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Passive_ErrData[3];&nbsp;//当产生的错误中有消极错误时表示为消极错误的错误标识数据。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;ArLost_ErrData;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//当产生的错误中有仲裁丢失错误时表示为仲裁丢失错误的错误标识数据。&nbsp;&nbsp;   }&nbsp;VCI_ERR_INFO,*PVCI_ERR_INFO;&nbsp;&nbsp;   &nbsp;&nbsp;   //5.定义初始化CAN的数据类型&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_INIT_CONFIG{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;AccCode;&nbsp;&nbsp;&nbsp;&nbsp;//验收码&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;AccMask;&nbsp;&nbsp;&nbsp;&nbsp;//屏蔽码&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;Reserved;&nbsp;&nbsp;&nbsp;//保留&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Filter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//滤波方式,0-双滤波，接收所有的帧，1-单滤波，根据AccCode和AccMask来设置过滤器   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Timing0;&nbsp;&nbsp;&nbsp;&nbsp;//定时器0（BTR0），波特率设置参数，请参考后面的波特率参数表   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Timing1;&nbsp;&nbsp;&nbsp;&nbsp;//定时器1（BTR1），波特率设置参数，请参考后面的波特率参数表&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Mode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//模式，0-正常模式，1-监听模式，2-自发自收默认，若最高位设置为1，比如按位或上0x80，则表示接入120欧的终端电阻到CAN总线，否则不接入。&nbsp;&nbsp;   }VCI_INIT_CONFIG,*PVCI_INIT_CONFIG;&nbsp;&nbsp;   &nbsp;&nbsp;   //6.定义了CAN&nbsp;滤波器的设置&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_VCI_FILTER_CONFIG{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Enable;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使能该过滤器，1-使能，0-禁止&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;FilterIndex;&nbsp;&nbsp;&nbsp;&nbsp;//过滤器索引号，取值范围为0到13&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;FilterMode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//过滤器模式，0-屏蔽位模式，1-标识符列表模式&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;ExtFrame;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//过滤的帧类型标志，为1&nbsp;代表要过滤的为扩展帧，为0&nbsp;代表要过滤的为标准帧。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ID_Std_Ext;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//验收码ID&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ID_IDE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//验收码IDE&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ID_RTR;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//验收码RTR&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;MASK_Std_Ext;&nbsp;&nbsp;&nbsp;//屏蔽码ID，该项只有在过滤器模式为屏蔽位模式时有用&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;MASK_IDE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//屏蔽码IDE，该项只有在过滤器模式为屏蔽位模式时有用&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;MASK_RTR;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//屏蔽码RTR，该项只有在过滤器模式为屏蔽位模式时有用&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;Reserved;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//系统保留&nbsp;&nbsp;   }&nbsp;VCI_FILTER_CONFIG,*PVCI_FILTER_CONFIG;&nbsp;&nbsp;\n\r\n\r\n\r波特率表（VCI_INIT_CONFIG结构体中的Timing0和Timing1参数）：\n\r\n\r              \n\r\n\r&nbsp;CAN波特率          \n\r\n\r&nbsp;Timing0          \n\r\n\r&nbsp;Timing1            \n\r\n\r5Kbps&nbsp;          \n\r\n\r0xBF&nbsp;          \n\r\n\r0xFF&nbsp;            \n\r\n\r&nbsp;10Kbps          \n\r\n\r&nbsp;0x31          \n\r\n\r&nbsp;0x1C            \n\r\n\r&nbsp;20Kbps          \n\r\n\r0x18&nbsp;          \n\r\n\r&nbsp;0x1C            \n\r\n\r40Kbps&nbsp;          \n\r\n\r&nbsp;0x87          \n\r\n\r0xFF&nbsp;            \n\r\n\r&nbsp;50Kbps          \n\r\n\r&nbsp;0x09          \n\r\n\r0x1C&nbsp;            \n\r\n\r&nbsp;80Kbps          \n\r\n\r0x83&nbsp;          \n\r\n\r0xFF&nbsp;            \n\r\n\r&nbsp;100Kbps          \n\r\n\r0x04&nbsp;          \n\r\n\r0x1C&nbsp;            \n\r\n\r&nbsp;125Kbps          \n\r\n\r0x03&nbsp;          \n\r\n\r0x1C&nbsp;            \n\r\n\r&nbsp;200Kbps          \n\r\n\r0x81&nbsp;          \n\r\n\r0xFA&nbsp;            \n\r\n\r&nbsp;250Kbps          \n\r\n\r0x01&nbsp;          \n\r\n\r0x1C&nbsp;            \n\r\n\r&nbsp;400Kbps          \n\r\n\r0x80&nbsp;          \n\r\n\r&nbsp;0xFA            \n\r\n\r&nbsp;500Kbps          \n\r\n\r0x00&nbsp;          \n\r\n\r0x1C&nbsp;            \n\r\n\r&nbsp;666Kbps          \n\r\n\r0x80&nbsp;          \n\r\n\r0xB6&nbsp;            \n\r\n\r&nbsp;800Kbps          \n\r\n\r0x00&nbsp;          \n\r\n\r0x16&nbsp;            \n\r\n\r1000Kbps          \n\r\n\r0x00          \n\r\n\r0x14            \n\r\n\r225Kbps          \n\r\n\r0x81          \n\r\n\r0xF0VCI_ScanDevice\n\r\n\r描述：\n\r\n\r扫描当前连接到电脑端的USB2XXX设备，改函数可以不用调用。\n\r\n\r原型：\n\r  unsigned&nbsp;int&nbsp;WINAPI&nbsp;VCI_ScanDevice(unsigned&nbsp;char&nbsp;NeedInit);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rNeedInit 保留参数，可以传入0.\n\r\n\r返回值：\n\r\n\r当前连接到电脑的设备数。VCI_OpenDevice\n\r\n\r描述：\n\r\n\r打开设备，该函数必须调用。\n\r\n\r原型：\n\r  unsigned&nbsp;int&nbsp;WINAPI&nbsp;VCI_OpenDevice(unsigned&nbsp;int&nbsp;DevType,unsigned&nbsp;int&nbsp;DevIndex,unsigned&nbsp;int&nbsp;Reserved);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevType 设备类型，若设备只有一个CAN通道，选择VCI_USBCAN1，若设备有2个CAN通道，则选择VCI_USBCAN2。\n\r\n\rDevIndex 设备索引号，若只连接了一个设备，则传入0即可。\n\r\n\rReserved 保留，若是安卓系统则传入设备句柄，具体请参考我们提供的范例程序源码。\n\r\n\r返回值：\n\r\n\r0-函数调用出错，1-函数调用成功。VCI_CloseDevice\n\r\n\r描述：\n\r\n\r关闭已经被打开的设备，若已经启动了CAN，则会自动停止CAN。\n\r\n\r原型：\n\r  unsigned&nbsp;int&nbsp;WINAPI&nbsp;VCI_CloseDevice(unsigned&nbsp;int&nbsp;DevType,unsigned&nbsp;int&nbsp;DevIndex);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevType 设备类型，若设备只有一个CAN通道，选择VCI_USBCAN1，若设备有2个CAN通道，则选择VCI_USBCAN2。\n\r\n\rDevIndex 设备索引号，若只连接了一个设备，则传入0即可。\n\r\n\r返回值：\n\r\n\r0-函数调用出错，1-函数调用成功。VCI_InitCAN\n\r\n\r描述：\n\r\n\r初始化CAN，必须调用。\n\r\n\r原型：\n\r  unsigned&nbsp;int&nbsp;WINAPI&nbsp;VCI_InitCAN(unsigned&nbsp;int&nbsp;DevType,&nbsp;unsigned&nbsp;int&nbsp;DevIndex,&nbsp;unsigned&nbsp;int&nbsp;CANIndex,&nbsp;PVCI_INIT_CONFIG&nbsp;pInitConfig);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevType 设备类型，若设备只有一个CAN通道，选择VCI_USBCAN1，若设备有2个CAN通道，则选择VCI_USBCAN2。\n\r\n\rDevIndex 设备索引号，若只连接了一个设备，则传入0即可。\n\r\n\rpInitConfig 初始化参数结构体指针。\n\r\n\r返回值：\n\r\n\r0-函数调用出错，1-函数调用成功。VCI_GetReceiveNum\n\r\n\r描述：\n\r\n\r获取当前CAN接收数据缓冲区中有效帧数。\n\r\n\r原型：\n\r  unsigned&nbsp;int&nbsp;WINAPI&nbsp;VCI_GetReceiveNum(unsigned&nbsp;int&nbsp;DevType,unsigned&nbsp;int&nbsp;DevIndex,unsigned&nbsp;int&nbsp;CANIndex);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevType 设备类型，若设备只有一个CAN通道，选择VCI_USBCAN1，若设备有2个CAN通道，则选择VCI_USBCAN2。\n\r\n\rDevIndex 设备索引号，若只连接了一个设备，则传入0即可。\n\r\n\rCANIndex CAN通道索引，0-对应CAN1通道，1-对应CAN2通道。\n\r\n\r返回值：\n\r\n\rCAN数据接收缓冲区中的CAN帧数。VCI_ClearBuffer\n\r\n\r描述：\n\r\n\r清除CAN接收数据缓冲区中的所有数据。\n\r\n\r原型：\n\r  unsigned&nbsp;int&nbsp;WINAPI&nbsp;VCI_ClearBuffer(unsigned&nbsp;int&nbsp;DevType,unsigned&nbsp;int&nbsp;DevIndex,unsigned&nbsp;int&nbsp;CANIndex);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevType 设备类型，若设备只有一个CAN通道，选择VCI_USBCAN1，若设备有2个CAN通道，则选择VCI_USBCAN2。\n\r\n\rDevIndex 设备索引号，若只连接了一个设备，则传入0即可。\n\r\n\rCANIndex CAN通道索引，0-对应CAN1通道，1-对应CAN2通道。\n\r\n\r返回值：\n\r\n\r0-函数调用出错，1-函数调用成功。VCI_StartCAN\n\r\n\r描述：\n\r\n\r启动CAN，调用该函数后，底层会自动开启一个接收CAN数据的线程，接收到CAN数据之后自动放入内部数据缓冲区中。\n\r\n\r原型：\n\r  unsigned&nbsp;int&nbsp;WINAPI&nbsp;VCI_StartCAN(unsigned&nbsp;int&nbsp;DevType,unsigned&nbsp;int&nbsp;DevIndex,unsigned&nbsp;int&nbsp;CANIndex);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevType 设备类型，若设备只有一个CAN通道，选择VCI_USBCAN1，若设备有2个CAN通道，则选择VCI_USBCAN2。\n\r\n\rDevIndex 设备索引号，若只连接了一个设备，则传入0即可。\n\r\n\rCANIndex CAN通道索引，0-对应CAN1通道，1-对应CAN2通道。\n\r\n\r返回值：\n\r\n\r0-函数调用出错，1-函数调用成功。VCI_ResetCAN\n\r\n\r描述：\n\r\n\r停止CAN，调用该函数后，会停止CAN接收数据线程。\n\r\n\r原型：\n\r  unsigned&nbsp;int&nbsp;WINAPI&nbsp;VCI_ResetCAN(unsigned&nbsp;int&nbsp;DevType,unsigned&nbsp;int&nbsp;DevIndex,unsigned&nbsp;int&nbsp;CANIndex);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevType 设备类型，若设备只有一个CAN通道，选择VCI_USBCAN1，若设备有2个CAN通道，则选择VCI_USBCAN2。\n\r\n\rDevIndex 设备索引号，若只连接了一个设备，则传入0即可。\n\r\n\rCANIndex CAN通道索引，0-对应CAN1通道，1-对应CAN2通道。\n\r\n\r返回值：\n\r\n\r0-函数调用出错，1-函数调用成功。VCI_Transmit\n\r\n\r描述：\n\r\n\r发送CAN数据。\n\r\n\r原型：\n\r  unsigned&nbsp;int&nbsp;WINAPI&nbsp;VCI_Transmit(unsigned&nbsp;int&nbsp;DevType,unsigned&nbsp;int&nbsp;DevIndex,unsigned&nbsp;int&nbsp;CANIndex,PVCI_CAN_OBJ&nbsp;pSend,unsigned&nbsp;int&nbsp;Len);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevType 设备类型，若设备只有一个CAN通道，选择VCI_USBCAN1，若设备有2个CAN通道，则选择VCI_USBCAN2。\n\r\n\rDevIndex 设备索引号，若只连接了一个设备，则传入0即可。\n\r\n\rCANIndex CAN通道索引，0-对应CAN1通道，1-对应CAN2通道。\n\r\n\rpSend 待发送的CAN数据缓冲区指针。\n\r\n\rLen 待发送的CAN数据长度。\n\r\n\r返回值：\n\r\n\r成功发送的CAN帧数。VCI_Receive\n\r\n\r描述：\n\r\n\r从CAN数据缓冲区中获取CAN数据。\n\r\n\r原型：\n\r  unsigned&nbsp;int&nbsp;WINAPI&nbsp;VCI_Receive(unsigned&nbsp;int&nbsp;DevType,unsigned&nbsp;int&nbsp;DevIndex,unsigned&nbsp;int&nbsp;CANIndex,PVCI_CAN_OBJ&nbsp;pReceive,unsigned&nbsp;int&nbsp;Len,int&nbsp;WaitTime=-1);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevType 设备类型，若设备只有一个CAN通道，选择VCI_USBCAN1，若设备有2个CAN通道，则选择VCI_USBCAN2。\n\r\n\rDevIndex 设备索引号，若只连接了一个设备，则传入0即可。\n\r\n\rCANIndex CAN通道索引，0-对应CAN1通道，1-对应CAN2通道。\n\r\n\rpReceive 存储CAN数据的缓冲区指针。\n\r\n\rLen 存储CAN数据的缓冲区大小。\n\r\n\rWaitTime 保留。\n\r\n\r返回值：\n\r\n\r实际获取到的CAN数据帧数。","ControlCAN","topics\\函数说明/ControlCAN.htm","目录\n\r  概述  I2C_SnifferStart  I2C_SnifferStop\n\r概述\n\r\n\r本文介绍了IIC/I2C总线监控接口函数，利用这些函数，可以自己写上位机软件实现对IIC/I2C总线的数据监控，存储，分析，处理。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //I2C数据类型定义&nbsp;&nbsp;  typedef&nbsp;enum&nbsp;&nbsp;  {&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;UNKNOWN&nbsp;=&nbsp;0x00,&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;START,&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;ADDR,&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;DATA,&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;STOP&nbsp;&nbsp;  }I2C_DATA_TYPE;&nbsp;&nbsp;  //I2C数据结构定义&nbsp;&nbsp;  typedef&nbsp;struct&nbsp;&nbsp;  {&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;DataType;&nbsp;//当前数据类型&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;ACK;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //0-当前ACK为低电平，1-当前ACK为高电平&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;WriteRead;//1-读操作，0-写操作&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;Data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //当DataType为DATA时对应的数据&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;Addr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //数据对应的从机地址&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;long&nbsp;Timestamp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //时间戳，单位为ns&nbsp;&nbsp;  }I2C_DATA;&nbsp;&nbsp;  &nbsp;&nbsp;  //解析到I2C数据后的回调函数&nbsp;&nbsp;  typedef&nbsp;&nbsp;int&nbsp;(WINAPI&nbsp;I2C_GET_DATA_HANDLE)(int&nbsp;DevHandle,int&nbsp;Channel,I2C_DATA&nbsp;*pI2CData,int&nbsp;I2CDataNum);&nbsp;&nbsp;  &nbsp;&nbsp;  //定义函数返回错误代码&nbsp;&nbsp;  #define&nbsp;SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;  #define&nbsp;ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;  #define&nbsp;ERR_USB_WRITE_FAIL&nbsp;&nbsp;   (-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;  #define&nbsp;ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;&nbsp;   (-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;  #define&nbsp;ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;\n\rI2C_SnifferStart\n\r\n\r  描述：\n\r\n\r启动I2C总线监控功能，启动的时候需要传入一个回调函数，抓取到数据后会自动调用回调函数实现数据输出。  \n\r\n\r原型：             \n\r  int&nbsp;WINAPI&nbsp;I2C_SnifferStart(int&nbsp;DevHandle,int&nbsp;Channel,unsigned&nbsp;int&nbsp;SampleRateHz,I2C_GET_DATA_HANDLE&nbsp;*pGetI2CDataHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rChannel&nbsp; 监控通道号，0-对应D0(SCL)和D1(SDA)，1-对应D2(SCL)和D3(SDA)，2-对应D4(SCL)和D5(SDA)，3-对应D6(SCL)和D7(SDA)。\n\r\n\rSampleRateHz 采样波特率，建议设置为5000000或者2500000。\n\r\n\rpGetI2CDataHandle 数据输出回调函数，函数原型见文章开头部分宏定义。\n\r\n\r返回值：\n\r\n\r0函数调用成功，启动I2C监控功能成功，其他值，函数执行失败，启动I2C监控失败。I2C_SnifferStop  \n\r\n\r  描述：\n\r\n\r停止I2C监控功能。  \n\r\n\r原型：             \n\r  int&nbsp;WINAPI&nbsp;I2C_SnifferStop(int&nbsp;DevHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\r返回值：\n\r\n\r0停止失败，其他值函数调用失败，停止I2C监控失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;  #include&nbsp;\"i2c_sniffer.h\"&nbsp;&nbsp;  &nbsp;&nbsp;  int&nbsp;WINAPI&nbsp;GetI2CData(int&nbsp;DeviceIndex,int&nbsp;Channel,I2C_DATA&nbsp;*pI2CData,int&nbsp;I2CDataNum)&nbsp;&nbsp;  {&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i=0;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;for(i=0;i&lt;I2CDataNum;i++){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(pI2CData[i].DataType&nbsp;==&nbsp;START){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"S\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(pI2CData[i].DataType&nbsp;==&nbsp;ADDR){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"&lt;%02X&gt;\",pI2CData[i].Addr);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(pI2CData[i].WriteRead&amp;0x01){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"&lt;R&gt;\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"&lt;W&gt;\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(pI2CData[i].DataType&nbsp;==&nbsp;DATA){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",pI2CData[i].Data);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(pI2CData[i].DataType&nbsp;==&nbsp;STOP){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"P\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;  }&nbsp;&nbsp;  &nbsp;&nbsp;  int&nbsp;main(int&nbsp;argc,&nbsp;const&nbsp;char*&nbsp;argv[])&nbsp;&nbsp;  {&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;DEVICE_INFO&nbsp;DevInfo;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;DevHandles[20];&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;state;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;//扫描查找设备&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;USB_ScanDevice(DevHandles);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;if(ret&nbsp;&lt;=&nbsp;0){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"No&nbsp;device&nbsp;connected!\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;//打开设备&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;=&nbsp;USB_OpenDevice(DevHandles[0]);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;if(!state){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Open&nbsp;device&nbsp;error!\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;//获取固件信息&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;FunctionStr[256]={0};&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;//获取固件信息&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;=&nbsp;DEV_GetDeviceInfo(DevHandles[0],&amp;DevInfo,FunctionStr);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;if(!state){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Get&nbsp;device&nbsp;infomation&nbsp;error!\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Firmware&nbsp;Info:\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Firmware&nbsp;Name:%s\\n\",DevInfo.FirmwareName);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Firmware&nbsp;Build&nbsp;Date:%s\\n\",DevInfo.BuildDate);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Firmware&nbsp;Version:v%d.%d.%d\\n\",(DevInfo.FirmwareVersion&gt;&gt;24)&amp;0xFF,(DevInfo.FirmwareVersion&gt;&gt;16)&amp;0xFF,DevInfo.FirmwareVersion&amp;0xFFFF);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Hardware&nbsp;Version:v%d.%d.%d\\n\",(DevInfo.HardwareVersion&gt;&gt;24)&amp;0xFF,(DevInfo.HardwareVersion&gt;&gt;16)&amp;0xFF,DevInfo.HardwareVersion&amp;0xFFFF);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Firmware&nbsp;Functions:%s\\n\",FunctionStr);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;//启动I2C&nbsp;Sniffer&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;I2C_SnifferStart(DevHandles[0],0,5000000,GetI2CData);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;if(ret&nbsp;!=&nbsp;SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;i2c&nbsp;sniffer&nbsp;faild!\\r\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;getchar();&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;getchar();&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;I2C_SnifferStop(DevHandles[0]);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;USB_CloseDevice(DevHandles[0]);&nbsp;&nbsp;  }&nbsp;&nbsp;\n\r","i2c_sniffer","topics\\函数说明/i2c_sniffer.htm","目录\n\r    概述\n\r概述\n\r\n\r本文主要介绍LIN总线的LDF文件解析相关函数，这些函数是基于LDFDecoder库函数进行再次封装实现，使用更简单，接口函数也更容易被其他语言调用，此外还增加了直接发送帧数据到LIN总线，或者直接执行调度表的功能，更易于实现LIN总线数据收发。\n\r\n\r注意，使用这些函数需要连接我们的适配器才能正常使用，否则无法正常解析数据。\n\r\n\r函数的使用范例可以参考我们提供的二次开发范例程序源码。\n\r\n\r下面是本文相关函数可能会用到的宏定义：\n\r  #define&nbsp;LDF_PARSER_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0//没有错误&nbsp;&nbsp;  #define&nbsp;LDF_PARSER_FILE_OPEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-1)//打开文件出错&nbsp;&nbsp;   #define&nbsp;LDF_PARSER_FILE_FORMAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-2)//文件格式错误&nbsp;&nbsp;   #define&nbsp;LDF_PARSER_DEV_DISCONNECT&nbsp;&nbsp;&nbsp;&nbsp;(-3)//设备未连接&nbsp;&nbsp;   #define&nbsp;LDF_PARSER_HANDLE_ERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-4)//LDF&nbsp;Handle错误&nbsp;&nbsp;   #define&nbsp;LDF_PARSER_GET_INFO_ERROR&nbsp;&nbsp;&nbsp;&nbsp;(-5)//获取解析后的数据出错&nbsp;&nbsp;   #define&nbsp;LDF_PARSER_DATA_ERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-6)//数据处理错误&nbsp;&nbsp;   #define&nbsp;LDF_PARSER_SLAVE_NACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-7)//从机未响应数据&nbsp;&nbsp;\n\rLDF_ParserFile\n\r\n\r\n\r\n\r描述：\n\r\n\r输入LDF文件，解析后输出ldf文件解析句柄，后续函数操作需要该句柄，解析ldf文件后，内部调用LIN初始化函数初始化对应的LIN通道。\n\r\n\r原型：\n\r  long&nbsp;long&nbsp;WINAPI&nbsp;LDF_ParserFile(int&nbsp;DevHandle,&nbsp;int&nbsp;LINIndex,&nbsp;unsigned&nbsp;char&nbsp;isMaster,&nbsp;char*&nbsp;pLDFFileName);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice 函数获得。 \n\r\n\rLINIndex 需要进行数据收发的LIN通道号，0-LIN1,1-LIN2,2-LIN3,3-LIN4。 \n\r\n\risMaster 将我们设备节点配置为主机还是从机模式，0-从机，1-主机。 \n\r\n\rpLDFFileName ldf格式的文件名，建议传入完整的文件路径。\n\r\n\r返回值：\n\r\n\r文件解析成功则返回ldf解析句柄，后续函数需要使用该句柄，若解析文件失败，则返回0。\n\r\n\r示例：\n\r  int&nbsp;DevHandle[20];&nbsp;&nbsp;   int&nbsp;ret&nbsp;=&nbsp;USB_ScanDevice(DevHandle);&nbsp;&nbsp;   if&nbsp;(!USB_OpenDevice(DevHandle[0]))&nbsp;{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"打开设备失败！\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;   printf(\"DevHandle&nbsp;=&nbsp;%08X\\n\",&nbsp;DevHandle[0]);&nbsp;&nbsp;   long&nbsp;long&nbsp;LDFHandle&nbsp;=&nbsp;LDF_ParserFile(DevHandle[0],0,1,&nbsp;\"example.ldf\");&nbsp;&nbsp;   if(LDFHandle&nbsp;==&nbsp;NULL)&nbsp;&nbsp;   {&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"解析LDF文件失败\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\r\n\r\n\rLDF_GetLINSpeed\n\r\n\r\n\r\n\r描述：\n\r\n\r获取ldf文件里面的波特率值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetLINSpeed(long&nbsp;long&nbsp;LDFHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\r返回值：\n\r\n\r若成功获取波特率值，则返回对应的波特率值，若返回值为负数或者0，说明获取波特率值失败。\n\r\n\r示例：\n\r\n\r\n\r\n\rLDF_GetFrameQuantity\n\r\n\r\n\r\n\r描述：\n\r\n\r获取ldf文件中包含的所有帧总数。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetFrameQuantity(long&nbsp;long&nbsp;LDFHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\r返回值：\n\r\n\r大于0，表示成功获取到的帧总数值，小于等于0表示获取帧总数失败。\n\r\n\r示例：LDF_GetFrameName\n\r\n\r\n\r\n\r描述：\n\r\n\r通过索引号获取帧名称。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetFrameName(long&nbsp;long&nbsp;LDFHandle,&nbsp;int&nbsp;index,&nbsp;char*&nbsp;pFrameName);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rindex 帧索引号。 \n\r\n\rpFrameName 帧名称输出。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：\n\r  int&nbsp;FrameLen&nbsp;=&nbsp;LDF_GetFrameQuantity(LDFHandle);&nbsp;&nbsp;   for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;i&nbsp;&lt;&nbsp;FrameLen;i++)&nbsp;{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;FrameName[64];&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(LDF_PARSER_OK&nbsp;==&nbsp;LDF_GetFrameName(LDFHandle,&nbsp;i,&nbsp;FrameName))&nbsp;{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Frame[%d].Name=%s\\n\",&nbsp;i,&nbsp;FrameName);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rLDF_GetFrameSignalQuantity\n\r\n\r\n\r\n\r描述：\n\r\n\r获取帧里面包含的信号数量。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetFrameSignalQuantity(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pFrameName);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpFrameName 帧名称。 \n\r\n\r返回值：\n\r\n\r返回成功获取到的帧信号数量，若获取失败则返回0或者负数。\n\r\n\r示例：LDF_GetFrameSignalName\n\r\n\r\n\r\n\r描述：\n\r\n\r通过信号索引获取帧里面的信号名称。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetFrameSignalName(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pFrameName,&nbsp;int&nbsp;index,&nbsp;char*&nbsp;pSignalName);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpFrameName 帧名称。 \n\r\n\rindex 信号索引，不能大于总的信号数量。 \n\r\n\rpSignalName 信号名称输出。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：\n\r  int&nbsp;FrameLen&nbsp;=&nbsp;LDF_GetFrameQuantity(LDFHandle);&nbsp;&nbsp;   for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;i&nbsp;&lt;&nbsp;FrameLen;i++)&nbsp;{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;FrameName[64];&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(LDF_PARSER_OK&nbsp;==&nbsp;LDF_GetFrameName(LDFHandle,&nbsp;i,&nbsp;FrameName))&nbsp;{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Frame[%d].Name=%s\\n\",&nbsp;i,&nbsp;FrameName);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;SignalNum&nbsp;=&nbsp;LDF_GetFrameSignalQuantity(LDFHandle,&nbsp;FrameName);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;j&nbsp;&lt;&nbsp;SignalNum;j++)&nbsp;{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;SignalName[64];&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(LDF_PARSER_OK&nbsp;==&nbsp;LDF_GetFrameSignalName(LDFHandle,&nbsp;FrameName,&nbsp;j,&nbsp;SignalName))&nbsp;{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\tSignal[%d].Name=%s\\n\",&nbsp;j,&nbsp;SignalName);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rLDF_SetSignalValue\n\r\n\r\n\r\n\r描述：\n\r\n\r设置信号值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_SetSignalValue(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pFrameName,&nbsp;char*&nbsp;pSignalName,&nbsp;double&nbsp;Value);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpFrameName 帧名称。 \n\r\n\rpSignalName 信号名称。 \n\r\n\rValue 信号值。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：LDF_GetSignalValue\n\r\n\r\n\r\n\r描述：\n\r\n\r获取信号值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetSignalValue(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pFrameName,&nbsp;char*&nbsp;pSignalName,&nbsp;double&nbsp;*pValue);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpFrameName 帧名称。 \n\r\n\rpSignalName 信号名称。 \n\r\n\rpValue 信号值输出。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：LDF_GetSignalValueStr\n\r\n\r\n\r\n\r描述：\n\r\n\r获取信号值，该值通过字符串形式输出，若该信号包含单位，也同时会输出对应的单位。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetSignalValueStr(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pFrameName,&nbsp;char*&nbsp;pSignalName,&nbsp;char*&nbsp;pValueStr);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpFrameName 帧名称。 \n\r\n\rpSignalName 信号名称。 \n\r\n\rpValueStr 信号值字符串输出。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：LDF_SetFrameRawValue\n\r\n\r\n\r\n\r描述：\n\r\n\r设置帧原始数据值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_SetFrameRawValue(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pFrameName,&nbsp;unsigned&nbsp;char*&nbsp;pRawData);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpFrameName 帧名称。 \n\r\n\rpRawData 需要写入帧的原始数据指针。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：LDF_GetFrameRawValue\n\r\n\r\n\r\n\r描述：\n\r\n\r获取帧原始数据。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetFrameRawValue(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pFrameName,&nbsp;unsigned&nbsp;char*&nbsp;pRawData);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpFrameName 帧名称。 \n\r\n\rpRawData 需要存储帧原始数据指针。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：LDF_GetFramePublisher\n\r\n\r\n\r\n\r描述：\n\r\n\r获取当前帧对应的数据发布者，若发布者为主机，那么该帧数据就是发送给从机的，若发布者不是主机，那么该帧数据就是通过从机返回的，通过LDF_GetMasterName函数可以获取主机节点名称。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetFramePublisher(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pFrameName,&nbsp;char*&nbsp;pPublisher);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpFrameName 帧名称。 \n\r\n\rpPublisher 当前帧数据发布名称。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：LDF_GetMasterName\n\r\n\r\n\r\n\r描述：\n\r\n\r获取ldf文件里面定义的主节点名称。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetMasterName(long&nbsp;long&nbsp;LDFHandle,&nbsp;&nbsp;char*&nbsp;pMasterName);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpMasterName 主节点名称输出。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：LDF_GetSchQuantity\n\r\n\r\n\r\n\r描述：\n\r\n\r获取调度表数量。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetSchQuantity(long&nbsp;long&nbsp;LDFHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回调度表数，失败返回负数。\n\r\n\r示例：LDF_GetSchName\n\r\n\r\n\r\n\r描述：\n\r\n\r获取调度表名称。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetSchName(long&nbsp;long&nbsp;LDFHandle,&nbsp;int&nbsp;index,&nbsp;char*&nbsp;pSchName);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rindex 调度表索引，不能大于总的调度表数量。 \n\r\n\rpSchName 调度表名称输出。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：LDF_GetSchFrameQuantity\n\r\n\r\n\r\n\r描述：\n\r\n\r获取调度表里面包含的帧数量。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetSchFrameQuantity(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pSchName);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpSchName 调度表名称。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：LDF_GetSchFrameName\n\r\n\r\n\r\n\r描述：\n\r\n\r获取调度表帧名称。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_GetSchFrameName(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pSchName,&nbsp;int&nbsp;index,&nbsp;char*&nbsp;pFrameName);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpSchName 调度表名称输出。 \n\r\n\rindex 帧索引，不能大于总的帧数量。 \n\r\n\rpFrameName 帧名称输出。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：LDF_ExeFrameToBus\n\r\n\r\n\r\n\r描述：\n\r\n\r将帧数据发送到LIN总线，或者向从机读取数据，内部会根据主机名称和帧发布者自动判断是发送数据还是读取数据，发送数据校验模式是通过协议版本号自动判断的。\n\r\n\r若是发送数据给从机，需要先调用LDF_SetSignalValue函数设置该帧里面每个信号的值。\n\r\n\r若是向从机读数据，调用该函数后，可以通过调用LDF_GetSignalValue函数获取读到的值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_ExeFrameToBus(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pFrameName);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpFrameName 帧名称。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：LDF_ExeSchToBus\n\r\n\r\n\r\n\r描述：\n\r\n\r执行调度表，调用该函数后会根据调度表里面的帧发送数据或者读取数据。帧间隔时间是通过调度表里面的延时函数控制。\n\r\n\r若调度表里面包含发送数据给从机的帧，需要先调用LDF_SetSignalValue函数设置该帧里面每个信号的值。\n\r\n\r若调度表包含向从机读数据的帧，调用该函数后，可以通过调用LDF_GetSignalValue函数获取读到的值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_ExeSchToBus(long&nbsp;long&nbsp;LDFHandle,&nbsp;char*&nbsp;pSchName);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rLDFHandle ldf文件解析句柄，通过LDF_ParserFile函数获取 。 \n\r\n\rpSchName 调度表名称。 \n\r\n\r返回值：\n\r\n\r函数执行成功返回0，失败返回负数。\n\r\n\r示例：\n\r  //主机写操作，发送数据给从机&nbsp;&nbsp;\n\r  LDF_SetSignalValue(LDFHandle,&nbsp;\"LIN_CONTROL\",&nbsp;\"Reg_Set_Voltage\",&nbsp;13.5);&nbsp;&nbsp;\n\r  LDF_SetSignalValue(LDFHandle,&nbsp;\"LIN_CONTROL\",&nbsp;\"Ramp_Time\",&nbsp;3);&nbsp;&nbsp;\n\r  LDF_SetSignalValue(LDFHandle,&nbsp;\"LIN_CONTROL\",&nbsp;\"Cut_Off_Speed\",&nbsp;4);&nbsp;&nbsp;\n\r  LDF_SetSignalValue(LDFHandle,&nbsp;\"LIN_CONTROL\",&nbsp;\"Exc_Limitation\",&nbsp;15.6);&nbsp;&nbsp;\n\r  LDF_SetSignalValue(LDFHandle,&nbsp;\"LIN_CONTROL\",&nbsp;\"Derat_Shift\",&nbsp;2);&nbsp;&nbsp;\n\r  LDF_SetSignalValue(LDFHandle,&nbsp;\"LIN_CONTROL\",&nbsp;\"MM_Request\",&nbsp;2);&nbsp;&nbsp;\n\r  LDF_SetSignalValue(LDFHandle,&nbsp;\"LIN_CONTROL\",&nbsp;\"Reg_Blind\",&nbsp;1);&nbsp;&nbsp;\n\r  //执行调度表&nbsp;&nbsp;\n\r  LDF_ExeSchToBus(LDFHandle,&nbsp;\"Nissan\");&nbsp;&nbsp;\n\r  LDF_GetSignalValueStr(LDFHandle,&nbsp;\"LIN_STATE\",&nbsp;\"MM_State\",&nbsp;ValueStr);&nbsp;&nbsp;\n\r  printf(\"LIN_STATE.MM_State=%s\\n\",&nbsp;ValueStr);&nbsp;&nbsp;\n\r  LDF_GetSignalValueStr(LDFHandle,&nbsp;\"LIN_STATE\",&nbsp;\"Exc_Duty_Cycle\",&nbsp;ValueStr);&nbsp;&nbsp;\n\r  printf(\"LIN_STATE.Exc_Duty_Cycle=%s\\n\",&nbsp;ValueStr);&nbsp;&nbsp;\n\r  LDF_GetSignalValueStr(LDFHandle,&nbsp;\"LIN_STATE\",&nbsp;\"Exc_Current\",&nbsp;ValueStr);&nbsp;&nbsp;\n\r  printf(\"LIN_STATE.Exc_Current=%s\\n\",&nbsp;ValueStr);&nbsp;&nbsp;\n\r  LDF_GetSignalValueStr(LDFHandle,&nbsp;\"LIN_STATE\",&nbsp;\"iStARS_Voltage\",&nbsp;ValueStr);&nbsp;&nbsp;\n\r  printf(\"LIN_STATE.iStARS_Voltage=%s\\n\",&nbsp;ValueStr);&nbsp;&nbsp;\n\r","ldf_parser","topics\\函数说明/ldf_parser.htm","目录\n\r  概述\n\r  LDF_Decode\n\r  LDF_DataRawToFrame\n\r  LDF_DataFrameToRaw\n\r概述\n\r\n\r本文主要介绍LIN总线的LDF文件解析相关函数，使用这些函数可以将LDF文件中的内容解析为程序可用的结构体，也可以使用我们的函数将原始的LIN数据和LDF文件里面的信号数据进行双向转换。\n\r\n\r注意，使用这些函数需要连接我们的适配器才能正常使用，否则无法正常解析数据。\n\r\n\r函数的使用范例可以参考我们提供的二次开发范例程序源码。\n\r\n\r下面是本文相关函数可能会用到的宏定义：\n\r  #define&nbsp;LDF_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;//操作成功&nbsp;&nbsp;  #define&nbsp;LDF_ERROR_FILE_OPEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-1)//打开文件出错&nbsp;&nbsp;  #define&nbsp;LDF_ERROR_FILE_FORMAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-2)//文件格式错误&nbsp;&nbsp;  #define&nbsp;LDF_ERROR_DEV_DISCONNECT&nbsp;&nbsp;&nbsp;&nbsp;(-3)//设备未连接&nbsp;&nbsp;  &nbsp;&nbsp;  //逻辑类型编码值&nbsp;&nbsp;  typedef&nbsp;struct&nbsp;_LDF_CODING_LOGICAL{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;RawValue;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//实际值&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pDescription;&nbsp;//逻辑值编码字符串&nbsp;&nbsp;  }LDF_CODING_LOGICAL;&nbsp;&nbsp;  &nbsp;&nbsp;  //物理类型编码值，信号物理值=信号实际值*Factor+Offset&nbsp;&nbsp;  typedef&nbsp;struct&nbsp;_LDF_CODING_PHYSICAL{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;Offset;&nbsp;&nbsp;&nbsp;//信号物理值偏移量&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;Factor;&nbsp;&nbsp;&nbsp;//信号缩放因子&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Minimum;&nbsp;&nbsp;&nbsp;&nbsp;//信号实际最小值，注意不是物理值&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Maximum;&nbsp;&nbsp;&nbsp;&nbsp;//信号实际最大值，注意不是物理值&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pUnit;&nbsp;&nbsp;&nbsp;&nbsp;//信号物理值单位&nbsp;&nbsp;  }LDF_CODING_PHYSICAL;&nbsp;&nbsp;  &nbsp;&nbsp;  //信号中的值类型&nbsp;&nbsp;  enum&nbsp;LDF_SIGNAL_VALUE_TYPE{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;LDF_SIGNAL_VALUE_TYPE_SCALAR,&nbsp;&nbsp;&nbsp;//标量值&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;LDF_SIGNAL_VALUE_TYPE_ARRAY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数组值&nbsp;&nbsp;  };&nbsp;&nbsp;  &nbsp;&nbsp;  //信号值编码类型&nbsp;&nbsp;  enum&nbsp;LDF_SIGNAL_CODING_TYPE{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;LDF_SIGNAL_CODING_TYPE_NONE,&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;LDF_SIGNAL_CODING_TYPE_PHYSICAL,//物理值&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;LDF_SIGNAL_CODING_TYPE_LOGICAL&nbsp;&nbsp;//逻辑值&nbsp;&nbsp;  };&nbsp;&nbsp;  &nbsp;&nbsp;  //信号类型&nbsp;&nbsp;  enum&nbsp;LDF_SIGNAL_TYPE{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;LDF_SIGNAL_TYPE_NORMAL,&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;LDF_SIGNAL_TYPE_DIAGNOSTIC&nbsp;&nbsp;  };&nbsp;&nbsp;  &nbsp;&nbsp;  //帧类型&nbsp;&nbsp;  enum&nbsp;LDF_FRAME_TYPE{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;LDF_FRAME_TYPE_NORMAL,&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;LDF_FRAME_TYPE_DIAGNOSTIC&nbsp;&nbsp;  };&nbsp;&nbsp;  &nbsp;&nbsp;  //信号编码&nbsp;&nbsp;  typedef&nbsp;struct&nbsp;_LDF_SIGNAL_CODING{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pName;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//信号编码名称&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;LogicalValueLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//逻辑值长度&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;PhysicalValueLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//物理值长度&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;LDF_CODING_LOGICAL&nbsp;*pLogicalValues;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//逻辑值列表指针&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;LDF_CODING_PHYSICAL&nbsp;*pPhysicalValues;&nbsp;&nbsp;&nbsp;//物理值列表指针&nbsp;&nbsp;  }LDF_SIGNAL_CODING;&nbsp;&nbsp;  &nbsp;&nbsp;  //信号和信号编码对应值&nbsp;&nbsp;  typedef&nbsp;struct&nbsp;_LDF_SIGNAL_REPRESENTATION{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pSignalName;&nbsp;&nbsp;//信号名称&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pCodingName;&nbsp;&nbsp;//编码名称&nbsp;&nbsp;   }LDF_SIGNAL_REPRESENTATION;&nbsp;&nbsp;   &nbsp;&nbsp;   //信号值结构体，结构体里面的值二取一，并不是同时存在&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_LDF_SIGNAL_VALUE{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;long&nbsp;ScalarValue;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//物理值&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;ArrayValue[8];//数组&nbsp;&nbsp;   }LDF_SIGNAL_VALUE;&nbsp;&nbsp;   &nbsp;&nbsp;   //信号编码&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_LDF_LIN_SIGNAL{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pName;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//信号名称&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//信号大小，单位为bit&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_SIGNAL_TYPE&nbsp;Type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//普通信号或者诊断信号&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_SIGNAL_VALUE_TYPE&nbsp;ValueType;//数值或者数组&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_SIGNAL_VALUE&nbsp;Value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//信号值&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pPublisher;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//信号发布者名称，可能为主机或者从机&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;SubscriberLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//接收该信号节点长度&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pSubscribers[16];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//接收该信号的节点名称数组&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;Offset;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//该信号在8字节数据中的偏移量&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_SIGNAL_CODING&nbsp;SignalCodings;//信号编码&nbsp;&nbsp;   }LDF_LIN_SIGNAL;&nbsp;&nbsp;   &nbsp;&nbsp;   //帧，每帧数据包含多个信号&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_LDF_LIN_FRAME{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pName;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//帧名称&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;ID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//帧ID&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pPublisher;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//发布者名称&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;Size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//帧长度，单位为字节&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_FRAME_TYPE&nbsp;Type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//帧类型&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;SignalListLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//信号长度&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_LIN_SIGNAL&nbsp;*pSignalList;//信号指针&nbsp;&nbsp;   }LDF_LIN_FRAME;&nbsp;&nbsp;   //节点结构体&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_LDF_LIN_NODE{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pMasterName;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//主机名称&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;time_base;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;jitter;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;SlaveLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从机数量&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pSlaveNames[16];&nbsp;&nbsp;//从机名称数组&nbsp;&nbsp;   }LDF_LIN_NODE;&nbsp;&nbsp;   &nbsp;&nbsp;   //调度表命令&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_LDF_LIN_SCH_CMD{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_LIN_FRAME&nbsp;Frame;&nbsp;&nbsp;&nbsp;&nbsp;//LIN帧&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;DelayOfMs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//延时时间，单位为毫秒&nbsp;&nbsp;   }LDF_LIN_SCH_CMD;&nbsp;&nbsp;   &nbsp;&nbsp;   //调度表&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_LDF_LIN_SCH{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pName;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//调度表名称&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ScheduleCmdLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//该表下面包含的帧数&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_LIN_SCH_CMD&nbsp;*pScheduleCmdList;&nbsp;&nbsp;//改表下面的帧列表&nbsp;&nbsp;   }LDF_LIN_SCH;&nbsp;&nbsp;   &nbsp;&nbsp;   //节点属性&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_LDF_NODE_ATTR{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*pName;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;LIN_protocol;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;configured_NAD;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;initial_NAD;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;supplier_id;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;function_id;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;variant;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}product_id;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*response_error;//signal_name&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*fault_state_signals[64];&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fault_state_signal_len;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;P2_min;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;ST_min;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;N_As_timeout;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;N_Cr_timeout;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*configurable_frames[64];&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;configurable_frame_len;&nbsp;&nbsp;   }LDF_NODE_ATTR;&nbsp;&nbsp;   &nbsp;&nbsp;   //解析后的LDF文件内容&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_LDF_CODING{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ProtocolVersion;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//LIN&nbsp;protocol&nbsp;version,实际版本号的一百倍值，比如当前值为210，那么实际版本为2.1&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;LanguageVersion;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//LIN&nbsp;language&nbsp;version,实际版本号的一百倍值，比如当前值为210，那么实际版本为2.1&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;LINSpeed;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//LIN总线波特率，单位为bps&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_LIN_NODE&nbsp;*pNode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//节点指针&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;FrameLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//帧长度&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_LIN_FRAME&nbsp;*pFrames;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//帧指针&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;NodeAttrLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//节点属性长度&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_NODE_ATTR&nbsp;*pNodeAttrs;&nbsp;&nbsp;//节点属性指针&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;LINSchLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//调度表长度&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LDF_LIN_SCH&nbsp;*pLINSch;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//调度表指针&nbsp;&nbsp;   }LDF_CODING;&nbsp;&nbsp;\n\r\n\r\n\rLDF_Decode\n\r\n\r\n\r\n\r描述：\n\r\n\r输入LDF文件，解析后输出LDF文件的结构体表述形式。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_Decode(int&nbsp;DevHandle,char&nbsp;*pLDFFileName,LDF_CODING&nbsp;*pLDFCoding);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice 函数获得。 \n\r\n\rpLDFFileName LDF格式的文件名，建议传入完整的文件路径。\n\r\n\rpLDFCoding 解析之后LDF结构体指针。\n\r\n\r返回值：\n\r\n\r函数执行状态，0-函数执行成功，其他值，函数执行出错。LDF_DataRawToFrame\n\r\n\r\n\r\n\r描述：\n\r\n\r将原始的LIN数据转换成帧里面的信号值。这样就可以直接获取信号值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_DataRawToFrame(LDF_LIN_FRAME&nbsp;*pFrame,unsigned&nbsp;char&nbsp;*pRawData);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rpFrame 用于存储数据的帧指针。\n\r\n\rpRawData 原始LIN数据指针。\n\r\n\r返回值：\n\r\n\r函数执行状态，0-函数执行成功，其他值，函数执行出错。LDF_DataFrameToRaw\n\r\n\r\n\r\n\r描述：\n\r\n\r将帧里面的数据转换成原始的LIN数据，方便调用我们的LIN发送数据函数将数据发送到LIN总线上。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;LDF_DataFrameToRaw(LDF_LIN_FRAME&nbsp;*pFrame,unsigned&nbsp;char&nbsp;*pRawData);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rpFrame 用于获取数据的帧指针。\n\r\n\rpRawData 原始LIN数据指针。\n\r\n\r返回值：\n\r\n\r函数执行状态，0-函数执行成功，其他值，函数执行出错。","LDFDecoder","topics\\函数说明/LDFDecoder.htm"," Help &gt; 函数说明 &gt; lin_uds目录\n\r    概述    LIN_UDS_Request    LIN_UDS_Response    LIN_UDS_GetMsgFromUDSBuffer\n\r概述 \n\r\n\r基于UDS协议实现的LIN UDS操作函数，使用这些函数可以实现LIN UDS的所有功能。注意，在调用这些函数之前，需要先调用扫描设备，打开设备，LIN初始化的函数。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  #define&nbsp;LIN_UDS_OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;  #define&nbsp;LIN_UDS_TRAN_USB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-98&nbsp;&nbsp;  #define&nbsp;LIN_UDS_TRAN_LIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-99&nbsp;&nbsp;  #define&nbsp;LIN_UDS_TIMEOUT_A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-100&nbsp;&nbsp;  #define&nbsp;LIN_UDS_TIMEOUT_Bs&nbsp;&nbsp;&nbsp;&nbsp;-101&nbsp;&nbsp;  #define&nbsp;LIN_UDS_TIMEOUT_Cr&nbsp;&nbsp;&nbsp;&nbsp;-102&nbsp;&nbsp;  #define&nbsp;LIN_UDS_WRONG_SN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-103&nbsp;&nbsp;  #define&nbsp;LIN_UDS_INVALID_FS&nbsp;&nbsp;&nbsp;&nbsp;-104&nbsp;&nbsp;  #define&nbsp;LIN_UDS_UNEXP_PDU&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-105&nbsp;&nbsp;  #define&nbsp;LIN_UDS_WFT_OVRN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-106&nbsp;&nbsp;  #define&nbsp;LIN_UDS_BUFFER_OVFLW&nbsp;&nbsp;-107&nbsp;&nbsp;  #define&nbsp;LIN_UDS_ERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-108&nbsp;&nbsp;  &nbsp;&nbsp;  //1.LIN&nbsp;UDS地址定义&nbsp;&nbsp;  typedef&nbsp;&nbsp;struct&nbsp;&nbsp;_LIN_UDS_ADDR&nbsp;&nbsp;  {&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;ReqID;&nbsp;//请求报文ID，一般为0x3C。&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;ResID;&nbsp;//应答报文ID，一般为0x3D。&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;NAD;&nbsp;&nbsp;&nbsp;//节点地址，0x7F为广播地址&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CheckType;//0-标准，1-增强，一般为标准校验&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;STmin;&nbsp;&nbsp;//连续帧时间间隔，单位为毫秒&nbsp;&nbsp;  }LIN_UDS_ADDR;&nbsp;&nbsp;\n\rLIN_UDS_Request\n\r\n\r描述：\n\r\n\r按照UDS协议发送数据，被测设备收到这些数据后，会发送响应数据。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;LIN_UDS_Request(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,LIN_UDS_ADDR&nbsp;*pUDSAddr,unsigned&nbsp;char&nbsp;*pReqData,int&nbsp;DataLen);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex 0-对应LIN1,1-对应LIN2。\n\r\n\rpUDSAddr UDS协议发送数据时需要用到的相关ID。\n\r\n\rpReqData UDS协议里面的SID加上SID所携带的数据。\n\r\n\rDataLen pReqData里面的有效数据。\n\r\n\r返回值：\n\r\n\r函数执行状态，为LIN_UDS_OK表示成功，否则为失败。\n\r\n\r示例：LIN_UDS_Response\n\r\n\r描述：\n\r\n\r按照UDS协议发送数据后，获取设备响应的数据。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;LIN_UDS_Response(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,LIN_UDS_ADDR&nbsp;*pUDSAddr,unsigned&nbsp;char&nbsp;*pResData,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex 0-对应LIN1,1-对应LIN2。\n\r\n\rpUDSAddr UDS协议发送数据时需要用到的相关ID。\n\r\n\rpResData&nbsp; 存储设备返回的UDS数据，第一个字节为RSID，后面的为RSID所携带的参数。\n\r\n\rTimeOutMs 获取数据超时时间。\n\r\n\r返回值：\n\r\n\r函数执行状态，大于0，表示获取到的响应字节数，否则为失败。\n\r\n\r示例：LIN_UDS_GetMsgFromUDSBuffer\n\r\n\r描述：\n\r\n\r调用LIN_UDS_Request和LIN_UDS_Response函数后，读取LIN总线上收发的LIN数据，在调用LIN_UDS_Request的时候会清除之前缓冲区中的所有消息。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;LIN_UDS_GetMsgFromUDSBuffer(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,LIN_EX_MSG&nbsp;*pLINMsg,int&nbsp;BufferSize);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex 0-对应LIN1,1-对应LIN2。\n\r\n\rpLINMsg 存储LIN消息的缓冲区指针。\n\r\n\rBufferSize&nbsp; 缓冲区大小。\n\r\n\r返回值：\n\r\n\r函数执行状态，大于0，表示获取到缓冲区帧数，否则为失败。\n\r\n\r示例： Copyright ? 2018. All rights reserved.","lin_uds","topics\\函数说明/lin_uds.htm","目录\n\r  概述  USB_ScanDevice  USB_OpenDevice  USB_CloseDevice  DEV_GetDeviceInfo  DEV_EraseUserData  DEV_WriteUserData  DEV_ReadUserData  DEV_SetPowerLevel\n\r概述\n\r\n\r本文介绍USB2XXX设备操作相关函数，有些函数在进行二次开发时是必须要被调用的，因此若要使用USB2XXX的API接口函数进行二次开发，必须了解下这些函数的基本功能和使用方法。\n\r\n\r下面是本文函数可能用到的一些宏定义：\n\r  //定义设备信息&nbsp;&nbsp;  typedef&nbsp;struct&nbsp;_DEVICE_INFO&nbsp;&nbsp;   {&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;FirmwareName[32];&nbsp;&nbsp;&nbsp;//固件名称字符串&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;BuildDate[32];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;//固件编译时间字符串&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HardwareVersion;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//硬件版本号&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FirmwareVersion;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;//固件版本号&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SerialNumber[3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//适配器序列号&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Functions;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;//适配器当前具备的功能&nbsp;&nbsp;   }DEVICE_INFO,*PDEVICE_INFO;&nbsp;&nbsp;   &nbsp;&nbsp;   //定义电压输出值&nbsp;&nbsp;   #define&nbsp;POWER_LEVEL_NONE&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;//不输出&nbsp;&nbsp;   #define&nbsp;POWER_LEVEL_1V8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;//输出1.8V&nbsp;&nbsp;   #define&nbsp;POWER_LEVEL_2V5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;//输出2.5V&nbsp;&nbsp;   #define&nbsp;POWER_LEVEL_3V3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;//输出3.3V&nbsp;&nbsp;   #define&nbsp;POWER_LEVEL_5V0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;//输出5.0V&nbsp;&nbsp;\n\rUSB_ScanDevice\n\r\n\r描述：\n\r\n\r扫描当前连接到电脑上的USB2XXX设备，同时通过pDevHandle返回每个设备的设备号，利用该设备号可以分别控制不同的设备。函数返回当前连接到电脑上的USB2XXX设备数量。\n\r\n\r原型：\n\r  #ifdef&nbsp;OS_ANDROID&nbsp;&nbsp;   int&nbsp;&nbsp;WINAPI&nbsp;USB_ScanDevice(int&nbsp;*pDevHandle,int&nbsp;fd);&nbsp;&nbsp;   #else&nbsp;&nbsp;   int&nbsp;&nbsp;WINAPI&nbsp;USB_ScanDevice(int&nbsp;*pDevHandle);&nbsp;&nbsp;   #endif&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rpDevHandle&nbsp; 返回每个设备唯一不变的设备号指针，以后对设备的任何操作都必须传入该设备号，注意每个设备的设备号都是不同的，所以在对设备进行任何操作之前都必须调用该函数获得其设备号。\n\r\n\rfd 该参数是在安卓系统下用JNA调用我们的函数需要传入的参数，fd的获取方式可以参考我们提供的安卓版本二次开发范例程序源码。\n\r\n\r返回值：\n\r\n\r当前连接到电脑的设备数量，若返回值小于0，则调用该函数出错。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;DevHandle[20];//假设当前最多连接的设备不超过20个&nbsp;&nbsp;   ret&nbsp;=&nbsp;USB_ScanDevice(DevHandle);&nbsp;&nbsp;   if(ret&nbsp;&lt;=&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"无设备连接!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"当前连接的设备数为：%d\\n\",ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"每个设备的句柄为：\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;ret;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"DevHandle[%d]&nbsp;=&nbsp;%d\\n\",i,DevHandle[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rUSB_OpenDevice\n\r\n\r描述：\n\r\n\r打开设备，必须调用该函数，否则后续函数调用无法成功。\n\r\n\r原型：\n\r  bool&nbsp;WINAPI&nbsp;USB_OpenDevice(int&nbsp;DevHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数或得。\n\r\n\r返回值：\n\r\n\r打开设备状态。0-打开设备失败，1-打开设备成功。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   bool&nbsp;state;&nbsp;&nbsp;   int&nbsp;DevHandle;&nbsp;&nbsp;   int&nbsp;DevNum&nbsp;=&nbsp;USB_ScanDevice(&amp;DevHandle);//确保当前接入的设备只有一个，否则DevHandle需要使用数组&nbsp;&nbsp;   if(DevNum&nbsp;&gt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;=&nbsp;USB_OpenDevice(DevHandle);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if(state){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"打开设备成功!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"打开设备失败！\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rUSB_CloseDevice\n\r\n\r描述：\n\r\n\r关闭已经打开的设备，在不需要使用设备的时候可以调用该函数关闭设备，比如在程序退出之前可以调用该函数。\n\r\n\r原型：\n\r  bool&nbsp;WINAPI&nbsp;USB_CloseDevice(int&nbsp;DevHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice函数或得。\n\r\n\r返回值：\n\r\n\r打开设备状态。0-关闭设备失败，1-关闭设备成功。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   bool&nbsp;state;&nbsp;&nbsp;   state&nbsp;=&nbsp;USB_CloseDevice(DevHandle);&nbsp;&nbsp;   if(state){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"关闭设备成功!\\n\");&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"关闭设备失败！\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rDEV_GetDeviceInfo\n\r\n\r描述：\n\r\n\r获取设备信息，如固件版本号，固件编译时间，硬件版本号，设备唯一序列号。\n\r\n\r原型：\n\r  bool&nbsp;WINAPI&nbsp;DEV_GetDeviceInfo(int&nbsp;DevHandle,PDEVICE_INFO&nbsp;pDevInfo,char&nbsp;*pFunctionStr);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice函数或得。\n\r\n\rpDevInfo&nbsp; 设备信息结构体指针，PDEVICE_INFO的定义如下所示：\n\r      //定义设备信息&nbsp;&nbsp;     typedef&nbsp;struct&nbsp;_DEVICE_INFO&nbsp;&nbsp;   {&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;FirmwareName[32];&nbsp;&nbsp;&nbsp;//固件名称字符串&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;BuildDate[32];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;//固件编译时间字符串&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HardwareVersion;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//硬件版本号&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FirmwareVersion;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;//固件版本号&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SerialNumber[3];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//适配器序列号&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Functions;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;//适配器当前具备的功能&nbsp;&nbsp;   }DEVICE_INFO,*PDEVICE_INFO;&nbsp;&nbsp;\n\r\n\r\n\r&nbsp;&nbsp; pFunctionStr&nbsp; 设备功能描述字符串，类似于“USB2IIC,USB2SPI,USB2PWM,USB2ADC,USB2GPIO,USB2CNT,USB2UART”。\n\r\n\r返回值：\n\r\n\r获取设备信息是否成功，0-获取设备信息失败，1-获取设备信息成功。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   bool&nbsp;state;&nbsp;&nbsp;   DEVICE_INFO&nbsp;DevInfo;&nbsp;&nbsp;   char&nbsp;&nbsp;&nbsp;&nbsp;FuncStr[256]={0};&nbsp;&nbsp;   state&nbsp;=&nbsp;&nbsp;&nbsp;&nbsp;USB_GetDeviceInfo(DevHandle,&amp;DevInfo,FuncStr);&nbsp;&nbsp;   if(state){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Firmware&nbsp;Name:%s\\n\",DevInfo.FirmwareName);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Firmware&nbsp;Build&nbsp;Date:%s\\n\",DevInfo.BuildDate);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Firmware&nbsp;Version:v%d.%d.%d\\n\",(DevInfo.FirmwareVersion&gt;&gt;24)&amp;0xFF,(DevInfo.FirmwareVersion&gt;&gt;16)&amp;0xFF,DevInfo.FirmwareVersion&amp;0xFFFF);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Hardware&nbsp;Version:v%d.%d.%d\\n\",(DevInfo.HardwareVersion&gt;&gt;24)&amp;0xFF,(DevInfo.HardwareVersion&gt;&gt;16)&amp;0xFF,DevInfo.HardwareVersion&amp;0xFFFF);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Firmware&nbsp;Functions:%08X\\n\",DevInfo.Functions);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Firmware&nbsp;&nbsp;Functions:%s\\n\",FuncStr);&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"获取设备信息失败！\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rDEV_EraseUserData\n\r\n\r描述：\n\r\n\r擦出用户数据存储区域的数据，擦出数据后，默认数据全部为0xFF，用户自定义数据存储区可以存储64KByte数据，但是单次写入数据量不能大于20KByte。\n\r\n\r原型：\n\r  bool&nbsp;WINAPI&nbsp;DEV_EraseUserData(int&nbsp;DevHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice函数或得。\n\r\n\r返回值：\n\r\n\r擦出数据状态。0-擦出数据失败，1-擦出数据成功。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   bool&nbsp;state;&nbsp;&nbsp;   state&nbsp;=&nbsp;USB_EraseUserData(DevHandle);&nbsp;&nbsp;   if(!state){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Erase&nbsp;user&nbsp;data&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rDEV_WriteUserData\n\r\n\r描述：\n\r\n\r向用户区写入用户自定义数据，单次写入数据不能超过20KByte，总的数据不能超过64KByte。\n\r\n\r原型：\n\r  bool&nbsp;WINAPI&nbsp;DEV_WriteUserData(int&nbsp;DevHandle,int&nbsp;OffsetAddr,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;DataLen);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice函数或得。\n\r\n\rOffsetAddr&nbsp; 写入数据在用户区的偏移地址，地址从0x0000开始，小于等于0xFFFF。\n\r\n\rpWriteData&nbsp; 待写入的数据缓冲区地址。\n\r\n\rDataLen&nbsp; 待写入的数据字节数。\n\r\n\r返回值：\n\r\n\r写入数据状态。0-写入数据失败，1-写入数据成功。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   bool&nbsp;state;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;UserData[512]={0};&nbsp;&nbsp;   strcpy((char*)UserData,\"Hello&nbsp;user&nbsp;define&nbsp;data!\");&nbsp;&nbsp;   state&nbsp;=&nbsp;USB_WriteUserData(DevHandle,0,UserData,sizeof(UserData));&nbsp;&nbsp;   if(!state){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"User&nbsp;data&nbsp;write&nbsp;data&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rDEV_ReadUserData\n\r\n\r描述：\n\r\n\r从用户数据区域读取用户写入的自定义数据，单次读取数据最多不能超过20KByte。\n\r\n\r原型：\n\r  bool&nbsp;WINAPI&nbsp;DEV_ReadUserData(int&nbsp;DevHandle,int&nbsp;OffsetAddr,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;DataLen);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice函数或得。\n\r\n\rOffsetAddr&nbsp; 读取数据在用户区的偏移地址，地址从0x0000开始，小于等于0xFFFF。\n\r\n\rpReadData&nbsp; 待保存读取数据的缓冲区地址。\n\r\n\rDataLen&nbsp; 待读取的数据字节数。\n\r\n\r返回值：\n\r\n\r读取数据状态。0-读取数据失败，1-读取数据成功。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   bool&nbsp;state;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;UserData[512]={0};&nbsp;&nbsp;   //从用户区读取数据&nbsp;&nbsp;   state&nbsp;=&nbsp;USB_ReadUserData(DevHandle,0,UserData,sizeof(UserData));&nbsp;&nbsp;   if(!state){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"User&nbsp;data&nbsp;write&nbsp;data&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"USER&nbsp;DATA&nbsp;=&nbsp;%s&nbsp;\\n\",UserData);&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rDEV_SetPowerLevel\n\r\n\r描述：\n\r\n\r设置接口输出电平电压，注意，该函数只对带接口电压配置的适配器有用。\n\r\n\r原型：\n\r  bool&nbsp;WINAPI&nbsp;DEV_SetPowerLevel(int&nbsp;DevHandle,char&nbsp;PowerLevel);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice函数或得。\n\r\n\rPowerLevel&nbsp; 接口电压，0-0V，1-1.8V，2-2.5V，3-3.3V，4-5V。\n\r\n\r返回值：\n\r\n\r设置接口电压状态。0-设置电压失败，1-设置电压成功。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   //定义电压输出值&nbsp;&nbsp;   #define&nbsp;POWER_LEVEL_NONE&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;//不输出&nbsp;&nbsp;   #define&nbsp;POWER_LEVEL_1V8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;//输出1.8V&nbsp;&nbsp;   #define&nbsp;POWER_LEVEL_2V5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;//输出2.5V&nbsp;&nbsp;   #define&nbsp;POWER_LEVEL_3V3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;//输出3.3V&nbsp;&nbsp;   #define&nbsp;POWER_LEVEL_5V0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;//输出5.0V&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   bool&nbsp;state;&nbsp;&nbsp;   //将接口电压设置为1.8V&nbsp;&nbsp;   state&nbsp;=&nbsp;DEV_SetPowerLevel(DevHandle,POWER_LEVEL_1V8);&nbsp;&nbsp;   if(!state){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Set&nbsp;powerlevel&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Set&nbsp;powerlevel&nbsp;success\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\r","usb_device","topics\\函数说明/usb_device.htm","目录\n\r  概述  ADC_Init  ADC_Read     ADC_StartContinueRead  ADC_StopContinueRead  ADC_GetData\n\r概述&nbsp;\n\r\n\r 本文主要介绍关于USB2XXX的ADC操作相关API，在调用这些函数前需要调用设备操作相关函数，比如扫描设备，打开设备等，详情请查看《设备操作相关函数说明 》。\n\r\n\r下面是本文函数可能会用到的一些宏定义： \n\r  //定义函数返回错误代码&nbsp;&nbsp;  #define&nbsp;ADC_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;  #define&nbsp;ADC_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;  #define&nbsp;ADC_ERR_USB_WRITE_FAIL&nbsp;&nbsp;(-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;  #define&nbsp;ADC_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;   (-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;  #define&nbsp;ADC_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;  #define&nbsp;ADC_ERR_CH_NO_INIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-5)&nbsp;&nbsp;//该通道未初始化&nbsp;&nbsp;  &nbsp;&nbsp;  //定义连续采集数据模式下的回调函数&nbsp;&nbsp;  typedef&nbsp;&nbsp;int&nbsp;(WINAPI&nbsp;*PADC_GET_DATA_HANDLE)(int&nbsp;DevHandle,unsigned&nbsp;short&nbsp;*pData,int&nbsp;DataNum);//接收数据回掉函数&nbsp;&nbsp;\n\rADC_Init\n\r\n\r描述：\n\r\n\r初始化配置ADC，调用该函数之后可以通过调用ADC_Read函数获取ADC的值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;ADC_Init(int&nbsp;DevHandle,char&nbsp;Channel,int&nbsp;SampleRateHz);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数或得。\n\r\n\rChannel&nbsp; 需要初始化配置的ADC通道，每个bit位代表一个通道，最低位代表通道0，最多4个通道。对应通道值为1则初始化并使能该通道ADC。在调用ADC_Read函数的时候，会根据该通道值返回对应的数据。\n\r\n\rSampleRateHz&nbsp; ADC采集多个数据时的采样频率，单位为Hz，最大2500000Hz。若同时使能多个通道时，其最大采样率会根据通道值降低，比如同时使能了4个通道，那么最大采样率为2500000/4=625000.\n\r\n\r返回值：\n\r\n\r初始化ADC的状态，0-配置成功，其他值，配置失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb2adc.h\"&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  int&nbsp;ret;&nbsp;&nbsp;  char&nbsp;ADC_Channel&nbsp;=&nbsp;0x01;//初始化配置ADC_IN0&nbsp;  ret&nbsp;=&nbsp;ADC_Init(DevHandle,ADC_Channel,1000000);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"初始化配置ADC失败!\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;  }&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\rADC_Read\n\r\n\r描述：\n\r\n\r立即获取ADC采样值，其通道通过ADC_Init函数指定。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;ADC_Read(int&nbsp;DevHandle,short&nbsp;*pData,int&nbsp;DataNum);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rpData&nbsp; 数据存储缓冲区首地址，当只初始化了1路ADC时，其数据只有DataNum个，若初始化了n路ADC，则返回的数据有n*DataNum个数据，数据按照ADC_IN0,ADC_IN1,…ADC_INn这样依次排列，假如说初始化配置了ADC_IN0,ADC_IN1,ADC_IN2,DataNum为3，那么总的数据有3*3=9个，数据的顺序为ADC_IN0_DATA0,ADC_IN1_DATA0,ADC_IN2_DATA0,ADC_IN0_DATA1,ADC_IN1_DATA1,ADC_IN2_DATA1,ADC_IN0_DATA2,ADC_IN1_DATA2,ADC_IN2_DATA2.\n\r\n\rDataNum&nbsp; 每个ADC通道采集的数据数。\n\r\n\r返回值：\n\r\n\r获取ADC数据的状态，0-获取数据成功，其他值，获取数据失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb2adc.h\"&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  int&nbsp;ret;&nbsp;&nbsp;  int&nbsp;DataNum&nbsp;=&nbsp;10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//每通道获取10个ADC采样值&nbsp;&nbsp;  short   Buffer[DataNum*BitCount(ADC_Channel)];&nbsp;&nbsp;&nbsp;    ret&nbsp;=&nbsp;ADC_Read(DevHandle,Buffer,DataNum);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;adc&nbsp;error!\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;  }else{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;DataNum*BitCount(ADC_Channel);i++){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"ADC&nbsp;Data[%d]&nbsp;=&nbsp;%fV\\n\",i,(Buffer[i]*3.3)/4095);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  }&nbsp;&nbsp;\n\rADC_StartContinueRead\n\r\n\r描述：\n\r\n\r启动ADC连续采样，调用该函数后，ADC将以设置的采样率连续采集数据，直到调用ADC_StopContinueRead函数为止。可以通过传入的回调函数或者调用ADC_GetData函数获取采集到的数据。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;ADC_StartContinueRead(int&nbsp;DevHandle,char&nbsp;Channel,int&nbsp;SampleRateHz,int&nbsp;FrameSize,PADC_GET_DATA_HANDLE&nbsp;pGetDataHandle);&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rChannel&nbsp; 需要初始化配置的ADC通道，每个bit位代表一个通道，最低位代表通道0，最多4个通道。对应通道值为1则初始化并使能该通道ADC。在调用ADC_Read函数的时候，会根据该通道值返回对应的数据。\n\r\n\rSampleRateHz&nbsp; ADC采集多个数据时的采样频率，单位为Hz，最大2500000Hz。若同时使能多个通道时，其最大采样率会根据通道值降低，比如同时使能了4个通道，那么最大采样率为2500000/4=625000.\n\r\n\rFrameSize&nbsp; 连续采样时每次传输数据个数SampleRateHz*1000/FrameSize最好大于或者等于20。\n\r\n\rpGetDataHandle&nbsp; 读取到数据之后的回调函数，该函数需要上层代码自己实现，并在里面做对应的数据处理。\n\r\n\r返回值：\n\r\n\r启动连续采样的状态，0-启动成功，其他值，启动失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb2adc.h\"&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  int&nbsp;GetAdcDataHandle(int&nbsp;DevHandle,unsigned&nbsp;short&nbsp;*pData,int&nbsp;DataNum)&nbsp;&nbsp;  {&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Get&nbsp;%d&nbsp;Byte&nbsp;Data\\n\",DataNum);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"ADC&nbsp;Data&nbsp;=&nbsp;%fV\\n\",(pData[0]*3.3)/4095);&nbsp;&nbsp;  }&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  int&nbsp;ret;&nbsp;&nbsp;  char&nbsp;ADC_Channel&nbsp;=&nbsp;0x01;&nbsp;&nbsp;  ret&nbsp;=&nbsp;ADC_StartContinueRead(DevHandle,ADC_Channel,1000000,GetAdcDataHandle);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;ADC_SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;Continue&nbsp;Read&nbsp;adc&nbsp;error!\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;  }else{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;Continue&nbsp;Read&nbsp;ADC&nbsp;ADC_SUCCESS!\\n\");&nbsp;&nbsp;  }&nbsp;&nbsp;\n\rADC_StopContinueRead\n\r\n\r描述：\n\r\n\r停止ADC的连续采样。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;ADC_StopContinueRead(int&nbsp;DevHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\r返回值：\n\r\n\r停止ADC连续采样状态，0-停止成功，其他值，停止失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb2adc.h\"&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  int&nbsp;ret;&nbsp;&nbsp;  ret&nbsp;=&nbsp;ADC_StopContinueRead(DevHandle);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"停止ADC连续采样失败!\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;  }&nbsp;&nbsp;\n\rADC_GetData\n\r\n\r描述：\n\r\n\r启动ADC连续采集数据之后，通过该函数获取存入数据缓冲区中的数据，该函数应在ADC_StopContinueRead函数被调用之前连续调用，以防止接收的数据太大，导致数据缓冲区溢出。若在启动连续获取数据函数时传入了回调函数，则无需通过该函数来获取数据。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;ADC_GetData(int&nbsp;DevHandle,unsigned&nbsp;short&nbsp;*pDataBuffer,int&nbsp;BufferSize);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rpDataBuffer&nbsp; 数据存储缓冲区首地址。缓冲区最小为10240个unsigned short大小，其他缓冲区大小最好按照10240整数倍分配。\n\r\n\rBufferSize&nbsp; 数据缓冲区大小，单位为short，比如数据缓冲区声明为unsigned short DataBuffer[10240],那么该值为10240.\n\r\n\r返回值：\n\r\n\r从数据接收缓冲区实际获取到的数据数，单位为unsigned short数据类型大小。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb2adc.h\"&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  unsigned&nbsp;short&nbsp;ReadDataBuffer[20480];&nbsp;&nbsp;  int&nbsp;ReadDataNum;&nbsp;&nbsp;  ReadDataNum&nbsp;=&nbsp;ADC_GetData(DevHandle,ReadDataBuffer,20480);&nbsp;&nbsp;  printf(\"获取到%d个数据\\n\",ReadDataNum&nbsp;);&nbsp;&nbsp;\n\r","usb2adc","topics\\函数说明/usb2adc.htm","目录\n\r  概述  CAN_Init  CAN_Filter_Init  CAN_StartGetMsg  CAN_StopGetMsg  CAN_SendMsg  CAN_GetMsg  CAN_GetMsgWithSize  CAN_ClearMsg  CAN_GetStatus  CAN_SetSchedule  CAN_StartSchedule  CAN_StopSchedule  CAN_BL_Init   CAN_BL_NodeCheck  CAN_BL_Erase  CAN_BL_Write  CAN_BL_Excute  CAN_BL_SetNewBaudRate\n\r概述\n\r\n\rUSB2XXX有1路CAN总线，P3引脚为CAN_TX，P2为CAN_RX，板子上这两个引脚输出的是TTL电平,需要外接CAN收发器才能接入CAN总线，常用的CAN收发器芯片有TJA1050,SN65HVD230,AU5790(单线CAN)等。\n\r\n\rUSB2CAN/LIN适配器有2路CAN和1路LIN，内部集成收发器，可以直接接入CAN总线使用。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //1.CAN信息帧的数据类型定义&nbsp;&nbsp;   typedef&nbsp;&nbsp;struct&nbsp;&nbsp;_CAN_MSG&nbsp;&nbsp;   {&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //报文ID。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;TimeStamp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //接收到信息帧时的时间标识，从CAN&nbsp;控制器初始化开始计时。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;RemoteFlag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //是否是远程帧&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;ExternFlag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//是否是扩展帧&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;DataLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数据长度(&lt;=8)，即Data&nbsp;的长度。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Data[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//报文的数据。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp; unsigned&nbsp;char&nbsp;&nbsp;&nbsp;__Res;&nbsp;&nbsp;   }CAN_MSG,*PCAN_MSG;&nbsp;&nbsp;   &nbsp;&nbsp;   //2.初始化CAN的数据类型定义&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_CAN_INIT_CONFIG&nbsp;&nbsp;   {&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//CAN波特率&nbsp;=&nbsp;100MHz/(CAN_BRP)/(CAN_SJW+CAN_BS1+CAN_BS2)&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;CAN_BRP;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;//取值范围1~1024&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CAN_SJW;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //取值范围1~4&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CAN_BS1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //取值范围1~16&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CAN_BS2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //取值范围1~8&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CAN_Mode;&nbsp;&nbsp;&nbsp;&nbsp;//CAN工作模式，0-正常模式，1-环回模式，2-静默模式，3-静默环回模式，bit7为1则接入适配器内部终端电阻，否则不接入&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CAN_ABOM;&nbsp;&nbsp;&nbsp;&nbsp;//自动离线管理，0-禁止，1-使能&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CAN_NART;&nbsp;&nbsp;&nbsp;&nbsp;   //报文重发管理，0-使能报文重传，1-禁止报文重传&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CAN_RFLM;&nbsp;&nbsp;&nbsp;&nbsp;   //FIFO锁定管理，0-新报文覆盖旧报文，1-丢弃新报文&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CAN_TXFP;&nbsp;&nbsp;&nbsp;&nbsp;   //发送优先级管理，0-标识符决定，1-发送请求顺序决定&nbsp;&nbsp;   }CAN_INIT_CONFIG,*PCAN_INIT_CONFIG;&nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   //3.CAN&nbsp;滤波器设置数据类型定义&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_CAN_FILTER_CONFIG{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Enable;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //使能该过滤器，1-使能，0-禁止&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;FilterIndex;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //过滤器索引号，取值范围为0到13&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;FilterMode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //过滤器模式，0-屏蔽位模式，1-标识符列表模式&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;ExtFrame;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //过滤的帧类型标志，为1&nbsp;代表要过滤的为扩展帧，为0&nbsp;代表要过滤的为标准帧。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ID_Std_Ext;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //验收码ID&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ID_IDE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //验收码IDE&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ID_RTR;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //验收码RTR&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;MASK_Std_Ext;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //屏蔽码ID，该项只有在过滤器模式为屏蔽位模式时有用&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;MASK_IDE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //屏蔽码IDE，该项只有在过滤器模式为屏蔽位模式时有用&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;MASK_RTR;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //屏蔽码RTR，该项只有在过滤器模式为屏蔽位模式时有用&nbsp;&nbsp;   }&nbsp;CAN_FILTER_CONFIG,*PCAN_FILTER_CONFIG;&nbsp;&nbsp;   //4.CAN总线状态数据类型定义&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_CAN_STATUS{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;TSR;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ESR;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;RECounter;&nbsp;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器接收错误寄存器。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;TECounter;&nbsp;&nbsp;&nbsp;&nbsp;//CAN&nbsp;控制器发送错误寄存器。&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;LECode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //最后的错误代码&nbsp;&nbsp;   }CAN_STATUS,*PCAN_STATUS;&nbsp;&nbsp;   //5.定义CAN&nbsp;Bootloader命令列表&nbsp;&nbsp;   typedef&nbsp;&nbsp;struct&nbsp;&nbsp;_CBL_CMD_LIST{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//Bootloader相关命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Erase;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //擦出APP储存扇区数据&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;WriteInfo;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置多字节写数据相关参数（写起始地址，数据量）&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Write;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;//以多字节形式写数据&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Check;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //检测节点是否在线，同时返回固件信息&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;SetBaudRate;&nbsp;&nbsp;&nbsp;//设置节点波特率&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Excute;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //执行固件&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//节点返回状态&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;CmdSuccess;&nbsp;&nbsp;&nbsp;//命令执行成功&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;CmdFaild;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;   }&nbsp;CBL_CMD_LIST,*PCBL_CMD_LIST;&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;   //6.函数返回错误代码定义&nbsp;&nbsp;   #define&nbsp;CAN_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp; (0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;   #define&nbsp;CAN_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;   #define&nbsp;CAN_ERR_USB_WRITE_FAIL&nbsp;&nbsp;(-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;   #define&nbsp;CAN_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;   (-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;   #define&nbsp;CAN_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;   #define&nbsp;CAN_BL_ERR_CONFIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-20)&nbsp;//配置设备错误&nbsp;&nbsp;   #define&nbsp;CAN_BL_ERR_SEND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-21)&nbsp;//发送数据出错&nbsp;&nbsp;   #define&nbsp;CAN_BL_ERR_TIME_OUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-22)&nbsp;//超时错误&nbsp;&nbsp;   #define&nbsp;CAN_BL_ERR_CMD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-23)&nbsp;//执行命令失败&nbsp;&nbsp;   &nbsp;&nbsp;   //7.CAN&nbsp;Bootloader固件类型&nbsp;&nbsp;   #define&nbsp;CAN_BL_BOOT&nbsp;&nbsp;&nbsp;0x55555555&nbsp;&nbsp;   #define&nbsp;CAN_BL_APP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0xAAAAAAAA&nbsp;&nbsp;\n\rUSB2XXX CAN波特率表（UTA0101,UTA0201,UTA0301,UTA0302适用）：\n\r\n\r              \n\r\n\r波特率值(Kbps)          \n\r\n\rSJW          \n\r\n\rBS1          \n\r\n\rBS2          \n\r\n\rBRP            \n\r\n\r1000          \n\r\n\r1          \n\r\n\r2          \n\r\n\r1          \n\r\n\r25            \n\r\n\r900          \n\r\n\r1          \n\r\n\r2          \n\r\n\r1          \n\r\n\r28            \n\r\n\r800          \n\r\n\r1          \n\r\n\r3          \n\r\n\r1          \n\r\n\r25            \n\r\n\r666          \n\r\n\r1          \n\r\n\r3          \n\r\n\r1          \n\r\n\r30            \n\r\n\r600          \n\r\n\r1          \n\r\n\r4          \n\r\n\r1          \n\r\n\r28            \n\r\n\r500          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r25            \n\r\n\r400          \n\r\n\r1          \n\r\n\r8          \n\r\n\r1          \n\r\n\r25            \n\r\n\r300          \n\r\n\r1          \n\r\n\r7          \n\r\n\r1          \n\r\n\r37            \n\r\n\r250          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r50            \n\r\n\r225          \n\r\n\r1          \n\r\n\r3          \n\r\n\r1          \n\r\n\r89            \n\r\n\r200          \n\r\n\r1          \n\r\n\r16          \n\r\n\r3          \n\r\n\r25            \n\r\n\r160          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r78            \n\r\n\r150          \n\r\n\r1          \n\r\n\r15          \n\r\n\r2          \n\r\n\r37            \n\r\n\r144          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r87            \n\r\n\r125          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r100            \n\r\n\r120          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r104            \n\r\n\r100          \n\r\n\r1          \n\r\n\r16          \n\r\n\r3          \n\r\n\r50            \n\r\n\r90          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r139            \n\r\n\r80          \n\r\n\r1          \n\r\n\r1          \n\r\n\r3          \n\r\n\r278            \n\r\n\r75          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r167            \n\r\n\r60          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r208            \n\r\n\r50          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r250            \n\r\n\r40          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r312            \n\r\n\r30          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r417            \n\r\n\r20          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r625            \n\r\n\r10          \n\r\n\r1          \n\r\n\r13          \n\r\n\r2          \n\r\n\r625            \n\r\n\r5          \n\r\n\r1          \n\r\n\r16          \n\r\n\r3          \n\r\n\r1000\n\r\n\r波特率 = 100MHz/(BRP*(SJW+BS1+BS2))USB2CAN/LIN CAN波特率表（UTA0401,UTA0402,UTA0403适用）：\n\r\n\r              \n\r\n\r波特率值(Kbps)          \n\r\n\rSJW          \n\r\n\rBS1          \n\r\n\rBS2          \n\r\n\rBRP            \n\r\n\r1000          \n\r\n\r1          \n\r\n\r15          \n\r\n\r5          \n\r\n\r2            \n\r\n\r900          \n\r\n\r1          \n\r\n\r16          \n\r\n\r6          \n\r\n\r2            \n\r\n\r800          \n\r\n\r1          \n\r\n\r2          \n\r\n\r1          \n\r\n\r13            \n\r\n\r666          \n\r\n\r1          \n\r\n\r16          \n\r\n\r4          \n\r\n\r3            \n\r\n\r600          \n\r\n\r1          \n\r\n\r7          \n\r\n\r2          \n\r\n\r7            \n\r\n\r500          \n\r\n\r1          \n\r\n\r16          \n\r\n\r4          \n\r\n\r4            \n\r\n\r400          \n\r\n\r1          \n\r\n\r12          \n\r\n\r2          \n\r\n\r7            \n\r\n\r300          \n\r\n\r1          \n\r\n\r5          \n\r\n\r1          \n\r\n\r20            \n\r\n\r250          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r21            \n\r\n\r225          \n\r\n\r1          \n\r\n\r14          \n\r\n\r2          \n\r\n\r11            \n\r\n\r200          \n\r\n\r1          \n\r\n\r5          \n\r\n\r1          \n\r\n\r30            \n\r\n\r160          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r33            \n\r\n\r150          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r35            \n\r\n\r144          \n\r\n\r1          \n\r\n\r3          \n\r\n\r1          \n\r\n\r58            \n\r\n\r125          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r42            \n\r\n\r120          \n\r\n\r1          \n\r\n\r8          \n\r\n\r1          \n\r\n\r35            \n\r\n\r100          \n\r\n\r1          \n\r\n\r15          \n\r\n\r4          \n\r\n\r21            \n\r\n\r90          \n\r\n\r1          \n\r\n\r15          \n\r\n\r2          \n\r\n\r26            \n\r\n\r80          \n\r\n\r1          \n\r\n\r3          \n\r\n\r1          \n\r\n\r105            \n\r\n\r75          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r70            \n\r\n\r60          \n\r\n\r1          \n\r\n\r16          \n\r\n\r3          \n\r\n\r35            \n\r\n\r50          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r105            \n\r\n\r40          \n\r\n\r1          \n\r\n\r5          \n\r\n\r1          \n\r\n\r150            \n\r\n\r30          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r175            \n\r\n\r20          \n\r\n\r1          \n\r\n\r12          \n\r\n\r2          \n\r\n\r140            \n\r\n\r10          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r525            \n\r\n\r5          \n\r\n\r1          \n\r\n\r13          \n\r\n\r2          \n\r\n\r525\n\r\n\r波特率 = 42MHz/(BRP*(SJW+BS1+BS2))CAN_Init\n\r\n\r描述：\n\r\n\r初始化配置USB2CAN适配器，主要是初始化配置CAN控制器，配置CAN总线波特率。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_Init(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;PCAN_INIT_CONFIG&nbsp;pCanConfig);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rpCanConfig CAN控制器初始化配置参数结构体指针，结构体成员取值说明见概述。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2can.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   int&nbsp;CANIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   //初始化配置CAN&nbsp;&nbsp;   CAN_INIT_CONFIG&nbsp;CANConfig;&nbsp;&nbsp;   #if&nbsp;CAN_MODE_LOOPBACK&nbsp;&nbsp;   CANConfig.CAN_Mode&nbsp;=&nbsp;1;//环回模式&nbsp;&nbsp;   #else&nbsp;&nbsp;   CANConfig.CAN_Mode&nbsp;=&nbsp;0;//正常模式&nbsp;&nbsp;   #endif&nbsp;&nbsp;   CANConfig.CAN_ABOM&nbsp;=&nbsp;0;//禁止自动离线&nbsp;&nbsp;   CANConfig.CAN_NART&nbsp;=&nbsp;1;//禁止报文重传&nbsp;&nbsp;   CANConfig.CAN_RFLM&nbsp;=&nbsp;0;//FIFO满之后覆盖旧报文&nbsp;&nbsp;   CANConfig.CAN_TXFP&nbsp;=&nbsp;1;//发送请求决定发送顺序&nbsp;&nbsp;   //配置波特率,波特率&nbsp;=&nbsp;100M/(BRP*(SJW+BS1+BS2))&nbsp;&nbsp;   CANConfig.CAN_BRP&nbsp;=&nbsp;25;&nbsp;&nbsp;   CANConfig.CAN_BS1&nbsp;=&nbsp;2;&nbsp;&nbsp;   CANConfig.CAN_BS2&nbsp;=&nbsp;1;&nbsp;&nbsp;   CANConfig.CAN_SJW&nbsp;=&nbsp;1;&nbsp;&nbsp;   ret&nbsp;=&nbsp;CAN_Init(DevHandle,CANIndex,&amp;CANConfig);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;CAN_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;CAN&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;CAN&nbsp;Success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCAN_Filter_Init\n\r\n\r描述：\n\r\n\r配置CAN总线接收过滤器，注意，初始化配置CAN后，所有过滤器都使能并接收所有数据，若要使能数据过滤功能，应该调用此函数配置每一个过滤器。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_Filter_Init(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;PCAN_FILTER_CONFIG&nbsp;pFilterConfig);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rpFilterConfig CAN控制器初始化配置参数结构体指针，结构体成员取值说明见概述。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2can.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;CANIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;   CAN_FILTER_CONFIG&nbsp;CANFilter;&nbsp;&nbsp;   CANFilter.FilterIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   CANFilter.Enable&nbsp;=&nbsp;1;&nbsp;&nbsp;   CANFilter.ExtFrame&nbsp;=&nbsp;1;&nbsp;&nbsp;//需要过滤接收的帧为扩展帧&nbsp;&nbsp;   CANFilter.FilterMode&nbsp;=&nbsp;0;//屏蔽位模式&nbsp;&nbsp;   CANFilter.MASK_IDE&nbsp;=&nbsp;1;&nbsp;//需要对比接收到的数据IDE位，若跟CANFilter.ID_IDE设置值一致则过滤通过&nbsp;&nbsp;   CANFilter.MASK_RTR&nbsp;=&nbsp;0;//无需对比接收到的数据RTR位&nbsp;&nbsp;   CANFilter.MASK_Std_Ext&nbsp;=&nbsp;0x0F;//需要对比接收到的ID低4位，且低4位跟CANFilter.ID_Std_Ext低4位相同则过滤通过&nbsp;&nbsp;   CANFilter.ID_IDE&nbsp;=&nbsp;1;&nbsp;&nbsp;   CANFilter.ID_RTR&nbsp;=&nbsp;0;&nbsp;&nbsp;   CANFilter.ID_Std_Ext&nbsp;=&nbsp;0x05;&nbsp;&nbsp;   CAN_Filter_Init(DevHandle,CANIndex,&amp;CANFilter);&nbsp;&nbsp;   &nbsp;&nbsp;   CANFilter.FilterIndex&nbsp;=&nbsp;1;&nbsp;&nbsp;   CANFilter.Enable&nbsp;=&nbsp;1;&nbsp;&nbsp;   CANFilter.ExtFrame&nbsp;=&nbsp;1;&nbsp;&nbsp;//需要过滤接收的帧为扩展帧&nbsp;&nbsp;   CANFilter.FilterMode&nbsp;=&nbsp;1;//标识符列表模式&nbsp;&nbsp;   CANFilter.ID_IDE&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//接收到的数据帧IDE必须为1，也就是必须为扩展帧数据&nbsp;&nbsp;   CANFilter.ID_RTR&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//接收到的帧类型必须为数据帧&nbsp;&nbsp;   CANFilter.ID_Std_Ext&nbsp;=&nbsp;0x12A;//接收到的帧ID必须等于CANFilter.ID_Std_Ext设置的值&nbsp;&nbsp;   CAN_Filter_Init(DevHandle,CANIndex,&amp;CANFilter);&nbsp;&nbsp;\n\rCAN_StartGetMsg\n\r\n\r描述：\n\r\n\r开始接收数据，调用该函数后，会启动数据接收线程，通过调用CAN_StopGetMsg函数可以停止接收数据线程，数据可以通过调用CAN_GetMsg函数获取。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_StartGetMsg(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：CAN_StopGetMsg\n\r\n\r描述：\n\r\n\r开始接收数据后，调用该函数，会停止数据接收线程。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_StopGetMsg(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：CAN_SendMsg\n\r\n\r描述：\n\r\n\r向CAN总线发送CAN消息。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_SendMsg(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;PCAN_MSG&nbsp;pCanSendMsg,unsigned&nbsp;int&nbsp;SendMsgNum);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rpCanSendMsg CAN消息存储缓冲区首地址。\n\r\n\rSendMsgNum 即将向CAN总线发送的CAN消息帧数。\n\r\n\r返回值：\n\r\n\r大于等于0表示成功发送的消息帧数，若小于0则该函数调用失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2can.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;CANIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   //CAN帧数组&nbsp;&nbsp;   CAN_MSG&nbsp;CanMsg[5];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;5;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].ExternFlag&nbsp;=&nbsp;0;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].RemoteFlag&nbsp;=&nbsp;0;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].ID&nbsp;=&nbsp;i;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].DataLen&nbsp;=&nbsp;8;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;CanMsg[i].DataLen;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].Data[j]&nbsp;=&nbsp;j;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;   int&nbsp;SendedNum&nbsp;=&nbsp;CAN_SendMsg(DevHandle,CANIndex,CanMsg,5);&nbsp;&nbsp;   if(SendedNum&nbsp;&gt;=&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Success&nbsp;send&nbsp;frames:%d\\n\",SendedNum);&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Send&nbsp;CAN&nbsp;data&nbsp;failed!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCAN_GetMsg \n\r\n\r描述：\n\r\n\r从USB2CAN适配器获取已经接收到的CAN消息。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_GetMsg(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;PCAN_MSG&nbsp;pCanGetMsg);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rpCanGetMsg 存储CAN消息缓冲区首地址,注意，为保证接收的数据不会溢出缓冲区，缓冲区大小设置最小为2048帧较为合适。\n\r\n\r返回值：\n\r\n\r大于等于0表示从CAN适配器内部成功读取到的CAN消息帧数，若返回值小于0则说明调用该函数失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2can.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;CANIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   //CAN消息帧存储缓冲区&nbsp;&nbsp;   CAN_MSG&nbsp;CanMsgBuffer[10240];&nbsp;&nbsp;   int&nbsp;CanNum&nbsp;=&nbsp;CAN_GetMsg(DevHandle,CANIndex,CanMsgBuffer);&nbsp;&nbsp;   if(CanNum&nbsp;&gt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"CanNum&nbsp;=&nbsp;%d\\n\",CanNum);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;CanNum;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"CanMsg[%d].ID&nbsp;=&nbsp;%d\\n\",i,CanMsgBuffer[i].ID);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"CanMsg[%d].TimeStamp&nbsp;=&nbsp;%d\\n\",i,CanMsgBuffer[i].TimeStamp);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"CanMsg[%d].Data&nbsp;=&nbsp;\",i);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;CanMsgBuffer[i].DataLen;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",CanMsgBuffer[i].Data[j]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }else&nbsp;if(CanNum&nbsp;==&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"No&nbsp;CAN&nbsp;data!\\n\");&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Get&nbsp;CAN&nbsp;data&nbsp;error!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCAN_GetMsgWithSize\n\r\n\r描述：\n\r\n\r读取接收到的CAN消息，推荐使用该函数。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_GetMsgWithSize(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;CAN_MSG&nbsp;*pCanGetMsg,int&nbsp;BufferSize);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\rpCanGetMsg 存储CAN消息缓冲区首地址。\n\r\n\rBufferSize 存储CAN消息缓冲区大小。\n\r\n\r返回值：\n\r\n\r大于等于0表示从CAN适配器内部成功读取到的CAN消息帧数，若返回值小于0则说明调用该函数失败。\n\r\n\r示例：\n\r  CAN_ClearMsg\n\r\n\r描述：\n\r\n\r清除已经接收到的所有数据。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_ClearMsg(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：CAN_GetStatus\n\r\n\r描述：\n\r\n\r获取CAN控制器相关状态数据。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_GetStatus(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;PCAN_STATUS&nbsp;pCANStatus);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rpCANStatus CAN控制状态结构体变量指针。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2can.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;CANIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   CAN_STATUS&nbsp;CANStatus;&nbsp;&nbsp;   ret&nbsp;=&nbsp;CAN_GetStatus(DevHandle,CANIndex,&amp;CANStatus);&nbsp;&nbsp;   if(ret&nbsp;==&nbsp;CAN_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"CANStatus.RECounter&nbsp;=&nbsp;%d\\n\",CANStatus.RECounter);//接收错误计数器&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"CANStatus.TECounter&nbsp;=&nbsp;%d\\n\",CANStatus.TECounter);//发送错误计数器&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Get&nbsp;CAN&nbsp;status&nbsp;error!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCAN_SetSchedule\n\r\n\r描述：\n\r\n\r配置CAN调度表数据，该数据是放到适配器内部，被适配器内部调度表定时器调度运行，其帧发送间隔时间精度更高，一般误差在1ms以内。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CAN_SetSchedule(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;PCAN_MSG&nbsp;pCanMsgTab,unsigned&nbsp;char&nbsp;*pMsgNum,unsigned&nbsp;short&nbsp;*pSendTimes,unsigned&nbsp;char&nbsp;MsgTabNum);&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，可以设置为0或者1。\n\r\n\rpCanMsgTab CAN调度表数据指针。\n\r\n\rpMsgNum 每个调度表里面包含有效帧数指针。\n\r\n\rpSendTimes 每个调度表里面帧发送次数，若为0xFFFF，则循环发送，通过调用CAN_StopSchedule函数停止发送。\n\r\n\rMsgTabNum 调度表数量。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  //准备CAN调度表数据&nbsp;&nbsp;   const&nbsp;int&nbsp;MsgNum&nbsp;=&nbsp;20;&nbsp;&nbsp;   CAN_MSG&nbsp;CanMsg[MsgNum];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;MsgNum;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].ExternFlag&nbsp;=&nbsp;0;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].RemoteFlag&nbsp;=&nbsp;0;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].ID&nbsp;=&nbsp;i+1;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].DataLen&nbsp;=&nbsp;8;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].TimeStamp&nbsp;=&nbsp;20;//帧周期为20ms，必须设置&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;CanMsg[i].DataLen;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].Data[j]&nbsp;=&nbsp;j;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].Data[0]&nbsp;=&nbsp;i+1;&nbsp;&nbsp;   }&nbsp;&nbsp;   //总共3个调度表，第一个表里面包含3帧数据，第二个调度表包含6帧数据，第三个调度表包含11帧数据&nbsp;&nbsp;   uint8_t&nbsp;MsgTabNum[3]={3,6,11};&nbsp;&nbsp;   //第一个调度表循环发送数据，第二个调度表循环发送数据，第三个调度表只发送3次&nbsp;&nbsp;   uint16_t&nbsp;SendTimes[3]={0xFFFF,0xFFFF,3};&nbsp;&nbsp;   ret&nbsp;=&nbsp;CAN_SetSchedule(DevHandle[0],0,CanMsg,MsgTabNum,SendTimes,3);&nbsp;&nbsp;   if(ret&nbsp;==&nbsp;CAN_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Set&nbsp;CAN&nbsp;Schedule&nbsp;Success\\n\");&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Set&nbsp;CAN&nbsp;Schedule&nbsp;Error&nbsp;ret&nbsp;=&nbsp;%d\\n\",&nbsp;ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCAN_StartSchedule \n\r\n\r描述：\n\r\n\r启动CAN调度表，开始发送CAN数据，每次只能启动一个调度表，在启动新的调度表之前，需要把已经启动的调度表停止。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_StartSchedule(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;unsigned&nbsp;char&nbsp;MsgTabIndex,unsigned&nbsp;char&nbsp;TimePrecMs,unsigned&nbsp;char&nbsp;OrderSend);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rMsgTabIndex 调度表索引号，该索引号不能大于调度表数量。\n\r\n\rTimePrecMs 调度表执行定时参数，比如调度表中，帧周期最小为10ms，那么此处可以设置为10，该值不能设置小于5.OrderSend 0-调度表里面数据并行发送，1-调度表里面数据顺序发送。 \n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  ret&nbsp;=&nbsp;CAN_StartSchedule(DevHandle[0],SendCANIndex,0,10,0);//启动第一个调度表&nbsp;&nbsp;   if(ret&nbsp;==&nbsp;CAN_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;CAN&nbsp;Schedule&nbsp;1&nbsp;Success\\n\");&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;CAN&nbsp;Schedule&nbsp;1&nbsp;Error&nbsp;ret&nbsp;=&nbsp;%d\\n\",&nbsp;ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCAN_StopSchedule&nbsp;\n\r\n\r描述：\n\r\n\r停止已经启动的调度表。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_StopSchedule(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，可以设置为0或者1。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。CAN_BL_Init\n\r\n\r描述：\n\r\n\rCAN-Bootloader初始化配置，主要是初始化CAN控制器，配置CAN总线波特率，配置CAN-Bootloader命令列表。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_BL_Init(int&nbsp;DevHandle,int&nbsp;CANIndex,PCAN_INIT_CONFIG&nbsp;pInitConfig,PCBL_CMD_LIST&nbsp;pCmdList);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rpInitConfig CAN控制器初始化配置参数结构体指针，结构体成员取值说明见概述。\n\r\n\rpCmdList CAN-Bootloader命令列表变量指针。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2can.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   CBL_CMD_LIST&nbsp;CMD_List;&nbsp;&nbsp;   CMD_List.Erase&nbsp;=&nbsp;0x00;&nbsp;&nbsp;   CMD_List.WriteInfo&nbsp;=&nbsp;0x01;&nbsp;&nbsp;   CMD_List.Write&nbsp;=&nbsp;0x02;&nbsp;&nbsp;   CMD_List.Check&nbsp;=&nbsp;0x03;&nbsp;&nbsp;   CMD_List.SetBaudRate&nbsp;=&nbsp;0x04;&nbsp;&nbsp;   CMD_List.Excute&nbsp;=&nbsp;0x05;&nbsp;&nbsp;   CMD_List.CmdSuccess&nbsp;=&nbsp;0x08;&nbsp;&nbsp;   CMD_List.CmdFaild&nbsp;=&nbsp;0x09;&nbsp;&nbsp;   CAN_INIT_CONFIG&nbsp;CAN_InitConfig;&nbsp;&nbsp;   //波特率配置为1M&nbsp;&nbsp;   CAN_INIT_CONFIG&nbsp;CAN_InitConfig;&nbsp;&nbsp;   CAN_InitConfig.CAN_BRP&nbsp;=&nbsp;2;&nbsp;&nbsp;   CAN_InitConfig.CAN_SJW&nbsp;=&nbsp;1;&nbsp;&nbsp;   CAN_InitConfig.CAN_BS1&nbsp;=&nbsp;15;&nbsp;&nbsp;   CAN_InitConfig.CAN_BS2&nbsp;=&nbsp;5;&nbsp;&nbsp;   //使能接入内部终端电阻&nbsp;&nbsp;   CAN_InitConfig.CAN_Mode&nbsp;|=&nbsp;0x80;&nbsp;&nbsp;   int&nbsp;bret&nbsp;=&nbsp;CAN_BL_Init(DeviceHandle,0,&amp;CAN_InitConfig,&amp;CMD_List);&nbsp;&nbsp;   if(ret!=CAN_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Init&nbsp;device&nbsp;error!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCAN_BL_NodeCheck\n\r\n\r描述：\n\r\n\r检测指定地址的节点当前是否在线。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_BL_NodeCheck(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;short&nbsp;NodeAddr,unsigned&nbsp;int&nbsp;*pVersion,unsigned&nbsp;int&nbsp;*pType,unsigned&nbsp;int&nbsp;TimeOut);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rNodeAddr 节点地址，该地址存储在CAN ID的非命令存储区域。\n\r\n\rpVersion 指定节点接收到命令后返回的固件版本号。\n\r\n\rpType 指定节点接收到命令后返回的固件类型。\n\r\n\rTimeOut 等待指定节点返回固件信息的超时时间，单位为毫秒。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2can.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   unsigned&nbsp;short&nbsp;NodeAddr=0x123;&nbsp;&nbsp;   unsigned&nbsp;int&nbsp;appversion;&nbsp;&nbsp;   unsigned&nbsp;int&nbsp;appType;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   ret&nbsp;=&nbsp;CAN_BL_NodeCheck(DeviceHandle,0,NodeAddr,&amp;appversion,&amp;appType,500);&nbsp;&nbsp;   if(ret&nbsp;==&nbsp;CAN_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if(appType&nbsp;==&nbsp;CAN_BL_BOOT){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"当前固件类型为Bootloader\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(appType&nbsp;==&nbsp;CAN_BL_APP){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"当前固件类型为App\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"当前节点无响应，可能不存在这个地址的节点！\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCAN_BL_Erase\n\r\n\r描述：\n\r\n\r擦除即将进行固件烧录区域中的数据。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_BL_Erase(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;short&nbsp;NodeAddr,unsigned&nbsp;int&nbsp;FlashSize,unsigned&nbsp;int&nbsp;TimeOut);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rNodeAddr 节点地址，该地址存储在CAN ID的非命令存储区域。\n\r\n\rFlashSize 准备擦除的Flash区域大小，单位为字节。\n\r\n\rTimeOut 等待节点返回命令执行状态的超时时间，单位为毫秒。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2can.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   unsigned&nbsp;short&nbsp;NodeAddr=0x123;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;FlashSize&nbsp;=&nbsp;10*1024;&nbsp;&nbsp;   ret&nbsp;=&nbsp;CAN_BL_Erase(DeviceHandle,0,NodeAddr,FlashSize&nbsp;,500);&nbsp;&nbsp;   if(ret&nbsp;==&nbsp;CAN_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"擦除固件成功！\\n\");&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"擦除固件失败！\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCAN_BL_Write\n\r\n\r描述：\n\r\n\r通过CAN总线发送固件二进制数据，进入升级模式的节点接收到数据后应该将数据写入指定地址的Flash区域。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_BL_Write(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;short&nbsp;NodeAddr,unsigned&nbsp;int&nbsp;AddrOffset,unsigned&nbsp;char&nbsp;*pData,unsigned&nbsp;int&nbsp;DataNum,unsigned&nbsp;int&nbsp;TimeOut);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rNodeAddr 节点地址，该地址存储在CAN ID的非命令存储区域。\n\r\n\rAddrOffset 写入数据的偏移地址，也就是bin文件的偏移地址。\n\r\n\rpData 即将发送的数据缓冲区指针。\n\r\n\rDataNum 即将发送的数据字节数。\n\r\n\rTimeOut 等待节点返回命令执行状态的超时时间，单位为毫秒。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2can.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   unsigned&nbsp;short&nbsp;NodeAddr=0x123;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;DataBuffer[1024];//先将固件文件中的数据读取到这个缓冲区中&nbsp;&nbsp;   &nbsp;&nbsp;   ret&nbsp;=&nbsp;CAN_BL_Write(DeviceHandle,0,NodeAddr,0&nbsp;,DataBuffer,1024,500);&nbsp;&nbsp;   if(ret&nbsp;==&nbsp;CAN_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"写固件数据成功！\\n\");&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"写固件数据失败！\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCAN_BL_Excute\n\r\n\r描述：\n\r\n\r执行Bootloader或者App程序。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_BL_Excute(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;short&nbsp;NodeAddr,unsigned&nbsp;int&nbsp;Type);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rNodeAddr 节点地址，该地址存储在CAN ID的非命令存储区域。\n\r\n\rType 准备执行的固件类型。CAN_BL_BOOT-不管当前是什么固件，必须执行Bootloader固件，CAN_BL_APP-不管当前是什么固件，立即执行App固件。\n\r\n\rTimeOut 等待节点返回命令执行状态的超时时间，单位为毫秒。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2can.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   unsigned&nbsp;short&nbsp;NodeAddr=0x123;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;   ret&nbsp;=&nbsp;CAN_BL_Excute(DeviceHandle,0,NodeAddr,CAN_BL_APP,500);&nbsp;&nbsp;   if(ret&nbsp;==&nbsp;CAN_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"跳转到APP成功！\\n\");&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"跳转到APP失败！\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCAN_BL_SetNewBaudRate \n\r\n\r描述：\n\r\n\r设置指定节点的CAN总线波特率。节点收到此命令后应尽快更改当前波特率，然后以新的波特率返回命令状态。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CAN_BL_SetNewBaudRate(int&nbsp;DevHandle,int&nbsp;CANIndex,unsigned&nbsp;short&nbsp;NodeAddr,PCAN_INIT_CONFIG&nbsp;pInitConfig,unsigned&nbsp;int&nbsp;NewBaudRate,unsigned&nbsp;int&nbsp;TimeOut);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，USB2XXX只能设置为0，USB2CAN/LIN适配器可以设置为0或者1。\n\r\n\rNodeAddr 节点地址，该地址存储在CAN ID的非命令存储区域。\n\r\n\rpInitConfig 新波特率对应的参数，设置节点新波特率后，为保证CAN适配器能正常接收到节点返回的命令，需要重新进行初始化配置，其主要是需要配置CAN总线波特率参数。\n\r\n\rNewBaudRate 新波特率，单位为bps。\n\r\n\rTimeOut 等待节点返回命令执行状态的超时时间，单位为毫秒。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2can.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   unsigned&nbsp;short&nbsp;NodeAddr=0x123;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   //波特率配置为500K&nbsp;&nbsp;&nbsp;&nbsp;   CAN_INIT_CONFIG&nbsp;CAN_InitConfig;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   CAN_InitConfig.CAN_BRP&nbsp;=&nbsp;4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   CAN_InitConfig.CAN_SJW&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   CAN_InitConfig.CAN_BS1&nbsp;=&nbsp;16;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   CAN_InitConfig.CAN_BS2&nbsp;=&nbsp;4;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;   ret&nbsp;=&nbsp;CAN_BL_SetNewBaudRate(DeviceHandle,0,NodeAddr,&amp;CAN_InitConfig,500000,500);&nbsp;&nbsp;   if(ret&nbsp;==&nbsp;CAN_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"设置新波特率成功！\\n\");&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"设置新波特率失败！\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\r","usb2can","topics\\函数说明/usb2can.htm"," Help &gt; 函数说明 &gt; usb2canfd目录\n\r    概述    CANFD_Init    CANFD_SetFilter    CANFD_StartGetMsg    CANFD_StopGetMsg    CANFD_SendMsg    CANFD_GetMsg       CANFD_GetDiagnostic    CANFD_GetBusError\n\r    CANFD_SetSchedule\n\r    CANFD_StartSchedule\n\r    CANFD_StopSchedule\n\r概述 \n\r\n\rUTA0503才支持CANFD功能，若需要使用CANFD功能，请注意使用适配器的型号。该版本的适配器同时支持发送CAN2.0A/B数据。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //函数返回值错误信息定义&nbsp;&nbsp;   #define&nbsp;CANFD_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;   #define&nbsp;CANFD_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;   #define&nbsp;CANFD_ERR_USB_WRITE_FAIL&nbsp;&nbsp;(-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;   #define&nbsp;CANFD_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;(-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;   #define&nbsp;CANFD_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;   //CANFD_MSG.ID定义&nbsp;&nbsp;   #define&nbsp;CANFD_MSG_FLAG_RTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;30)&nbsp;&nbsp;   #define&nbsp;CANFD_MSG_FLAG_IDE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;31)&nbsp;&nbsp;   #define&nbsp;CANFD_MSG_FLAG_ID_MASK&nbsp;&nbsp;(0x1FFFFFFF)&nbsp;&nbsp;   //CANFD_MSG.Flags定义&nbsp;&nbsp;   #define&nbsp;CANFD_MSG_FLAG_BRS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;0)&nbsp;&nbsp;   #define&nbsp;CANFD_MSG_FLAG_ESI&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;1)&nbsp;&nbsp;   #define&nbsp;CANFD_MSG_FLAG_FDF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;2)&nbsp;&nbsp;   #define&nbsp;CANFD_MSG_FLAG_RXD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;7)&nbsp;&nbsp;   //CANFD_DIAGNOSTIC.Flags定义&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_NBIT0_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x0001)//在发送报文（或应答位、主动错误标志或过载标志）期间，器件要发送显性电平（逻辑值为0的数据或标识符位），但监视的总线值为隐性。&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_NBIT1_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x0002)//在发送报文（仲裁字段除外）期间，器件要发送隐性电平（逻辑值为1的位），但监视到的总线值为显性。&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_NACK_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x0004)//发送报文未应答。&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_NFORM_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x0008)//接收报文的固定格式部分格式错误。&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_NSTUFF_ERR&nbsp;&nbsp;&nbsp;&nbsp;(0x0010)//在接收报文的一部分中，序列中包含了5个以上相等位，而报文中不允许出现这种序列。&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_NCRC_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x0020)//接收的报文的CRC校验和不正确。输入报文的CRC与通过接收到的数据计算得到的CRC不匹配。&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_TXBO_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x0080)//器件进入离线状态（且自动恢复）。&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_DBIT0_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x0100)//见NBIT0_ERR&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_DBIT1_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x0200)//见NBIT1_ERR&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_DFORM_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x0800)//见NFORM_ERR&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_DSTUFF_ERR&nbsp;&nbsp;&nbsp;&nbsp;(0x1000)//见NSTUFF_ERR&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_DCRC_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x2000)//见NCRC_ERR&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_ESI_ERR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x4000)//接收的CAN&nbsp;FD报文的ESI标志置1&nbsp;&nbsp;   #define&nbsp;CANFD_DIAGNOSTIC_FLAG_DLC_MISMATCH&nbsp;&nbsp;(0x8000)//DLC不匹配,在发送或接收期间，指定的DLC大于FIFO元素的PLSIZE&nbsp;&nbsp;   //CANFD_BUS_ERROR.Flags定义&nbsp;&nbsp;   #define&nbsp;CANFD_BUS_ERROR_FLAG_TX_RX_WARNING&nbsp;&nbsp;&nbsp;(0x01)&nbsp;&nbsp;   #define&nbsp;CANFD_BUS_ERROR_FLAG_RX_WARNING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x02)&nbsp;&nbsp;   #define&nbsp;CANFD_BUS_ERROR_FLAG_TX_WARNING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x04)&nbsp;&nbsp;   #define&nbsp;CANFD_BUS_ERROR_FLAG_RX_BUS_PASSIVE&nbsp;&nbsp;(0x08)&nbsp;&nbsp;   #define&nbsp;CANFD_BUS_ERROR_FLAG_TX_BUS_PASSIVE&nbsp;&nbsp;(0x10)&nbsp;&nbsp;   #define&nbsp;CANFD_BUS_ERROR_FLAG_TX_BUS_OFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x20)&nbsp;&nbsp;   //1.CANFD信息帧的数据类型定义&nbsp;&nbsp;   typedef&nbsp;&nbsp;struct&nbsp;&nbsp;_CANFD_MSG&nbsp;&nbsp;   {&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//报文ID,bit[30]-RTR,bit[31]-IDE,bit[28..0]-ID&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;DLC;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数据字节长度，可设置为-0,1,2,3,4,5,6,7,8,12,16,20,24,32,48,64&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Flags;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//bit[0]-BRS,bit[1]-ESI,bit[2]-FDF,bit[6..5]-Channel,bit[7]-RXD&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;__Res0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//保留&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;__Res1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//保留&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;TimeStamp;&nbsp;&nbsp;&nbsp;&nbsp;//帧接收或者发送时的时间戳，单位为10us&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Data[64];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//报文的数据。&nbsp;&nbsp;   }CANFD_MSG;&nbsp;&nbsp;   &nbsp;&nbsp;   //2.CANFD初始化配置数据类型定义&nbsp;&nbsp;   typedef&nbsp;&nbsp;struct&nbsp;&nbsp;_CANFD_INIT_CONFIG&nbsp;&nbsp;   {&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;Mode;&nbsp;//0-正常模式，1-自发自收模式&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;ISOCRCEnable;//0-禁止ISO&nbsp;CRC,1-使能ISO&nbsp;CRC&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;RetrySend;//0-禁止重发，1-无限制重发&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;ResEnable;//0-不接入内部120欧终端电阻，1-接入内部120欧终端电阻&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//波特率参数可以用TCANLINPro软件里面的波特率计算工具计算&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//仲裁段波特率参数,波特率=40M/NBT_BRP*(1+NBT_SEG1+NBT_SEG2)&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;NBT_BRP;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;NBT_SEG1;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;NBT_SEG2;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;NBT_SJW;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//数据段波特率参数,波特率=40M/DBT_BRP*(1+DBT_SEG1+DBT_SEG2)&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;DBT_BRP;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;DBT_SEG1;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;DBT_SEG2;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;DBT_SJW;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;__Res0[8];&nbsp;&nbsp;   }CANFD_INIT_CONFIG;&nbsp;&nbsp;   //3.CANFD诊断帧信息结构体定义&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_CANFD_DIAGNOSTIC&nbsp;{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;NREC;//标称比特率接收错误计数&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;NTEC;//标称比特率发送错误计数&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;DREC;//数据比特率接收错误计数&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;DTEC;//数据比特率发送错误计数&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;ErrorFreeMsgCount;//无错误帧计数&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;Flags;//参考诊断标志定义&nbsp;&nbsp;   }CANFD_DIAGNOSTIC;&nbsp;&nbsp;   //4.CANFD总线错误信息结构体定义&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_CANFD_BUS_ERROR&nbsp;{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;TEC;//发送错误计数&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;REC;//接收错误计数&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;Flags;//参考总线错误标志定义&nbsp;&nbsp;   }CANFD_BUS_ERROR;&nbsp;&nbsp;   //5.CAN&nbsp;滤波器设置数据类型定义&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_CANFD_FILTER_CONFIG{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Enable;&nbsp;&nbsp;&nbsp;//使能该过滤器，1-使能，0-禁止&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Index;&nbsp;&nbsp;&nbsp;&nbsp;//过滤器索引号，取值范围为0到31&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ID_Accept;//验收码ID,bit[28..0]为有效ID位，bit[31]为IDE&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ID_Mask;&nbsp;&nbsp;//屏蔽码，对应bit位若为1，则需要对比对应验收码bit位，相同才接收&nbsp;&nbsp;   }CANFD_FILTER_CONFIG;&nbsp;\n\rUSB2CANFD 波特率表：              \n\r\n\r波特率值(Kbps)          \n\r\n\rSJW          \n\r\n\rBS1          \n\r\n\rBS2          \n\r\n\rBRP            \n\r\n\r10000          \n\r\n\r1          \n\r\n\r2          \n\r\n\r1          \n\r\n\r1            \n\r\n\r8000          \n\r\n\r1          \n\r\n\r3          \n\r\n\r1          \n\r\n\r1            \n\r\n\r6700          \n\r\n\r1          \n\r\n\r4          \n\r\n\r1          \n\r\n\r1            \n\r\n\r5000          \n\r\n\r2          \n\r\n\r5          \n\r\n\r2          \n\r\n\r1            \n\r\n\r4000          \n\r\n\r2          \n\r\n\r7          \n\r\n\r2          \n\r\n\r1            \n\r\n\r3000          \n\r\n\r3          \n\r\n\r9          \n\r\n\r3          \n\r\n\r1            \n\r\n\r2000          \n\r\n\r4          \n\r\n\r15          \n\r\n\r4          \n\r\n\r1            \n\r\n\r1500          \n\r\n\r6          \n\r\n\r19          \n\r\n\r6          \n\r\n\r1            \n\r\n\r1000          \n\r\n\r8          \n\r\n\r31          \n\r\n\r8          \n\r\n\r1            \n\r\n\r500          \n\r\n\r16          \n\r\n\r63          \n\r\n\r16          \n\r\n\r1            \n\r\n\r250          \n\r\n\r32          \n\r\n\r127          \n\r\n\r32          \n\r\n\r1            \n\r\n\r200          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r25            \n\r\n\r150          \n\r\n\r1          \n\r\n\r233          \n\r\n\r33          \n\r\n\r1            \n\r\n\r125          \n\r\n\r64          \n\r\n\r255          \n\r\n\r64          \n\r\n\r1            \n\r\n\r100          \n\r\n\r1          \n\r\n\r7          \n\r\n\r2          \n\r\n\r40            \n\r\n\r83          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r60            \n\r\n\r50          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r100            \n\r\n\r33          \n\r\n\r1          \n\r\n\r6          \n\r\n\r1          \n\r\n\r150            \n\r\n\r10          \n\r\n\r1          \n\r\n\r13          \n\r\n\r2          \n\r\n\r249      \n\r\n\r    \n\r\n\r    \n\r\n\r    \n\r\n\r    \n\r\n\r    \n\r\n\r    \n\r\n\r\n\r\n\r\n\r\n\r波特率 = 40MHz/(BRP*(SJW+BS1+BS2))CANFD_Init\n\r\n\r描述：\n\r\n\r初始化配置USB2CANFD适配器，主要是初始化配置CAN控制器，配置CAN总线波特率。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CANFD_Init(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;CANFD_INIT_CONFIG&nbsp;*pCanConfig);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\rpCanConfig CAN控制器初始化配置参数结构体指针，结构体成员取值说明见概述。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CANFD_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  //初始化配置CAN&nbsp;&nbsp;   CANFD_INIT_CONFIG&nbsp;CANFDConfig;&nbsp;&nbsp;   CANFDConfig.Mode&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//0-正常模式，1-自发自收模式&nbsp;&nbsp;   CANFDConfig.RetrySend&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;//使能自动重传&nbsp;&nbsp;   CANFDConfig.ISOCRCEnable&nbsp;=&nbsp;1;//使能ISOCRC&nbsp;&nbsp;   CANFDConfig.ResEnable&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;//使能内部终端电阻（若总线上没有终端电阻，则必须使能终端电阻才能正常传输数据）&nbsp;&nbsp;   //波特率参数可以用TCANLINPro软件里面的波特率计算工具计算&nbsp;&nbsp;   //仲裁段波特率参数,波特率=40M/NBT_BRP*(1+NBT_SEG1+NBT_SEG2)&nbsp;&nbsp;   CANFDConfig.NBT_BRP&nbsp;=&nbsp;1;&nbsp;&nbsp;   CANFDConfig.NBT_SEG1&nbsp;=&nbsp;63;&nbsp;&nbsp;   CANFDConfig.NBT_SEG2&nbsp;=&nbsp;16;&nbsp;&nbsp;   CANFDConfig.NBT_SJW&nbsp;=&nbsp;16;&nbsp;&nbsp;   //数据域波特率参数,波特率=40M/DBT_BRP*(1+DBT_SEG1+DBT_SEG2)&nbsp;&nbsp;   CANFDConfig.DBT_BRP&nbsp;=&nbsp;1;&nbsp;&nbsp;   CANFDConfig.DBT_SEG1&nbsp;=&nbsp;15;&nbsp;&nbsp;   CANFDConfig.DBT_SEG2&nbsp;=&nbsp;4;&nbsp;&nbsp;   CANFDConfig.DBT_SJW&nbsp;=&nbsp;4;&nbsp;&nbsp;   ret&nbsp;=&nbsp;CANFD_Init(DevHandle[0],CANIndex,&amp;CANFDConfig);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;CANFD_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"CANFD&nbsp;Init&nbsp;Error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"CANFD&nbsp;Init&nbsp;Success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCANFD_SetFilter\n\r\n\r描述：\n\r\n\r配置CAN总线接收过滤器。注意，初始化配置CAN后，所有过滤器都使能并接收所有数据，若要使能数据过滤功能，应该调用此函数配置每一个过滤器。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CANFD_SetFilter(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;CANFD_FILTER_CONFIG&nbsp;*pCanFilter,unsigned&nbsp;char&nbsp;Len);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\rpCanFilter CAN控制器初始化配置参数结构体指针，结构体成员取值说明见概述。\n\r\n\rLen 待配置的过滤器个数。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CANFD_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  //配置过滤器，若不配置过滤器，默认是接收所有数据&nbsp;&nbsp;   CANFD_FILTER_CONFIG&nbsp;CANFDFilter;&nbsp;&nbsp;   CANFDFilter.Index&nbsp;=&nbsp;0;//取值范围为：0~31&nbsp;&nbsp;   CANFDFilter.Enable&nbsp;=&nbsp;1;//0-禁止，1-使能&nbsp;&nbsp;   //配置为只接收扩展帧数据&nbsp;&nbsp;   CANFDFilter.ID_Accept&nbsp;=&nbsp;0x80000000;&nbsp;&nbsp;   CANFDFilter.ID_Mask&nbsp;=&nbsp;0x80000000;&nbsp;&nbsp;   ret&nbsp;=&nbsp;CANFD_SetFilter(DevHandle[0],&nbsp;CANIndex,&nbsp;&amp;CANFDFilter,&nbsp;1);&nbsp;&nbsp;   if&nbsp;(ret&nbsp;!=&nbsp;CANFD_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;filter&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;filter&nbsp;success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCANFD_StartGetMsg\n\r\n\r描述：\n\r\n\r开始接收数据，调用该函数后，会启动数据接收线程，通过调用CANFD_StopGetMsg函数可以停止接收数据线程，数据可以通过调用CANFD_GetMsg函数获取。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CANFD_StartGetMsg(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CANFD_SUCCESS表示成功，否则为失败。\n\r\n\r示例：CANFD_StopGetMsg\n\r\n\r描述：\n\r\n\r开始接收数据后，调用该函数，会停止数据接收线程。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CANFD_StopGetMsg(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CANFD_SUCCESS表示成功，否则为失败。\n\r\n\r示例：CANFD_SendMsg\n\r\n\r描述：\n\r\n\r向CAN总线发送CAN消息。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CANFD_SendMsg(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;CANFD_MSG&nbsp;*pCanSendMsg,unsigned&nbsp;int&nbsp;SendMsgNum);&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\rpCanSendMsg CAN消息存储缓冲区首地址。\n\r\n\rSendMsgNum 即将向CAN总线发送的CAN消息帧数。\n\r\n\r返回值：\n\r\n\r大于等于0表示成功发送的消息帧数，若小于0则该函数调用失败。\n\r\n\r示例：\n\r  //发送CAN数据&nbsp;&nbsp;   CANFD_MSG&nbsp;CanMsg[5];&nbsp;&nbsp;   for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;5;&nbsp;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].Flags&nbsp;=&nbsp;0;//bit[0]-BRS,bit[1]-ESI,bit[2]-FDF,bit[6..5]-Channel,bit[7]-RXD&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].DLC&nbsp;=&nbsp;8;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].ID&nbsp;=&nbsp;i|CANFD_MSG_FLAG_IDE;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;CanMsg[i].DLC;&nbsp;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].Data[j]&nbsp;=&nbsp;j;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;   int&nbsp;SendedMsgNum&nbsp;=&nbsp;CANFD_SendMsg(DevHandle[0],&nbsp;CANIndex,&nbsp;CanMsg,&nbsp;5);&nbsp;&nbsp;   if&nbsp;(SendedMsgNum&nbsp;&gt;=&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Success&nbsp;send&nbsp;frames:%d\\n\",&nbsp;SendedMsgNum);&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Send&nbsp;CAN&nbsp;data&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCANFD_GetMsg \n\r\n\r描述：\n\r\n\r读取接收到的CAN消息。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CANFD_GetMsg(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;CANFD_MSG&nbsp;*pCanGetMsg,int&nbsp;BufferSize);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\rpCanGetMsg 存储CAN消息缓冲区首地址。\n\r\n\rBufferSize 存储CAN消息缓冲区大小。\n\r\n\r返回值：\n\r\n\r大于等于0表示从CAN适配器内部成功读取到的CAN消息帧数，若返回值小于0则说明调用该函数失败。\n\r\n\r示例：\n\r  //读取接收数据缓冲中的数据&nbsp;&nbsp;   CANFD_MSG&nbsp;CanMsgBuffer[1024];&nbsp;&nbsp;   int&nbsp;GetMsgNum&nbsp;=&nbsp;CANFD_GetMsg(DevHandle[0],&nbsp;CANIndex,&nbsp;CanMsgBuffer,&nbsp;1024);&nbsp;&nbsp;   if&nbsp;(GetMsgNum&nbsp;&gt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;GetMsgNum;&nbsp;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"CanMsg[%d].ID&nbsp;=&nbsp;0x%08X\\n\",&nbsp;i,&nbsp;CanMsgBuffer[i].ID&nbsp;&amp;&nbsp;CANFD_MSG_FLAG_ID_MASK);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"CanMsg[%d].TimeStamp&nbsp;=&nbsp;%d\\n\",&nbsp;i,&nbsp;CanMsgBuffer[i].TimeStamp);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"CanMsg[%d].Data&nbsp;=&nbsp;\",&nbsp;i);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;CanMsgBuffer[i].DLC;&nbsp;j++)&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"0x%02X&nbsp;\",&nbsp;CanMsgBuffer[i].Data[j]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }else&nbsp;if&nbsp;(GetMsgNum&nbsp;&lt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Get&nbsp;CAN&nbsp;data&nbsp;error!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCANFD_GetDiagnostic\n\r\n\r描述：\n\r\n\r获取CAN总线错误信息数据。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CANFD_GetDiagnostic(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;CANFD_DIAGNOSTIC&nbsp;*pCanDiagnostic);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\rpCanDiagnostic CAN总线错误数据，具体细节参考概述里面结构体定义说明。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CANFD_SUCCESS表示成功，否则为失败。\n\r\n\r示例：CANFD_GetBusError\n\r\n\r描述：\n\r\n\r获取CAN总线错误信息数据。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CANFD_GetBusError(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;CANFD_BUS_ERROR&nbsp;*pCanBusError);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，0-对应CAN1,1-对应CAN2。\n\r\n\rpCanBusError CAN总线错误数据，具体细节参考概述里面结构体定义说明\n\r\n\r返回值：\n\r\n\r函数执行状态，为CANFD_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r\n\r&nbsp;CANFD_SetSchedule\n\r\n\r描述：\n\r\n\r配置CAN调度表数据，该数据是放到适配器内部，被适配器内部调度表定时器调度运行，其帧发送间隔时间精度更高，一般误差在1ms以内。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;CANFD_SetSchedule(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;CANFD_MSG&nbsp;pCanMsgTab,unsigned&nbsp;char&nbsp;*pMsgNum,unsigned&nbsp;short&nbsp;*pSendTimes,unsigned&nbsp;char&nbsp;MsgTabNum);&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，可以设置为0或者1。\n\r\n\rpCanMsgTab CAN调度表数据指针。\n\r\n\rpMsgNum 每个调度表里面包含有效帧数指针。\n\r\n\rpSendTimes 每个调度表里面帧发送次数，若为0xFFFF，则循环发送，通过调用CAN_StopSchedule函数停止发送。\n\r\n\rMsgTabNum 调度表数量。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  //准备CAN调度表数据&nbsp;&nbsp;\n\r  const&nbsp;int&nbsp;AllMsgNum&nbsp;=&nbsp;20;&nbsp;&nbsp;\n\r  CANFD_MSG&nbsp;CanMsg[AllMsgNum];&nbsp;&nbsp;\n\r  for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;AllMsgNum;&nbsp;i++){&nbsp;&nbsp;\n\r  &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].Flags&nbsp;=&nbsp;0;//bit[0]-BRS,bit[1]-ESI,bit[2]-FDF,bit[6..5]-Channel,bit[7]-RXD&nbsp;&nbsp;\n\r  &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].DLC&nbsp;=&nbsp;8;&nbsp;&nbsp;\n\r  &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].ID&nbsp;=&nbsp;i|CANFD_MSG_FLAG_IDE;&nbsp;&nbsp;\n\r  &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;CanMsg[i].DLC;&nbsp;j++){&nbsp;&nbsp;\n\r  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].Data[j]&nbsp;=&nbsp;j;&nbsp;&nbsp;\n\r  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\n\r  &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].Data[0]&nbsp;=&nbsp;i;&nbsp;&nbsp;\n\r  &nbsp;&nbsp;&nbsp;&nbsp;CanMsg[i].TimeStamp&nbsp;=&nbsp;20;//每帧间隔10ms&nbsp;&nbsp;\n\r  }&nbsp;&nbsp;\n\r  //总共3个调度表，第一个表里面包含3帧数据，第二个调度表包含6帧数据，第三个调度表包含11帧数据&nbsp;&nbsp;\n\r  uint8_t&nbsp;MsgTabNum[3]={3,6,11};&nbsp;&nbsp;\n\r  //第一个调度表循环发送数据，第二个调度表循环发送数据，第三个调度表只发送3次&nbsp;&nbsp;\n\r  uint16_t&nbsp;SendTimes[3]={0xFFFF,0xFFFF,3};&nbsp;&nbsp;\n\r  ret&nbsp;=&nbsp;CANFD_SetSchedule(DevHandle[0],&nbsp;SendCANIndex,CanMsg,MsgTabNum,SendTimes,3);//列表循环发送&nbsp;&nbsp;\n\r  if(ret&nbsp;==&nbsp;CANFD_SUCCESS){&nbsp;&nbsp;\n\r  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Set&nbsp;CAN&nbsp;Schedule&nbsp;Success\\n\");&nbsp;&nbsp;\n\r  }else{&nbsp;&nbsp;\n\r  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Set&nbsp;CAN&nbsp;Schedule&nbsp;Error&nbsp;ret&nbsp;=&nbsp;%d\\n\",&nbsp;ret);&nbsp;&nbsp;\n\r  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;\n\r  }&nbsp;&nbsp;\n\rCANFD_StartSchedule \n\r\n\r描述：\n\r\n\r启动CAN调度表，开始发送CAN数据，每次只能启动一个调度表，在启动新的调度表之前，需要把已经启动的调度表停止。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CANFD_StartSchedule(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex,&nbsp;unsigned&nbsp;char&nbsp;MsgTabIndex,unsigned&nbsp;char&nbsp;TimePrecMs,unsigned&nbsp;char&nbsp;OrderSend);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，可以设置为0或者1。\n\r\n\rMsgTabIndex 调度表索引号，该索引号不能大于调度表数量。\n\r\n\rTimePrecMs 调度表执行定时参数，比如调度表中，帧周期最小为10ms，那么此处可以设置为10，该值不能设置小于5.\n\r\n\rOrderSend 0-调度表里面数据并行发送，1-调度表里面数据顺序发送。 \n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。\n\r\n\r示例：\n\r  ret&nbsp;=&nbsp;CANFD_StartSchedule(DevHandle[0],SendCANIndex,0,10,0);//启动第一个调度表&nbsp;&nbsp;   if(ret&nbsp;==&nbsp;CAN_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;CAN&nbsp;Schedule&nbsp;1&nbsp;Success\\n\");&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;CAN&nbsp;Schedule&nbsp;1&nbsp;Error&nbsp;ret&nbsp;=&nbsp;%d\\n\",&nbsp;ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rCANFD_StopSchedule&nbsp;\n\r\n\r描述：\n\r\n\r停止已经启动的调度表。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CANFD_StopSchedule(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;CANIndex);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rCANIndex CAN通道索引号，可以设置为0或者1。\n\r\n\r返回值：\n\r\n\r函数执行状态，为CAN_SUCCESS表示成功，否则为失败。Copyright ? 2018. All rights reserved.","usb2canfd","topics\\函数说明/usb2canfd.htm","目录概述\n\r\n\rUSB2XXX有4通道脉冲计数器，可以配置为上升沿计数，下降沿计数，计数宽度可以配置为16位或者32位，计数模式也可以配置为加计数或者减计数。引脚的具体定义可以参考《引脚定义说明文档》。\n\r\n\r下面是该模块用到的一些宏定义：\n\r  //定义初始化Counter的数据类型&nbsp;&nbsp;  typedef&nbsp;struct&nbsp;_CNT_CONFIG{&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CounterMode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//计数模式，0-Up,1-Down&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CounterPolarity;&nbsp;&nbsp;//计数极性，0-Rising，1-Falling，2-BothEdge&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CounterBitWide;&nbsp;&nbsp;&nbsp;//计数位宽，16-16bit位宽，32-32bit位宽&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;CounterPinMode;&nbsp;&nbsp;&nbsp;//计数器输入引脚模式，0-浮空输入，1-上拉输入，2-下拉输入&nbsp;&nbsp;  }CNT_CONFIG,*PCNT_CONFIG;&nbsp;&nbsp;  &nbsp;&nbsp;  //定义函数返回错误代码&nbsp;&nbsp;  #define&nbsp;CNT_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;  #define&nbsp;CNT_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;  #define&nbsp;CNT_ERR_USB_WRITE_FAIL&nbsp;&nbsp;(-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;  #define&nbsp;CNT_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;(-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;  #define&nbsp;CNT_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;  //计数器模式&nbsp;&nbsp;  #define&nbsp;COUNTER_MODE_UP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;  #define&nbsp;COUNTER_MODE_DOWN&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;  //计数器触发条件&nbsp;&nbsp;  #define&nbsp;COUNTER_POL_RISING&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;  #define&nbsp;COUNTER_POL_FALLING&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;  #define&nbsp;COUNTER_POL_BOTHEDGE&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;  //计数器宽度&nbsp;&nbsp;  #define&nbsp;COUNTER_BITS16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;  #define&nbsp;COUNTER_BITS32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32&nbsp;&nbsp;  //计数器输入引脚模式&nbsp;&nbsp;  #define&nbsp;&nbsp;COUNTER_PIN_NOPULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x00&nbsp;&nbsp;  #define&nbsp;&nbsp;COUNTER_PIN_UP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01&nbsp;&nbsp;  #define&nbsp;&nbsp;COUNTER_PIN_DOWN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x02&nbsp;&nbsp;  //计数器通道定义&nbsp;&nbsp;  #define&nbsp;COUNTER_CH0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x01&nbsp;&nbsp;  #define&nbsp;COUNTER_CH1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x02&nbsp;&nbsp;  #define&nbsp;COUNTER_CH2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x04&nbsp;&nbsp;  #define&nbsp;COUNTER_CH3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x08&nbsp;&nbsp;\n\rCNT_Init\n\r\n\r描述：\n\r\n\r初始化配置计数器模块，在启动计数器之前必须调用。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CNT_Init(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;ChannelMask,&nbsp;PCNT_CONFIG&nbsp;pConfig);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用                                          USB_ScanDevice函数获得。\n\r\n\r                              ChannelMask&nbsp; 需要使能的通道，若需要配置该通道，则将对应的bit位设置为1，比如只使能通道0，那么该参数设置为0x01，若同时使能通道0和通道1，则该值设置为0x03.\n\r\n\rpConfig&nbsp; PWM初始化参数结构体数组。\n\r\n\r返回值：\n\r\n\r函数执行状态，0表示函数执行成功，其他值表示函数执行失败。CNT_Start\n\r\n\r描述：\n\r\n\r启动脉冲计数器。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CNT_Start(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;ChannelMask);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用                                          USB_ScanDevice函数获得。\n\r\n\r                              ChannelMask&nbsp; 需要使能的通道，若需要配置该通道，则将对应的bit位设置为1，比如只使能通道0，那么该参数设置为0x01，若同时使能通道0和通道1，则该值设置为0x03.\n\r\n\r返回值：\n\r\n\r函数执行状态，0表示函数执行成功，其他值表示函数执行失败。CNT_Stop\n\r\n\r描述：\n\r\n\r停止脉冲计数器。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CNT_Stop(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;ChannelMask);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用                                          USB_ScanDevice函数获得。\n\r\n\r                              ChannelMask&nbsp; 需要使能的通道，若需要配置该通道，则将对应的bit位设置为1，比如只使能通道0，那么该参数设置为0x01，若同时使能通道0和通道1，则该值设置为0x03.\n\r\n\r返回值：\n\r\n\r函数执行状态，0表示函数执行成功，其他值表示函数执行失败。CNT_SetValue\n\r\n\r描述：\n\r\n\r设置计数器的初始值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CNT_SetValue(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;ChannelMask,unsigned&nbsp;int&nbsp;*pCntValues);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用                                          USB_ScanDevice函数获得。\n\r\n\r                              ChannelMask&nbsp; 需要使能的通道，若需要配置该通道，则将对应的bit位设置为1，比如只使能通道0，那么该参数设置为0x01，若同时使能通道0和通道1，则该值设置为0x03.\n\r\n\rpCntValues&nbsp; 需要设置的初始值指针。\n\r\n\r返回值：\n\r\n\r函数执行状态，0表示函数执行成功，其他值表示函数执行失败。CNT_GetValue\n\r\n\r描述：\n\r\n\r获取当前计数器的值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;CNT_GetValue(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;ChannelMask,unsigned&nbsp;int&nbsp;*pCntValues);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用                                          USB_ScanDevice函数获得。\n\r\n\r                              ChannelMask&nbsp; 需要使能的通道，若需要配置该通道，则将对应的bit位设置为1，比如只使能通道0，那么该参数设置为0x01，若同时使能通道0和通道1，则该值设置为0x03.\n\r\n\rpCntValues&nbsp; 需要存储计数器值的指针。\n\r\n\r返回值：\n\r\n\r函数执行状态，0表示函数执行成功，其他值表示函数执行失败。","usb2cnt","topics\\函数说明/usb2cnt.htm","目录\n\r  概述     DAC_Init    DAC_StartDAC_Stop  \n\r概述&nbsp; \n\r\n\r本文主要介绍关于USB2XXX的ADAC操作相关API，在调用这些函数前需要调用设备操作相关函数，比如扫描设备，打开设备等，详情请查看《设备操作相关函数说明 》。 \n\r\n\r下面是本文函数可能会用到的一些宏定义： \n\r  //定义函数返回错误代码&nbsp;&nbsp;   #define&nbsp;DAC_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;   #define&nbsp;DAC_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;   #define&nbsp;DAC_ERR_USB_WRITE_FAIL&nbsp;&nbsp;(-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;   #define&nbsp;DAC_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;   (-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;   #define&nbsp;DAC_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;   #define&nbsp;DAC_ERR_CH_NO_INIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-5)&nbsp;&nbsp;//该通道未初始化&nbsp;&nbsp; \n\rDAC_Init \n\r\n\r描述： \n\r\n\r初始化配置DAC并根据配置数据输出DAC波形。 \n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;DAC_Init(int&nbsp;DevHandle,unsigned&nbsp;short&nbsp;CycleUs,unsigned&nbsp;short&nbsp;*pWaveData,unsigned&nbsp;short&nbsp;WaveDataNum);&nbsp;&nbsp;\n\r\n\r\n\r参数： \n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数或得。\n\r\n\rCycleUs &nbsp;DAC数据输出间隔时间，单位为0.25微妙，比如该参数传入4，那么DAC数据输出的间隔时间就是0.25*4=1us，波形输出的周期= 0.25*CycleUs*WaveDataNum微秒。\n\r\n\rpWaveData &nbsp;DAC输出数据指针，DAC为12bit转换，所以单个数据最大值为4095，对应3.3V，最多只能输出512个数据，最少输出2个数据。\n\r\n\rWaveDataNum DAC输出数据个数，最小为2，最大为512.\n\r\n\r返回值：\n\r\n\r初始化DAC的状态，0-配置成功，其他值，配置失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;  #include&nbsp;&lt;stdint.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;  #include&nbsp;\"usb2dac.h\"&nbsp;&nbsp;  #include&nbsp;&lt;math.h&gt;&nbsp;&nbsp;  int&nbsp;main(int&nbsp;argc,&nbsp;const&nbsp;char*&nbsp;argv[])&nbsp;&nbsp;  {&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;DEVICE_INFO&nbsp;DevInfo;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;DevHandle[10];&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;bool&nbsp;state;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;short&nbsp;DACBuffer[512];//缓冲区数据不能大于512&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;//扫描查找设备&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;USB_ScanDevice(DevHandle);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;if(ret&nbsp;&lt;=&nbsp;0){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"No&nbsp;device&nbsp;connected!\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//打开设备&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;=&nbsp;USB_OpenDevice(DevHandle[0]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if(!state){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Open&nbsp;device&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//获取固件信息&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;FuncStr[256]={0};&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;=&nbsp;DEV_GetDeviceInfo(DevHandle[0],&amp;DevInfo,FuncStr);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if(!state){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Get&nbsp;device&nbsp;infomation&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Firmware&nbsp;Info:\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"&nbsp;&nbsp;&nbsp;&nbsp;Name:%s\\n\",DevInfo.FirmwareName);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"&nbsp;&nbsp;&nbsp;&nbsp;Build&nbsp;Date:%s\\n\",DevInfo.BuildDate);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"&nbsp;&nbsp;&nbsp;&nbsp;Firmware&nbsp;Version:v%d.%d.%d\\n\",(DevInfo.FirmwareVersion&gt;&gt;24)&amp;0xFF,(DevInfo.FirmwareVersion&gt;&gt;16)&amp;0xFF,DevInfo.FirmwareVersion&amp;0xFFFF);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"&nbsp;&nbsp;&nbsp;&nbsp;Hardware&nbsp;Version:v%d.%d.%d\\n\",(DevInfo.HardwareVersion&gt;&gt;24)&amp;0xFF,(DevInfo.HardwareVersion&gt;&gt;16)&amp;0xFF,DevInfo.HardwareVersion&amp;0xFFFF);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"&nbsp;&nbsp;&nbsp;&nbsp;Functions:%08X\\n\",DevInfo.Functions);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"&nbsp;&nbsp;&nbsp;&nbsp;Functions:%s\\n\",FuncStr);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//产生方波信号&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;256;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DACBuffer[i]&nbsp;=&nbsp;0xFFF;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=256;i&lt;512;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DACBuffer[i]&nbsp;=&nbsp;0x0;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//初始化ADC,初始化配置后会自动输出波形&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;TimeOfUs&nbsp;=&nbsp;4;//每个数据输出的时间周期&nbsp;=&nbsp;TimeOfUs*0.25&nbsp;us&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;DAC_Init(DevHandle[0],TimeOfUs,DACBuffer,512);//周期&nbsp;=&nbsp;0.25*TimeOfUs*512&nbsp;us&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if(ret&nbsp;!=&nbsp;DAC_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Init&nbsp;dac&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;getchar();&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//输出正弦信号&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;dcVoltage&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;//直流分量&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;float&nbsp;amplitude&nbsp;=&nbsp;2.3;&nbsp;&nbsp;//幅值，幅值加上直流分量不能大于3.3V&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;DataNum=64;//周期&nbsp;=&nbsp;0.25*TimeOfUs*DataNum&nbsp;us&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;DataNum;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DACBuffer[i]&nbsp;=&nbsp;((dcVoltage+amplitude*(1+sin(2*3.141592653589793*i/DataNum))/2.0)*4095)/3.3;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//初始化ADC,初始化配置后会自动输出波形&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;DAC_Init(DevHandle[0],TimeOfUs,DACBuffer,DataNum);//周期&nbsp;=&nbsp;0.25*TimeOfUs*512&nbsp;us&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if(ret&nbsp;!=&nbsp;DAC_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Init&nbsp;dac&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;getchar();&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//输出三角波信号&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;DataNum/2;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DACBuffer[i]&nbsp;=&nbsp;(dcVoltage+amplitude*(i/(DataNum/2.0)))*4095.0/3.3;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;DataNum/2;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DACBuffer[i+DataNum/2]&nbsp;=&nbsp;(dcVoltage+amplitude*((DataNum/2.0-i)/(DataNum/2.0)))*4095.0/3.3;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;getchar();&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//停止数据输出&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;DAC_Stop(DevHandle[0]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;//关闭设备&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;USB_CloseDevice(DevHandle[0]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\rDAC_Start\n\r\n\r描述：\n\r\n\r控制DAC开始输出数据。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;DAC_Start(int&nbsp;DevHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\r返回值：\n\r\n\r函数执行状态，0-成功，其他值-失败。\n\r\n\r示例：DAC_Stop\n\r\n\r描述：\n\r\n\r停止DAC输出数据。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;DAC_Stop(int&nbsp;DevHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\r返回值：\n\r\n\r函数执行状态，0-成功，其他值-失败。\n\r\n\r示例：","usb2dac","topics\\函数说明/usb2dac.htm","目录\n\r  概述\n\r  GPIO_SetInput\n\r  GPIO_SetOutput\n\r  GPIO_SetOpenDrain\n\r  GPIO_Write\n\r  GPIO_Read\n\r概述\n\r\n\r本文主要介绍关于USB2XXX的GPIO操作相关函数，使用这些函数可以控制适配器上P0到P15引脚输出高低电平，或者读取这些引脚电平。在调用这些函数前需要调用设备操作相关函数，比如扫描设备，打开设备等，详情请查看《设备操作相关函数说明》。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //定义函数返回错误代码&nbsp;&nbsp;  #define&nbsp;GPIO_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;  #define&nbsp;GPIO_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;  #define&nbsp;GPIO_ERR_USB_WRITE_FAIL&nbsp;&nbsp;(-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;  #define&nbsp;GPIO_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;(-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;  #define&nbsp;GPIO_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;  &nbsp;&nbsp;  //上下拉电阻配置&nbsp;&nbsp;  #define&nbsp;GPIO_PUPD_NOPULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0x00&nbsp;&nbsp;&nbsp;&nbsp;//没有上拉下拉&nbsp;&nbsp;  #define&nbsp;GPIO_PUPD_UP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0x01&nbsp;&nbsp;&nbsp;&nbsp;//使能上拉&nbsp;&nbsp;  #define&nbsp;GPIO_PUPD_DOWN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0x02&nbsp;&nbsp;&nbsp;&nbsp;//使能下拉&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r\n\r\n\rGPIO_SetInput\n\r\n\r描述：\n\r\n\r将指定引脚设置为输入模式，设置为输入模式后可以通过调用GPIO_Read函数获取引脚高低电平状态。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;GPIO_SetInput(int&nbsp;DevHandle,unsigned&nbsp;int&nbsp;PinMask,&nbsp;unsigned&nbsp;char&nbsp;PuPd);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rPinMask&nbsp; 指定需要设置为输入模式的引脚，该值每个bit位对应一个引脚，最低位对应P0。若对应的bit位为1，则该引脚要被设置为输入模式，为0则不影响引脚原来工作状态。\n\r\n\rPuPd&nbsp; 配置引脚模式，0-无上拉和下拉电阻，1-使能上拉电阻，2-使能下拉电阻。\n\r\n\r返回值：\n\r\n\r引脚配置状态，0-配置引脚成功，若小于0则该函数调用失败。\n\r\n\r示例：&nbsp;\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb2gpio.h\"&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  int&nbsp;ret;&nbsp;&nbsp;  //将P0到P7配置为上拉输入模式&nbsp;&nbsp;  ret&nbsp;=&nbsp;GPIO_SetInput(DeviceHandle,0x00FF,GPIO_PUPD_UP);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;GPIO_SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"配置引脚失败\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;  }&nbsp;&nbsp;  //将P8到P15配置为下拉输入模式&nbsp;&nbsp;  ret&nbsp;=&nbsp;GPIO_SetInput(DeviceHandle,0xFF00,GPIO_PUPD_DOWN);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;GPIO_SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"配置引脚失败\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;  }&nbsp;&nbsp;\n\r\n\r\n\rGPIO_SetOutput\n\r\n\r描述：\n\r\n\r将指定引脚设置为输出模式，设置为输出模式后，可以通过调用GPIO_Write函数将指定引脚设置为高电平或者低电平。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;GPIO_SetOutput(int&nbsp;DevHandle,unsigned&nbsp;int&nbsp;PinMask,&nbsp;unsigned&nbsp;char&nbsp;PuPd);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rPinMask&nbsp; 指定需要设置为输出模式的引脚，该值每个bit位对应一个引脚，最低位对应P0，对应的bit位为1，则该引脚要被设置为输出模式，为0则不影响引脚原来工作状态。\n\r\n\rPuPd&nbsp; 配置引脚模式，0-无上拉和下拉电阻，1-使能上拉电阻，2-使能下拉电阻。\n\r\n\r返回值：\n\r\n\r引脚配置状态，0-配置引脚成功，若小于0则该函数调用失败。\n\r\n\r示例：&nbsp;\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb2gpio.h\"&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  int&nbsp;ret;&nbsp;&nbsp;  //将P0到P7配置为上拉输出模式&nbsp;&nbsp;  ret&nbsp;=&nbsp;GPIO_SetOutput(DeviceHandle,0x00FF,GPIO_PUPD_UP);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;GPIO_SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"配置引脚失败\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;  }&nbsp;&nbsp;  //将P8到P15配置为下拉输出模式&nbsp;&nbsp;  ret&nbsp;=&nbsp;GPIO_SetOutput(DeviceHandle,0xFF00,GPIO_PUPD_DOWN);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;GPIO_SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"配置引脚失败\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;  }&nbsp;&nbsp;\n\rGPIO_SetOpenDrain\n\r\n\r描述：\n\r\n\r将指定引脚设置为开漏模式，在该模式下，引脚可以当双向引脚使用。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;GPIO_SetOpenDrain(int&nbsp;DevHandle,unsigned&nbsp;int&nbsp;PinMask,&nbsp;unsigned&nbsp;char&nbsp;PuPd);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rPinMask&nbsp; 指定需要设置为开漏模式的引脚，该值每个bit位对应一个引脚，最低位对应P0，对应的bit位为1，则该引脚要被设置为开漏模式，为0则不影响引脚原来工作状态。\n\r\n\rPuPd&nbsp; 配置引脚模式，0-无上拉或者下拉电阻，1-使能上拉电阻，2-使能下拉电阻。\n\r\n\r返回值：\n\r\n\r引脚配置状态，0-配置引脚成功，若小于0则该函数调用失败。\n\r\n\r示例：&nbsp;\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb2gpio.h\"&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  int&nbsp;ret;&nbsp;&nbsp;  //将P4到P11配置为上拉开漏模式，开漏模式下需要使能内部上拉电阻或者外接上拉电阻，否则无法输出高电平&nbsp;  ret&nbsp;=&nbsp;GPIO_SetOpenDrain(DeviceHandle,0x0FF0,GPIO_PUPD_UP);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;GPIO_SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"配置引脚失败\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;  }&nbsp;&nbsp;  \n\rGPIO_Write\n\r\n\r描述：\n\r\n\r当GPIO引脚被配置为输出模式时，设置引脚输出高电平或者低电平。\n\r\n\r原型：\n\r\n\rint&nbsp;WINAPI&nbsp;GPIO_Write(int&nbsp;DevHandle,unsigned&nbsp;int&nbsp;PinMask,&nbsp;unsigned&nbsp;int&nbsp;PinValue);&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rPinMask&nbsp; 指定需要输出数据的引脚，该值每个bit位对应一个引脚，最低位对应P0。对应的bit位为1，则该引脚要根据PinValue对应位的值输出对应的电平状态。对应的bit位为0，则不影响该引脚的电平状态。\n\r\n\rPinValue&nbsp; 根据PinMask的值控制引脚输出对应的电平状态，该数据每个bit位对应一个引脚，最低bit位对应P0，若对应的bit位为1且PinMask的对应bit位为1则该引脚输出高电平，若对应bit位为0且PinMask的对应位为1则该引脚输出低电平，否则不影响引脚输出的电平状态。\n\r\n\r返回值：\n\r\n\r控制引脚输出数据的状态，0-设置成功，若小于0则设置失败。\n\r\n\r示例：&nbsp;\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb2gpio.h\"&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  int&nbsp;ret;&nbsp;&nbsp;  //将P0到P7输出高电平，P8到P15输出低电平&nbsp;&nbsp;  ret&nbsp;=&nbsp;GPIO_Write(DeviceHandle,0xFFFF,0x00FF);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;GPIO_SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"控制引脚失败\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;  }&nbsp;&nbsp;  //将P0到P7输出低电平，P8到P15输出高电平&nbsp;&nbsp;  ret&nbsp;=&nbsp;GPIO_Write(DeviceHandle,0xFFFF,0xFF00);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;GPIO_SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"控制引脚失败\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;  }&nbsp;&nbsp;  //将P0到P7输出高电平，其他引脚保留原来的电平状态&nbsp;&nbsp;  ret&nbsp;=&nbsp;GPIO_Write(DeviceHandle,0x00FF,0x00FF);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;GPIO_SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"控制引脚失败\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;  }&nbsp;&nbsp;\n\rGPIO_Read\n\r\n\r描述：\n\r\n\r当GPIO引脚被配置为输入模式时，通过该函数获取管脚输入的电平状态。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;GPIO_Read(int&nbsp;DevHandle,unsigned&nbsp;int&nbsp;PinMask,&nbsp;unsigned&nbsp;int&nbsp;*pPinValue);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rPinMask&nbsp; 指定需要获取输入数据的引脚，该值每个bit位对应一个引脚，最低位对应P0。对应的bit位为1，则pPinValue会返回引脚的电平状态，否则不返回状态。\n\r\n\rpPinValue&nbsp; 获取引脚电平状态的数据指针。\n\r\n\r返回值：\n\r\n\r获取引脚输入数据的状态，0-设置成功，若小于0则设置失败。\n\r\n\r示例：&nbsp;\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb2gpio.h\"&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;  int&nbsp;ret;&nbsp;&nbsp;  unsigned&nbsp;int&nbsp;PinValue;&nbsp;&nbsp;  //获取P0到P8引脚的电平状态&nbsp;&nbsp;  ret&nbsp;=&nbsp;GPIO_Read(DeviceHandle,0x00FF,&amp;PinValue);&nbsp;&nbsp;  if(ret&nbsp;!=&nbsp;GPIO_SUCCESS){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;printf(\"获取引脚状态失败\\n\");&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;  }else{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;8;i++){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if((PinValue&amp;(1&lt;&lt;i))!=0x00){&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"P[%d]为高电平\\n\",i);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"P[%d]为低电平\\n\",i);&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;  }&nbsp;&nbsp;\n\r","usb2gpio","topics\\函数说明/usb2gpio.htm","目录\n\r  概述  IIC_Init  IIC_GetSlaveAddr  IIC_WriteBytes  IIC_ReadBytes  IIC_WriteReadBytes  IIC_SlaveWriteBytes  IIC_SlaveReadBytes  IIC_SlaveWriteRemain  IIC_WriteBytesOfEvent  IIC_ReadBytesOfEvent  IIC_WriteReadBytesOfEvent\n\r概述\n\r\n\rUSB2XXX有8路IIC/I2C信号输出，每路最大时钟频率可达400Kbps,USB2XXX的IIC/I2C总线上不带上拉电阻，在实际使用的时候需要外接上拉电阻，或者软件上使能内部上拉电阻，总线上拉电压范围为1.8V到5V。U2B2XXX的IIC/I2C支持主机模式和从机模式（只有通道0和通道1支持从机模式）。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //定义初始化IIC的数据类型&nbsp;&nbsp;  typedef&nbsp;struct&nbsp;_IIC_CONFIG{&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;ClockSpeedHz;&nbsp;&nbsp;   //IIC时钟频率:单位为Hz&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;short&nbsp;&nbsp;OwnAddr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //USB2XXX为从机时自己的地址&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;Master;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //主从选择控制:0-从机，1-主机&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;AddrBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //从机地址模式，7-7bit模式，10-10bit模式&nbsp;&nbsp;   &nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;&nbsp;EnablePu;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //使能引脚芯片内部上拉电阻，若不使能，则I2C总线上必须接上拉电阻&nbsp;&nbsp;   }IIC_CONFIG,*PIIC_CONFIG;&nbsp;&nbsp;   &nbsp;&nbsp;   //定义函数返回错误代码&nbsp;&nbsp;   #define&nbsp;IIC_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;   #define&nbsp;IIC_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;   #define&nbsp;IIC_ERR_USB_WRITE_FAIL&nbsp;&nbsp;(-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;   #define&nbsp;IIC_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;   (-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;   #define&nbsp;IIC_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;   #define&nbsp;IIC_ERR_PARA_ERROR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-5)&nbsp;&nbsp;//参数传入错误&nbsp;&nbsp;   //定义IIC函数返回错误代码&nbsp;&nbsp;   #define&nbsp;IIC_ERROR_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0&nbsp;&nbsp;&nbsp;//操作成功&nbsp;&nbsp;   #define&nbsp;IIC_ERROR_CHANNEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1&nbsp;&nbsp;&nbsp;//该通道不支持该函数&nbsp;&nbsp;   #define&nbsp;IIC_ERROR_BUSY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   2&nbsp;&nbsp;&nbsp;//总线忙&nbsp;&nbsp;   #define&nbsp;IIC_ERROR_START_FAILD&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;//启动总线失败&nbsp;&nbsp;   #define&nbsp;IIC_ERROR_TIMEOUT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   4&nbsp;&nbsp;&nbsp;//超时&nbsp;&nbsp;   #define&nbsp;IIC_ERROR_NACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;//从机无应答&nbsp;&nbsp;   #define&nbsp;IIC_ERROR_PEC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   6&nbsp;&nbsp;&nbsp;//PEC校验失败&nbsp;&nbsp;\n\rIIC_Init\n\r\n\r描述：\n\r\n\r初始化配置IIC/I2C总线。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;IIC_Init(int&nbsp;DevHandle,int&nbsp;IICIndex,&nbsp;PIIC_CONFIG&nbsp;pConfig);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rIICIndex&nbsp; IIC/I2C通道索引号，每个通道对应的管脚可参考《引脚定义说明文档 》。\n\r\n\rpConfig &nbsp; IIC/I2C初始化配置参数结构指针，具体取值说明可参考概述说明。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2iic.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;IICIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;&nbsp;ret;&nbsp;&nbsp;   //初始化配置I2C&nbsp;&nbsp;   IIC_CONFIG&nbsp;IIC_Config;&nbsp;&nbsp;   IIC_Config.AddrBits&nbsp;=&nbsp;7;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//7bit地址模式&nbsp;&nbsp;   IIC_Config.ClockSpeedHz&nbsp;=&nbsp;400000;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//时钟频率400KHz&nbsp;&nbsp;   IIC_Config.EnablePu&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使能内部上拉电阻&nbsp;&nbsp;   #if&nbsp;SLAVE_WRITE_TEST||SLAVE_READ_TEST&nbsp;&nbsp;   IIC_Config.Master&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从机模式&nbsp;&nbsp;   IIC_Config.OwnAddr&nbsp;=&nbsp;0x71;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//从机地址&nbsp;&nbsp;   #else&nbsp;&nbsp;   IIC_Config.Master&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//主机模式&nbsp;&nbsp;   #endif&nbsp;&nbsp;   ret&nbsp;=&nbsp;IIC_Init(DevHandle,IICIndex,&amp;IIC_Config);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;IIC_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;IIC&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;IIC&nbsp;IIC_SUCCESS!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rIIC_GetSlaveAddr\n\r\n\r描述：\n\r\n\r获取IIC/I2C总线上已经连接好的从机设备地址列表，使用此函数可以检测当前总线上连接的器件是否能正常工作。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;IIC_GetSlaveAddr(int&nbsp;DevHandle,int&nbsp;IICIndex,short&nbsp;*pSlaveAddr);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rIICIndex&nbsp; IIC/I2C通道索引号，每个通道对应的管脚可参考《引脚定义说明文档 》。\n\r\n\rpSlaveAddr&nbsp; IIC/I2C总线上能正常响应的从设备地址列表指针。\n\r\n\r返回值：\n\r\n\r大于0为扫描到的从机数量，小于0则函数调用出错。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2iic.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   int&nbsp;IICIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;&nbsp;ret;&nbsp;&nbsp;   //获取总线上能应答的从机地址&nbsp;&nbsp;   short&nbsp;SlaveAddrs[128];&nbsp;&nbsp;//地址存储缓冲区&nbsp;&nbsp;   int&nbsp;SlaveAddrNum&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;//返回应答的地址个数&nbsp;&nbsp;   SlaveAddrNum&nbsp;=&nbsp;IIC_GetSlaveAddr(DevHandle,IICIndex,SlaveAddrs);&nbsp;&nbsp;   if(SlaveAddrNum&nbsp;&gt;=&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Get&nbsp;%d&nbsp;slave&nbsp;address!\\n\",SlaveAddrNum);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;SlaveAddrNum;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",SlaveAddrs[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Get&nbsp;slave&nbsp;address&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rIIC_WriteBytes \n\r\n\r描述：\n\r\n\r主机模式向IIC/I2C总线上写数据，调用该函数后，USB2XXX会先发送从机地址，若从机正常应答之后再发送指定字节数数据。\n\r\n\r对应IIC/I2C本身来说是没有定义子地址或者内部寄存器地址概念的，但是大多数芯片在写数据时都要求先写一个内部寄存器地址，再发送要写入该寄存器的数据，那么在使用此函数时，只需要把内部寄存器地址放到发送的数据前面即可。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;IIC_WriteBytes(int&nbsp;DevHandle,int&nbsp;IICIndex,short&nbsp;SlaveAddr,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rIICIndex&nbsp; IIC/I2C通道索引号，每个通道对应的管脚可参考《引脚定义说明文档 》。\n\r\n\rSlaveAddr&nbsp; IIC/I2C从设备地址，不包含读写位，比如包含了读写位的从机地址是0xA0，那么不包含读写位的从机地址就是0xA0&gt;&gt;1，也就是0x50.\n\r\n\rpWriteData&nbsp; 待发送的数据缓冲区指针。\n\r\n\rWriteLen&nbsp; 待发送数据的字节数。\n\r\n\rTimeOutMs&nbsp; IIC/I2C总线若不能正常响应时，其等待时间，单位为毫秒。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2iic.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;IICIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;&nbsp;ret;&nbsp;&nbsp;   //IIC&nbsp;写数据&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[8]={0x10,0x02,0x03,0x04,0x05,0x06,0x07,0x08};&nbsp;&nbsp;   ret&nbsp;=&nbsp;IIC_WriteBytes(DevHandle,IICIndex,0x50,WriteBuffer,sizeof(WriteBuffer),10);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;IIC_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Write&nbsp;IIC&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Error&nbsp;Code:%d\\n\",ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Write&nbsp;IIC&nbsp;IIC_SUCCESS!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rIIC_ReadBytes&nbsp;\n\r\n\r描述：\n\r\n\r主机模式向IIC/I2C从机读取数据，调用该函数后，USB2XXX会先发送从机地址，若从机正常响应了则会进入主机接收模式从从机读取指定字节数数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;IIC_ReadBytes(int&nbsp;DevHandle,int&nbsp;IICIndex,short&nbsp;SlaveAddr,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rIICIndex&nbsp; IIC/I2C通道索引号，每个通道对应的管脚可参考《引脚定义说明文档 》。\n\r\n\rSlaveAddr&nbsp; IIC/I2C从设备地址，不包含读写位，比如包含了读写位的从机地址是0xA0，那么不包含读写位的从机地址就是0xA0&gt;&gt;1，也就是0x50.\n\r\n\rpReadData&nbsp; 存储从从机返回的数据缓冲区首地址。\n\r\n\rReadLen&nbsp; 待读取数据的字节数。\n\r\n\rTimeOutMs&nbsp; IIC/I2C总线若不能正常响应时，其等待时间，单位为毫秒。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2iic.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   int&nbsp;IICIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;&nbsp;ret;&nbsp;&nbsp;   //IIC&nbsp;读数据&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[8];&nbsp;&nbsp;   ret&nbsp;=&nbsp;IIC_ReadBytes(DevHandle,IICIndex,0x50,ReadBuffer,sizeof(ReadBuffer),10);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;IIC_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;IIC&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Error&nbsp;Code:%d\\n\",ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;IIC&nbsp;IIC_SUCCESS!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;Data:\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;sizeof(ReadBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rIIC_WriteReadBytes\n\r\n\r描述：\n\r\n\r主机模式向IIC/I2C总线发送数据之后再读取指定字节数数据，调用该函数后，USB2XXX会先发送从机地址，然后发送指定的数据，然后再发送从机地址，再从从机读取数据，该函数在操作带内部寄存器地址的设备的时候非常有用。比如IIC/I2C接口的EEPROM。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;IIC_WriteReadBytes(int&nbsp;DevHandle,int&nbsp;IICIndex,short&nbsp;SlaveAddr,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rIICIndex&nbsp; IIC/I2C通道索引号，每个通道对应的管脚可参考《引脚定义说明文档 》。\n\r\n\rSlaveAddr&nbsp; IIC/I2C从设备地址，不包含读写位，比如包含了读写位的从机地址是0xA0，那么不包含读写位的从机地址就是0xA0&gt;&gt;1，也就是0x50.\n\r\n\rpWriteData&nbsp; 待发送的数据缓冲区首地址。\n\r\n\rWriteLen&nbsp; 待发送数据的字节数。\n\r\n\rpReadData&nbsp; 存储从从机返回的数据缓冲区首地址。\n\r\n\rReadLen&nbsp; 待读取数据的字节数。\n\r\n\rTimeOutMs&nbsp; IIC/I2C总线若不能正常响应时，其等待时间，单位为毫秒。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2iic.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;IICIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[8];&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[8];&nbsp;&nbsp;   //IIC&nbsp;写读数据。也就是先发送数据，然后再次产生START信号，再读数据&nbsp;&nbsp;   //注意：对于每个I2C设备，必须按照设备要求正确读写，否则可能会导致设备工作不正常，从而导致无法读写数据&nbsp;&nbsp;   WriteBuffer[0]&nbsp;=&nbsp;0x08;&nbsp;&nbsp;   ret&nbsp;=&nbsp;IIC_WriteReadBytes(DevHandle,IICIndex,0x50,WriteBuffer,1,ReadBuffer,sizeof(ReadBuffer),1000);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;IIC_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"WriteRead&nbsp;IIC&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Error&nbsp;Code:%d\\n\",ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"WriteRead&nbsp;IIC&nbsp;IIC_SUCCESS!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;Data:\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;sizeof(ReadBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rIIC_SlaveWriteBytes&nbsp;\n\r\n\r描述：\n\r\n\r从机模式写数据，调用该函数后，数据会存放到USB2XXX内部数据缓冲区，然后等待主机产生读数据时序，地址匹配后再将数据移位发送出去。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;IIC_SlaveWriteBytes(int&nbsp;DevHandle,int&nbsp;IICIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rIICIndex&nbsp; IIC/I2C通道索引号，每个通道对应的管脚可参考《引脚定义说明文档 》。\n\r\n\rpWriteData&nbsp; 待发送的数据缓冲区首地址。\n\r\n\rWriteLen&nbsp; 待发送数据的字节数。\n\r\n\rTimeOutMs&nbsp; 等待数据被读取的超时时间，若为0则不用等待数据发送完毕立即返回，大于0则等待数据发送完毕或者超时之后再返回。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2iic.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;IICIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   //IIC&nbsp;从机模式写数据&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;SlaveWriteBuffer[256];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(SlaveWriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;SlaveWriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;(sizeof(SlaveWriteBuffer)/8);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;IIC_SlaveWriteBytes(DevHandle,IICIndex,&amp;SlaveWriteBuffer[i*8],8,10000);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if(ret&nbsp;&lt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Slave&nbsp;write&nbsp;data&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(ret&nbsp;==&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Slave&nbsp;write&nbsp;data&nbsp;IIC_SUCCESS!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(ret&nbsp;&gt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Slave&nbsp;write&nbsp;data&nbsp;IIC_SUCCESS!&nbsp;have&nbsp;%d&nbsp;byte&nbsp;data&nbsp;remain\\n\",ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rIIC_SlaveReadBytes\n\r\n\r描述：\n\r\n\r获取在从机模式下接收到的数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;IIC_SlaveReadBytes(int&nbsp;DevHandle,int&nbsp;IICIndex,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rIICIndex&nbsp; IIC/I2C通道索引号，每个通道对应的管脚可参考《引脚定义说明文档 》。\n\r\n\rpReadData&nbsp; 存储IIC/I2C在从机模式下接收到的数据缓冲区首地址。\n\r\n\rTimeOutMs&nbsp; 等待接收数据超时参数，若为0则立即返回，大于0则接收到数据或者超时后返回。\n\r\n\r返回值：\n\r\n\r小于0则该函数调用出错，否则返回读取到的数据字节数。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2iic.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;IICIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   //IIC&nbsp;从机模式读数据&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;SlaveReadBuffer[256];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;16;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;IIC_SlaveReadBytes(DevHandle,IICIndex,SlaveReadBuffer,10000);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if(ret&nbsp;&lt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Slave&nbsp;read&nbsp;data&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(ret&nbsp;==&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Slave&nbsp;read&nbsp;data&nbsp;IIC_SUCCESS!&nbsp;but&nbsp;no&nbsp;data\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;if(ret&nbsp;&gt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Slave&nbsp;read&nbsp;data&nbsp;IIC_SUCCESS!&nbsp;have&nbsp;%d&nbsp;byte&nbsp;data&nbsp;have&nbsp;read\\n\",ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;ret;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",SlaveReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;   printf(\"Slave&nbsp;read&nbsp;end!\\n\");&nbsp;&nbsp;\n\rIIC_SlaveWriteRemain \n\r\n\r描述：\n\r\n\r获取在从机发送数据模式下，发送数据缓冲区遗留的数据字节数。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;IIC_SlaveWriteRemain(int&nbsp;DevHandle,int&nbsp;IICIndex);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rIICIndex&nbsp; IIC/I2C通道索引号，每个通道对应的管脚可参考《引脚定义说明文档 》。\n\r\n\r返回值：\n\r\n\r小于0则该函数调用出错，否则返回发送数据缓冲区中遗留的数据字节数。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2iic.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;IICIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   ret&nbsp;=&nbsp;IIC_SlaveWriteRemain(DevHandle,IICIndex);&nbsp;&nbsp;   if(ret&nbsp;&lt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Get&nbsp;slave&nbsp;write&nbsp;remain&nbsp;data&nbsp;count&nbsp;error!\\n\");&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Have&nbsp;%d&nbsp;byte&nbsp;data&nbsp;remained!\\n\",ret);&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rIIC_WriteBytesOfEvent\n\r\n\r描述：\n\r\n\r等到事件后主机模式向IIC/I2C总线上写数据，调用该函数后，USB2XXX会先发送从机地址，若从机正常应答之后再发送指定字节数数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;IIC_WriteBytesOfEvent(int&nbsp;DevHandle,int&nbsp;IICIndex,short&nbsp;SlaveAddr,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen,int&nbsp;EventPin,unsigned&nbsp;char&nbsp;EventType,int&nbsp;TimeOutOfEventMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rIICIndex&nbsp; IIC/I2C通道索引号，每个通道对应的管脚可参考《引脚定义说明文档 》。\n\r\n\rSlaveAddr&nbsp; IIC/I2C从设备地址，不包含读写位，比如包含了读写位的从机地址是0xA0，那么不包含读写位的从机地址就是0xA0&gt;&gt;1，也就是0x50.\n\r\n\rpWriteData&nbsp; 待发送的数据缓冲区首地址。\n\r\n\rWriteLen&nbsp; 待发送数据的字节数。\n\r\n\rEventPin&nbsp; 等待事件输入的GPIO引脚，每个bit位对应一个引脚，比如P0为0x01，P2为0x04，P15为0x8000。\n\r\n\rEventType&nbsp;&nbsp; 等待件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿。\n\r\n\rTimeOutOfEventMs&nbsp; 等待事件超时时间，单位为毫秒，等待超时后该函数直接返回，不执行任何操作。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2iic.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   int&nbsp;IICIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;&nbsp;ret;&nbsp;&nbsp;   //IIC&nbsp;写数据&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[8]={0x10,0x02,0x03,0x04,0x05,0x06,0x07,0x08};&nbsp;&nbsp;   ret&nbsp;=&nbsp;IIC_WriteBytesOfEvent(DevHandle,IICIndex,0x50,WriteBuffer,sizeof(WriteBuffer),0x01,0x10,100);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;IIC_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Write&nbsp;IIC&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Error&nbsp;Code:%d\\n\",ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Write&nbsp;IIC&nbsp;IIC_SUCCESS!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rIIC_ReadBytesOfEvent\n\r\n\r描述：\n\r\n\r等到事件后主机模式向IIC/I2C从机读取数据，调用该函数后，USB2XXX会先发送从机地址，若从机正常响应了则会进入主机接收模式从从机读取指定字节数数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;IIC_ReadBytesOfEvent(int&nbsp;DevHandle,int&nbsp;IICIndex,short&nbsp;SlaveAddr,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen,int&nbsp;EventPin,unsigned&nbsp;char&nbsp;EventType,int&nbsp;TimeOutOfEventMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rIICIndex&nbsp; IIC/I2C通道索引号，每个通道对应的管脚可参考《引脚定义说明文档 》。\n\r\n\rSlaveAddr&nbsp; IIC/I2C从设备地址，不包含读写位，比如包含了读写位的从机地址是0xA0，那么不包含读写位的从机地址就是0xA0&gt;&gt;1，也就是0x50.\n\r\n\rpReadData&nbsp; 存储从从机返回的数据缓冲区首地址。\n\r\n\rReadLen&nbsp; 待读取数据的字节数。\n\r\n\rEventPin&nbsp; 等待事件输入的GPIO引脚，每个bit位对应一个引脚，比如P0为0x01，P2为0x04，P15为0x8000。\n\r\n\rEventType&nbsp;&nbsp; 等待件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿。\n\r\n\rTimeOutOfEventMs&nbsp; 等待事件超时时间，单位为毫秒，等待超时后该函数直接返回，不执行任何操作。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2iic.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;IICIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;&nbsp;ret;&nbsp;&nbsp;   //IIC&nbsp;读数据&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[8];&nbsp;&nbsp;   ret&nbsp;=&nbsp;IIC_ReadBytesOfEvent(DevHandle,IICIndex,0x50,ReadBuffer,sizeof(ReadBuffer),0x01,0x10,100);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;IIC_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;IIC&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Error&nbsp;Code:%d\\n\",ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;IIC&nbsp;IIC_SUCCESS!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;Data:\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;sizeof(ReadBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rIIC_WriteReadBytesOfEvent\n\r\n\r描述：\n\r\n\r等到事件后主机模式向IIC/I2C总线发送数据之后再读取指定字节数数据，调用该函数后，USB2XXX会先发送从机地址，然后发送指定的数据，然后再发送从机地址，再从从机读取数据，该函数在操作带内部寄存器地址的设备的时候非常有用。比如IIC/I2C接口的EEPROM。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;IIC_WriteReadBytesOfEvent(int&nbsp;DevHandle,int&nbsp;IICIndex,short&nbsp;SlaveAddr,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen,int&nbsp;EventPin,unsigned&nbsp;char&nbsp;EventType,int&nbsp;TimeOutOfEventMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rIICIndex&nbsp; IIC/I2C通道索引号，每个通道对应的管脚可参考《引脚定义说明文档 》。\n\r\n\rSlaveAddr&nbsp; IIC/I2C从设备地址，不包含读写位，比如包含了读写位的从机地址是0xA0，那么不包含读写位的从机地址就是0xA0&gt;&gt;1，也就是0x50.\n\r\n\rpWriteData&nbsp; 待发送的数据缓冲区首地址。\n\r\n\rWriteLen&nbsp; 待发送数据的字节数。\n\r\n\rpReadData&nbsp; 存储从从机返回的数据缓冲区首地址。\n\r\n\rReadLen&nbsp; 待读取数据的字节数。\n\r\n\rEventPin&nbsp; 等待事件输入的GPIO引脚，每个bit位对应一个引脚，比如P0为0x01，P2为0x04，P15为0x8000。\n\r\n\rEventType&nbsp;&nbsp; 等待件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿。\n\r\n\rTimeOutOfEventMs&nbsp; 等待事件超时时间，单位为毫秒，等待超时后该函数直接返回，不执行任何操作。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2iic.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;IICIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[8];&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[8];&nbsp;&nbsp;   //IIC&nbsp;写读数据。也就是先发送数据，然后再次产生START信号，再读数据&nbsp;&nbsp;   //注意：对于每个I2C设备，必须按照设备要求正确读写，否则可能会导致设备工作不正常，从而导致无法读写数据&nbsp;&nbsp;   WriteBuffer[0]&nbsp;=&nbsp;0x08;&nbsp;&nbsp;   ret&nbsp;=&nbsp;IIC_WriteReadBytesOfEvent(DevHandle,IICIndex,0x50,WriteBuffer,1,ReadBuffer,sizeof(ReadBuffer),0x01,0x10,100);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;IIC_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"WriteRead&nbsp;IIC&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Error&nbsp;Code:%d\\n\",ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"WriteRead&nbsp;IIC&nbsp;IIC_SUCCESS!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;Data:\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;sizeof(ReadBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\r","usb2iic","topics\\函数说明/usb2iic.htm","目录\n\r    概述    LIN_EX_Init    LIN_EX_MasterSync    LIN_EX_MasterWrite    LIN_EX_MasterRead    LIN_EX_SlaveSetIDMode    LIN_EX_SlaveGetIDMode    LIN_EX_SlaveGetData    LIN_EX_MasterStartSch    LIN_EX_MasterStopSch    LIN_EX_MasterGetSch    LIN_EX_CtrlPowerOut    LIN_EX_GetVbatValue\n\r概述&nbsp; \n\r\n\r新版本的USB2LIN接口函数说明，使用这些接口函数需要适配器固件大于或者等v1.5.30，若当前适配器固件版本低于这个版本，请参考《固件升级教程》升级固件。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //定义函数返回错误代码&nbsp;&nbsp;   #define&nbsp;LIN_EX_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;   #define&nbsp;LIN_EX_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp; (-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;   #define&nbsp;LIN_EX_ERR_USB_WRITE_FAIL&nbsp;&nbsp;(-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;   #define&nbsp;LIN_EX_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;   (-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;   #define&nbsp;LIN_EX_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;   #define&nbsp;LIN_EX_ERR_CH_NO_INIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-5)&nbsp;&nbsp;//该通道未初始化&nbsp;&nbsp;   #define&nbsp;LIN_EX_ERR_READ_DATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-6)&nbsp;&nbsp;//LIN读数据失败&nbsp;&nbsp;   #define&nbsp;LIN_EX_ERR_PARAMETER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-7)&nbsp;&nbsp;//函数参数传入有误&nbsp;   //校验类型定义&nbsp;&nbsp;   #define&nbsp;LIN_EX_CHECK_STD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0&nbsp;&nbsp;//标准校验，不含PID&nbsp;&nbsp;   #define&nbsp;LIN_EX_CHECK_EXT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1&nbsp;&nbsp;//增强校验，包含PID&nbsp;&nbsp;   #define&nbsp;LIN_EX_CHECK_USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   2&nbsp;&nbsp;//自定义校验类型，需要用户自己计算并传入Check，不进行自动校验&nbsp;&nbsp;   #define&nbsp;LIN_EX_CHECK_NONE&nbsp;&nbsp;&nbsp;&nbsp;   3&nbsp;&nbsp;//接收数据校验错误&nbsp;&nbsp;   #define&nbsp;LIN_EX_CHECK_ERROR&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;//接收数据校验错误&nbsp;&nbsp;   //校主从机定义&nbsp;&nbsp;&nbsp;   #define&nbsp;LIN_EX_MASTER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1//主机&nbsp;&nbsp;   #define&nbsp;LIN_EX_SLAVE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0//从机&nbsp;&nbsp;   //帧类型定义   #define&nbsp;LIN_EX_MSG_TYPE_UN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0&nbsp;&nbsp;&nbsp;//未知类型&nbsp;&nbsp;   #define&nbsp;LIN_EX_MSG_TYPE_MW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;//主机向从机发送数据&nbsp;&nbsp;   #define&nbsp;LIN_EX_MSG_TYPE_MR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   2&nbsp;&nbsp;&nbsp;//主机从从机读取数据&nbsp;&nbsp;   #define&nbsp;LIN_EX_MSG_TYPE_SW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;//从机发送数据&nbsp;&nbsp;   #define&nbsp;LIN_EX_MSG_TYPE_SR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   4&nbsp;&nbsp;&nbsp;//从机接收数据&nbsp;&nbsp;   #define&nbsp;LIN_EX_MSG_TYPE_BK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   5&nbsp;&nbsp;&nbsp;//只发送BREAK信号，若是反馈回来的数据，表明只检测到BREAK信号&nbsp;&nbsp;   #define&nbsp;LIN_EX_MSG_TYPE_SY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   6&nbsp;&nbsp;&nbsp;//表明检测到了BREAK，SYNC信号&nbsp;&nbsp;   #define&nbsp;LIN_EX_MSG_TYPE_ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   7&nbsp;&nbsp;&nbsp;//表明检测到了BREAK，SYNC，PID信号&nbsp;&nbsp;   #define&nbsp;LIN_EX_MSG_TYPE_DT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   8&nbsp;&nbsp;&nbsp;//表明检测到了BREAK，SYNC，PID,DATA信号&nbsp;&nbsp;   #define&nbsp;LIN_EX_MSG_TYPE_CK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   9&nbsp;&nbsp;&nbsp;//表明检测到了BREAK，SYNC，PID,DATA,CHECK信号&nbsp;&nbsp;   &nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_LIN_EX_MSG{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;Timestamp;&nbsp;&nbsp;&nbsp;&nbsp;//接收数据时代表时间戳，单位为100us，发送数据时代表该帧发送完毕后的延时时间，单位为毫秒&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;MsgType;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//帧类型&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CheckType;&nbsp;&nbsp;&nbsp;//校验类型&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;DataLen;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//LIN数据段有效数据字节数&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;Sync;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;//固定值，0x55&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;PID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//帧ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;Data[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数据&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;Check;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//校验,只有校验数据类型为LIN_EX_CHECK_USER的时候才需要用户传入数据&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;Reserve0;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;Reserve1;&nbsp;&nbsp;   }LIN_EX_MSG,*PLIN_EX_MSG;&nbsp;&nbsp;\n\rLIN_EX_Init \n\r\n\r描述：\n\r\n\r初始化配置USB2LIN适配器。\n\r\n\r原型： \n\r\n\rint&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_Init(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,unsigned&nbsp;int&nbsp;BaudRate,unsigned&nbsp;char&nbsp;MasterMode);&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rLINIndex&nbsp; LIN通道索引号，填0或者1，若只有一个通道LIN，则填0.\n\r\n\rBaudRate&nbsp; LIN通信波特率，填9600,19200,10000,20000等任意值，最大可支持到100000.\n\r\n\rMasterMode&nbsp; 主从机配置，0-初始化为从机，1-初始化为主机（会自动使能LIN总线1K上拉电阻）。\n\r\n\r返回值：\n\r\n\r函数执行状态，0表示函数执行成功，其他值表示函数执行失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2lin_ex.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   int&nbsp;DevHandle[10];&nbsp;&nbsp;   int&nbsp;LINMasterIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;DevIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   bool&nbsp;state;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;   //扫描查找设备&nbsp;&nbsp;   ret&nbsp;=&nbsp;USB_ScanDevice(DevHandle);&nbsp;&nbsp;   if(ret&nbsp;&lt;=&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"No&nbsp;device&nbsp;connected!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;   //打开设备&nbsp;&nbsp;   state&nbsp;=&nbsp;USB_OpenDevice(DevHandle[DevIndex]);&nbsp;&nbsp;   if(!state){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Open&nbsp;device&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;   //初始化配置LIN&nbsp;&nbsp;   ret&nbsp;=&nbsp;LIN_EX_Init(DevHandle[DevIndex],LINMasterIndex,9600,1);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;LIN_EX_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;LIN&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;LIN&nbsp;Success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rLIN_EX_MasterSync\n\r\n\r描述：\n\r\n\r主机模式发送或读取数据。主机通过消息帧的方式收发数据，消息帧类型可以设置为发送BREAK信号（LIN_EX_MSG_TYPE_BK），主机写数据（LIN_EX_MSG_TYPE_MW），主机读数据（LIN_EX_MSG_TYPE_MR）。\n\r\n\r再执行这些消息的时候，适配器会自动监控LIN总线上的数据，然后通过该函数的pOutMsg参数将收到的数据返回上层，上层函数可以对比接收到的数据和发送出去的数据就能判断数据是否成功发送。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_MasterSync(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,LIN_EX_MSG&nbsp;*pInMsg,LIN_EX_MSG&nbsp;*pOutMsg,unsigned&nbsp;int&nbsp;MsgLen);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rLINIndex&nbsp; LIN通道索引号，填0或者1，若只有一个通道LIN，则填0.\n\r\n\rpInMsg&nbsp; 输入的消息帧指针。\n\r\n\rpOutMsg&nbsp; 输出的消息帧指针。\n\r\n\rMsgLen&nbsp; 输入的消息帧数。\n\r\n\r返回值：\n\r\n\r小于0表示函数调用出错，大于0表示接收到LIN总线上数据帧数。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2lin_ex.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   int&nbsp;DevHandle[10];&nbsp;&nbsp;   int&nbsp;LINMasterIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;DevIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   bool&nbsp;state;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;   char&nbsp;*MSGTypeStr[]={\"UN\",\"MW\",\"MR\",\"SW\",\"SR\",\"BK\",\"SY\",\"ID\",\"DT\",\"CK\"};&nbsp;&nbsp;   char&nbsp;*CKTypeStr[]={\"STD\",\"EXT\",\"USER\",\"NONE\",\"ERROR\"};&nbsp;&nbsp;   &nbsp;&nbsp;   LIN_EX_MSG&nbsp;LINMsg[5];&nbsp;&nbsp;   LIN_EX_MSG&nbsp;LINOutMsg[10];&nbsp;&nbsp;   unsigned&nbsp;int&nbsp;MsgLen&nbsp;=&nbsp;5;&nbsp;&nbsp;   LINMsg[0].MsgType&nbsp;=&nbsp;LIN_EX_MSG_TYPE_BK;&nbsp;&nbsp;   LINMsg[0].Timestamp&nbsp;=&nbsp;10;//发送该帧数据之后的延时时间，最小建议设置为1&nbsp;&nbsp;   for(int&nbsp;f=1;f&lt;MsgLen;f++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].MsgType&nbsp;=&nbsp;LIN_EX_MSG_TYPE_MW;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].DataLen&nbsp;=&nbsp;8;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;LINMsg[1].DataLen;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].Data[i]&nbsp;=&nbsp;(f&lt;&lt;4)|i;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].Timestamp&nbsp;=&nbsp;10;//发送该帧数据之后的延时时间，最小建议设置为1&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].CheckType&nbsp;=&nbsp;LIN_EX_CHECK_EXT;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].PID&nbsp;=&nbsp;f+1;&nbsp;&nbsp;   }&nbsp;&nbsp;   &nbsp;&nbsp;   ret&nbsp;=&nbsp;LIN_EX_MasterSync(DevHandle[DevIndex],LINMasterIndex,LINMsg,LINOutMsg,MsgLen,0);&nbsp;&nbsp;   if(ret&nbsp;&lt;&nbsp;LIN_EX_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"MasterSync&nbsp;LIN&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"MsgLen&nbsp;=&nbsp;%d\\n\",ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;ret;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%s&nbsp;SYNC[%02X]&nbsp;PID[%02X]&nbsp;\",MSGTypeStr[LINOutMsg[i].MsgType],LINOutMsg[i].Sync,LINOutMsg[i].PID);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;LINOutMsg[i].DataLen;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",LINOutMsg[i].Data[j]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"[%s][%02X]&nbsp;[%02d:%02d:%02d.%03d]\\n\",CKTypeStr[LINOutMsg[i].CheckType],LINOutMsg[i].Check,(LINOutMsg[i].Timestamp/36000000)%60,(LINOutMsg[i].Timestamp/600000)%60,(LINOutMsg[i].Timestamp/10000)%60,(LINOutMsg[i].Timestamp/10)%1000);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }\n\rLIN_EX_MasterWrite\n\r\n\r描述：\n\r\n\r主机模式发送数据给从机，调用改函数后，适配器会发送同步间隔+0x55+PID+数据+校验到总线上。\n\r\n\r原型： \n\r\n\rint&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_MasterWrite(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,unsigned&nbsp;char&nbsp;PID,unsigned&nbsp;char&nbsp;*pData,unsigned&nbsp;char&nbsp;DataLen,unsigned&nbsp;char&nbsp;CheckType);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rLINIndex&nbsp; LIN通道索引号，填0或者1，若只有一个通道LIN，则填0.\n\r\n\rPID&nbsp; 发送LIN数的ID，只传入低6位ID值即可，底层会自动计算并填充高2位的校验数据，取值范围为0x00~0x3F。\n\r\n\rpData&nbsp; 需要发送数据的指针，最多只能发送8字节数据。\n\r\n\rDataLen&nbsp; 发送数据字节数，最大只能取值8，若设置为0，调用改函数后只发送帧头，校验也不会被发送。\n\r\n\rCheckType&nbsp; 校验类型，0-标准校验，校验不包含PID，1-增强校验，校验包含PID。\n\r\n\r返回值：\n\r\n\r小于0表示函数调用出错，等于0表示函数调用成功。\n\r\n\r示例：LIN_EX_MasterRead\n\r\n\r描述：\n\r\n\r主机模式从从机读取数据，调用该函数后，适配器会发送同步间隔+0x55+PID，然后等待从机返回数据。\n\r\n\r原型： \n\r\n\rint&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_MasterRead(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,unsigned&nbsp;char&nbsp;PID,unsigned&nbsp;char&nbsp;*pData);&nbsp;&nbsp;\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rLINIndex&nbsp; LIN通道索引号，填0或者1，若只有一个通道LIN，则填0.\n\r\n\rPID&nbsp; 发送LIN数的ID，只传入低6位ID值即可，底层会自动计算并填充高2位的校验数据，取值范围为0x00~0x3F。\n\r\n\rpData&nbsp; 存储从机返回数据的数据缓冲区指针，建议将缓冲区空件分配8字节空间。\n\r\n\r返回值：\n\r\n\r小于0表示函数调用出错，大于或者等于0，表示读到的数据字节数。\n\r\n\r示例：LIN_EX_SlaveSetIDMode\n\r\n\r描述：\n\r\n\r从机模式下设置每个ID的操作模式，比如设置为从机接收数据或者从机发送数据。需要监控总线上的数据，可以将所有ID都设置为从机读数据（初始化为从机后默认为该模式）。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_SlaveSetIDMode(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,LIN_EX_MSG&nbsp;*pLINMsg,unsigned&nbsp;int&nbsp;MsgLen);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rLINIndex&nbsp; LIN通道索引号，填0或者1，若只有一个通道LIN，则填0.\n\r\n\rpLINMsg&nbsp; 输入的消息帧指针。\n\r\n\rMsgLen&nbsp; 输入的消息帧数。\n\r\n\r返回值：\n\r\n\r等于0表示函数调用成功，其他值表示函数调用失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2lin_ex.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   int&nbsp;DevHandle[10];&nbsp;&nbsp;   int&nbsp;LINSlaveIndex=&nbsp;0;&nbsp;&nbsp;   int&nbsp;DevIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   bool&nbsp;state;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;   //初始化配置LIN&nbsp;&nbsp;   ret&nbsp;=&nbsp;LIN_EX_Init(DevHandle[DevIndex],LINSlaveIndex,9600,0);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;LIN_EX_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;LIN&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;LIN&nbsp;Success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;   printf(\"Start&nbsp;Get&nbsp;LIN&nbsp;Data...\\n\");&nbsp;&nbsp;   //设置ID为LIN_EX_MSG_TYPE_SW模式，这样主机就可以读取到数据&nbsp;&nbsp;   LIN_EX_MSG&nbsp;LINSlaveMsg[10];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;10;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINSlaveMsg[i].PID&nbsp;=&nbsp;i;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINSlaveMsg[i].CheckType&nbsp;=&nbsp;LIN_EX_CHECK_EXT;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINSlaveMsg[i].DataLen&nbsp;=&nbsp;7;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;LINSlaveMsg[i].DataLen;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LINSlaveMsg[i].Data[j]=(i&lt;&lt;4)|j;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINSlaveMsg[i].MsgType&nbsp;=&nbsp;LIN_EX_MSG_TYPE_SW;//从机发送数据模式&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;LIN_EX_SlaveSetIDMode(DevHandle[DevIndex],LINSlaveIndex,LINSlaveMsg,10);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;LIN_EX_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;LIN&nbsp;ID&nbsp;Mode&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Config&nbsp;LIN&nbsp;ID&nbsp;Mode&nbsp;Success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rLIN_EX_SlaveGetIDMode\n\r\n\r描述：\n\r\n\r从机模式下获取每个ID的操作模式。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_SlaveGetIDMode(   int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,LIN_EX_MSG&nbsp;*pLINMsg);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用 USB_ScanDevice函数获得。\n\r\n\rLINIndex&nbsp; LIN通道索引号，填0或者1，若只有一个通道LIN，则填0.\n\r\n\rpLINMsg&nbsp; 输出的消息帧指针，缓冲区大小不得小于64。\n\r\n\r返回值：\n\r\n\r小于0表示函数调用失败，大于0表示实际获取到的帧数，正常情况洗阿是64，所以在分配帧缓冲区的时候不得小于64。\n\r\n\r示例：LIN_EX_SlaveGetData\n\r\n\r描述：\n\r\n\r从机模式下获取从总线上接收到数据缓冲区中的数据，适配器内部有2个数据接收缓冲区，读取数据之后会自动切换另外一个缓冲区，保证数据不会被冲突。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_SlaveGetData(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,LIN_EX_MSG&nbsp;*pLINMsg);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rLINIndex&nbsp; LIN通道索引号，填0或者1，若只有一个通道LIN，则填0.\n\r\n\rpLINMsg&nbsp; 存储接收到的数据缓冲区指针，建议将缓冲区设置大一点，以免读取到的数据太多导致缓冲区溢出。\n\r\n\r返回值：\n\r\n\r小于0表示函数调用出错，大于0表示接收到LIN总线上数据帧数。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2lin_ex.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   int&nbsp;DevHandle[10];&nbsp;&nbsp;   int&nbsp;LINSlaveIndex=&nbsp;0;&nbsp;&nbsp;   int&nbsp;DevIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   bool&nbsp;state;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;   char&nbsp;*MSGTypeStr[]={\"UN\",\"MW\",\"MR\",\"SW\",\"SR\",\"BK\",\"SY\",\"ID\",\"DT\",\"CK\"};&nbsp;&nbsp;   char&nbsp;*CKTypeStr[]={\"STD\",\"EXT\",\"USER\",\"NONE\",\"ERROR\"};&nbsp;&nbsp;   &nbsp;&nbsp;   //循环获取接收到的数据，该操作可以用作LIN总线数据监控&nbsp;&nbsp;   while(1)&nbsp;&nbsp;   {&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LIN_EX_MSG&nbsp;LINMsg[1024];//缓冲区尽量大一点，防止益处&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ret&nbsp;=&nbsp;LIN_EX_SlaveGetData(DevHandle[DevIndex],LINSlaveIndex,LINMsg);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;ret;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%s&nbsp;SYNC[%02X]&nbsp;PID[%02X]&nbsp;\",MSGTypeStr[LINMsg[i].MsgType],LINMsg[i].Sync,LINMsg[i].PID);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;LINMsg[i].DataLen;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",LINMsg[i].Data[j]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"[%s][%02X]&nbsp;[%02d:%02d:%02d.%03d]\\n\",CKTypeStr[LINMsg[i].CheckType],LINMsg[i].Check,(LINMsg[i].Timestamp/36000000)%60,(LINMsg[i].Timestamp/600000)%60,(LINMsg[i].Timestamp/10000)%60,(LINMsg[i].Timestamp/10)%1000);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;Sleep(1000);&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rLIN_EX_MasterStartSch\n\r\n\r描述：\n\r\n\r主机模式下将调度表放到适配器内部并启动执行调度表，所谓调度表即为主机模式下的数据读写操作列表。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_MasterStartSch(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,LIN_EX_MSG&nbsp;*pLINMsg,unsigned&nbsp;int&nbsp;MsgLen);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rLINIndex&nbsp; LIN通道索引号，填0或者1，若只有一个通道LIN，则填0.\n\r\n\rpLINMsg&nbsp; 待发送的调度表数据缓冲区指针。\n\r\n\r返回值：\n\r\n\r等于0表示函数调用成功，其他值表示函数调用失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2lin_ex.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   LIN_EX_MSG&nbsp;LINMsg[6];&nbsp;&nbsp;   LIN_EX_MSG&nbsp;LINOutMsg[10];&nbsp;&nbsp;   unsigned&nbsp;int&nbsp;MsgLen&nbsp;=&nbsp;6;&nbsp;&nbsp;   LINMsg[0].MsgType&nbsp;=&nbsp;LIN_EX_MSG_TYPE_BK;&nbsp;&nbsp;   LINMsg[0].Timestamp&nbsp;=&nbsp;20;//当前帧发送时，下一帧数据发送的时间间隔，单位为毫秒&nbsp;&nbsp;   for(int&nbsp;f=1;f&lt;MsgLen;f++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].MsgType&nbsp;=&nbsp;LIN_EX_MSG_TYPE_MW;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].DataLen&nbsp;=&nbsp;8;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;LINMsg[1].DataLen;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].Data[i]&nbsp;=&nbsp;(f&lt;&lt;4)|i;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].Timestamp&nbsp;=&nbsp;20+f*10;//当前帧发送时，下一帧数据发送的时间间隔，单位为毫秒&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].CheckType&nbsp;=&nbsp;LIN_EX_CHECK_EXT;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;LINMsg[f].PID&nbsp;=&nbsp;f+1;&nbsp;&nbsp;   }&nbsp;&nbsp;   //ID=6，该帧为主机读数据模式，也就是主机发送帧头，从机返回数据&nbsp;&nbsp;   LINMsg[5].MsgType&nbsp;=&nbsp;LIN_EX_MSG_TYPE_MR;&nbsp;&nbsp;   LINMsg[5].PID&nbsp;=&nbsp;6;&nbsp;&nbsp;   LINMsg[5].Timestamp&nbsp;=&nbsp;20;&nbsp;&nbsp;   //启动调度表&nbsp;&nbsp;   ret&nbsp;=&nbsp;LIN_EX_MasterStartSch(DevHandle[DevIndex],LINMasterIndex,LINMsg,MsgLen);&nbsp;&nbsp;   if(ret&nbsp;&lt;&nbsp;LIN_EX_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Master&nbsp;schedule&nbsp;start&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Master&nbsp;schedule&nbsp;start&nbsp;success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rLIN_EX_MasterStopSch\n\r\n\r描述：\n\r\n\r停止正在自动执行的主机调度表。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_MasterStopSch(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rLINIndex&nbsp; LIN通道索引号，填0或者1，若只有一个通道LIN，则填0.\n\r\n\r返回值：\n\r\n\r小于0表示函数调用出错，大于0表示接收到LIN总线上数据帧数。\n\r\n\r示例：LIN_EX_MasterGetSch\n\r\n\r描述：\n\r\n\r获取调度表数据，比如调度表中有主机读数据的操作，调用该函数可以获取到主机从从机读取到的数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_MasterGetSch(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;LINIndex,LIN_EX_MSG&nbsp;*pLINMsg);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rLINIndex&nbsp; LIN通道索引号，填0或者1，若只有一个通道LIN，则填0.\n\r\n\rpLINMsg&nbsp; 存储接收到的数据缓冲区指针，该缓冲区大小必须大于或者等于启动调度表时传递给适配器的调度表大小，否则可能会出现缓冲区溢出，导致程序异常关闭。\n\r\n\r返回值：\n\r\n\r小于0表示函数调用出错，大于0表示获取到的调度表大小。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2lin_ex.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   //循环获取调度表数据&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;10;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;Sleep(1000);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;LIN_EX_MasterGetSch(DevHandle[DevIndex],LINMasterIndex,LINOutMsg);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if(ret&nbsp;&lt;&nbsp;LIN_EX_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Master&nbsp;get&nbsp;schedule&nbsp;failed!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"[0]MsgLen&nbsp;=&nbsp;%d\\n\",ret);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;ret;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"[0]%s&nbsp;SYNC[%02X]&nbsp;PID[%02X]&nbsp;\",MSGTypeStr[LINOutMsg[i].MsgType],LINOutMsg[i].Sync,LINOutMsg[i].PID);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;LINOutMsg[i].DataLen;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",LINOutMsg[i].Data[j]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rLIN_EX_CtrlPowerOut\n\r\n\r描述：\n\r\n\r控制适配器的电源输出口输出12V的电压，若LIN总线需要其他电平电压，则可以关闭输出，直接将输出电压接口接到外接电源即可。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_CtrlPowerOut(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;State);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rState&nbsp; 电平输出状态，0-禁止输出，当前电压为USB接口电压（5V）；1-输出12V电压\n\r\n\r返回值：\n\r\n\r等于0表示函数调用成功，其他值表示函数调用失败。\n\r\n\r示例：LIN_EX_GetVbatValue\n\r\n\r描述：\n\r\n\r获取电源接口上的电源电压。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;&nbsp;LIN_EX_GetVbatValue(int&nbsp;DevHandle,unsigned&nbsp;short&nbsp;*pBatValue);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rpBatValue&nbsp; 电源电压数据指针，单位为毫伏。\n\r\n\r返回值：\n\r\n\r等于0表示函数调用成功，其他值表示函数调用失败。\n\r\n\r示例：","usb2lin_ex","topics\\函数说明/usb2lin_ex.htm","目录\n\r  概述    PWM_Init    PWM_Start    PWM_SetPulse    PWM_SetPhase    PWM_SetFrequency    PWM_Stop\n\r概述 \n\r\n\rUSB2XXX有8路独立的PWM输出，每路的频率和占空比都可独立调节，最大输出频率可达100MHz,最小频率可达1Hz,占空比调节精度可自己设定，脉冲极性可调。\n\r\n\r可以在输出PWM的同时调整PWM占空比和频率。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //定义初始化PWM的数据类型&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_PWM_CONFIG{&nbsp;&nbsp;   &nbsp;&nbsp;unsigned&nbsp;short&nbsp;Prescaler[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //预分频器&nbsp;&nbsp;   &nbsp;&nbsp;unsigned&nbsp;short&nbsp;Precision[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//占空比调节精度,实际频率&nbsp;=&nbsp;200MHz/(Prescaler*Precision)&nbsp;&nbsp;   &nbsp;&nbsp;unsigned&nbsp;short&nbsp;Pulse[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//占空比，实际占空比=(Pulse/Precision)*100%&nbsp;&nbsp;   &nbsp; unsigned&nbsp;short&nbsp;Phase[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//波形相位，取值0到Precision-1   &nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;Polarity[8];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //波形极性，取值0或者1&nbsp;&nbsp;   &nbsp;&nbsp;unsigned&nbsp;char&nbsp;&nbsp;ChannelMask;&nbsp;&nbsp;&nbsp;&nbsp;//通道号，若要使能某个通道，则对应位为1，最低位对应通道0&nbsp;&nbsp;   }PWM_CONFIG,*PPWM_CONFIG;&nbsp;&nbsp;   &nbsp;&nbsp;   //定义函数返回错误代码&nbsp;&nbsp;   #define&nbsp;PWM_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;   #define&nbsp;PWM_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;   #define&nbsp;PWM_ERR_USB_WRITE_FAIL&nbsp;&nbsp;   (-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;   #define&nbsp;PWM_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;&nbsp;   (-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;   #define&nbsp;PWM_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;\n\rPWM_Init\n\r\n\r描述： \n\r\n\r初始化配置PWM通道，在启动PWM之前，该函数必须调用。\n\r\n\r\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;PWM_Init(int&nbsp;DevHandle,&nbsp;PPWM_CONFIG&nbsp;pConfig);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rpConfig&nbsp; PWM初始化参数结构体指针。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2pwm.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   //配置PWM相关参数并初始化PWM&nbsp;&nbsp;   PWM_CONFIG&nbsp;PWMConfig;&nbsp;&nbsp;   PWMConfig.ChannelMask&nbsp;=&nbsp;0xFF;//初始化所有通道&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;8;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;PWMConfig.Polarity[i]&nbsp;=&nbsp;1;//将所有PWM通道都设置为正极性&nbsp;&nbsp;   }&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;8;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;PWMConfig.Precision[i]&nbsp;=&nbsp;100;//将所有通道的占空比调节精度都设置为1%&nbsp;&nbsp;   }&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;8;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;PWMConfig.Phase[i]&nbsp;=&nbsp;0;//将所有通道的相位都设置为0   }&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;8;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;PWMConfig.Prescaler[i]&nbsp;=&nbsp;10;//将所有通道的预分频器都设置为10，则PWM输出频率为200MHz/(PWMConfig.Precision*PWMConfig.Prescaler)&nbsp;&nbsp;   }&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;8;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;PWMConfig.Pulse[i]&nbsp;=&nbsp;PWMConfig.Precision[i]*30/100;//将所有通道的占空比都设置为30%&nbsp;&nbsp;   }&nbsp;&nbsp;   //初始化PWM&nbsp;&nbsp;   ret&nbsp;=&nbsp;PWM_Init(DevHandle,&amp;PWMConfig);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;PWM_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Initialize&nbsp;pwm&nbsp;faild!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Initialize&nbsp;pwm&nbsp;sunccess!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rPWM_Start\n\r\n\r描述： \n\r\n\r启动已经初始化的PWM通道，使之输出PWM方波。\n\r\n\r\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;PWM_Start(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;ChannelMask,unsigned&nbsp;int&nbsp;RunTimeUs);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rChannelMask&nbsp; 需要输出波形的通道号，每个bit位代表一个通道，bit0对应PWM_CH0，对应位为1，该通道输出波形。\n\r\n\rRunTimeUs&nbsp; 输出波形的时间，单位为微妙，启动波形输出之后，RunTimeOfUs微妙之后会停止波形输出，该参数为0，波形会一直输出，直到手动停止，利用该参数可以控制脉冲输出个数。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2pwm.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   //启动PWM,RunTimeUs之后自动停止，利用该特性可以控制输出脉冲个数，脉冲个数=RunTimeUs*200/(PWMConfig.Precision*PWMConfig.Prescaler)&nbsp;&nbsp;   unsigned&nbsp;int&nbsp;RunTimeUs&nbsp;=&nbsp;10000;&nbsp;&nbsp;   ret&nbsp;=&nbsp;PWM_Start(DevHandle,PWMConfig.ChannelMask,RunTimeUs);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;PWM_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;pwm&nbsp;faild!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;pwm&nbsp;sunccess!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rPWM_SetPulse\n\r\n\r描述： \n\r\n\r设置PWM波占空比，该函数可以在PWM启动之后调用，以便动态改变PWM波形输出占空比。\n\r\n\r\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;PWM_SetPulse(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;ChannelMask,unsigned&nbsp;short&nbsp;*pPulse);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rChannelMask&nbsp; 需要输出波形的通道号，每个bit位代表一个通道，bit0对应PWM_CH0，对应位为1，该通道输出波形。\n\r\n\rpPulse&nbsp; 波形占空比调节参数首地址。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2pwm.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   //启动PWM,RunTimeUs之后自动停止，利用该特性可以控制输出脉冲个数，脉冲个数=RunTimeUs*200/(PWMConfig.Precision*PWMConfig.Prescaler)&nbsp;&nbsp;   unsigned&nbsp;int&nbsp;RunTimeUs&nbsp;=&nbsp;10000;&nbsp;&nbsp;   ret&nbsp;=&nbsp;PWM_Start(DevHandle,PWMConfig.ChannelMask,RunTimeUs);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;PWM_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;pwm&nbsp;faild!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;pwm&nbsp;sunccess!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;   //改变PWM波形占空比&nbsp;&nbsp;   uint16_t&nbsp;Plse[8];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;100;i+=5){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;8;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plse[j]&nbsp;=&nbsp;i;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;ret&nbsp;=&nbsp;PWM_SetPulse(DevHandle,PWMConfig.ChannelMask,Plse);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if(ret&nbsp;!=&nbsp;PWM_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;pwm&nbsp;faild!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rPWM_SetPhase\n\r\n\r描述： \n\r\n\r设置PWM相位，也就是设置PWM计数器的初始值。在PWM频率比较大的时候，设置的参数可能跟实际输出的值误差较大，建议根据实际输出值对该参数进行调整。\n\r\n\r\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;PWM_SetPhase(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;ChannelMask,unsigned&nbsp;short&nbsp;*pPhase);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rChannelMask&nbsp; 需要输出波形的通道号，每个bit位代表一个通道，bit0对应PWM_CH0，若对应位为1，则设置该通道的相位参数，否则不设置。\n\r\n\rpPhase&nbsp; 波形相位参数首地址。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2pwm.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   //启动PWM,RunTimeUs之后自动停止，利用该特性可以控制输出脉冲个数，脉冲个数=RunTimeUs*200/(PWMConfig.Precision*PWMConfig.Prescaler)&nbsp;&nbsp;   unsigned&nbsp;int&nbsp;RunTimeUs&nbsp;=&nbsp;10000;&nbsp;&nbsp;   ret&nbsp;=&nbsp;PWM_Start(DevHandle,PWMConfig.ChannelMask,RunTimeUs);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;PWM_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;pwm&nbsp;faild!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;pwm&nbsp;sunccess!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;   //改变PWM波形相位差&nbsp;   uint16_t&nbsp;Phase[8];&nbsp;&nbsp;   for(int&nbsp;j=0;j&lt;8;j++){&nbsp;&nbsp;   &nbsp;&nbsp;Phase[j]&nbsp;=&nbsp;j*10;&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;PWM_SetPhase(DevHandle,PWMConfig.ChannelMask,Phase);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;PWM_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Set pwm&nbsp;phase faild!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;&nbsp;&nbsp;   }&nbsp;&nbsp; \n\r\n\r\n\rPWM_SetFrequency\n\r\n\r描述： \n\r\n\r设置PWM频率，该函数可以在PWM启动之后调用，以便动态改变PWM波形输出频率。频率改变后，占空比保持不变（若改变了占空比精度，可能占空比会有很小的变动），PWM输出频率=200MHz/(Prescaler*Precision)。\n\r\n\r\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;PWM_SetFrequency(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;ChannelMask,unsigned&nbsp;short&nbsp;*pPrescaler,unsigned&nbsp;short&nbsp;*pPrecision);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rChannelMask&nbsp; 需要输出波形的通道号，每个bit位代表一个通道，bit0对应PWM_CH0，对应位为1，该通道输出波形。\n\r\n\rpPrescaler&nbsp; PWM时钟预分频器参数指针。\n\r\n\rpPrecision&nbsp; PWM占空比精度调节参数指针。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2pwm.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   //启动PWM,RunTimeUs之后自动停止，利用该特性可以控制输出脉冲个数，脉冲个数=RunTimeUs*200/(PWMConfig.Precision*PWMConfig.Prescaler)&nbsp;&nbsp;   unsigned&nbsp;int&nbsp;RunTimeUs&nbsp;=&nbsp;10000;&nbsp;&nbsp;   ret&nbsp;=&nbsp;PWM_Start(DevHandle,PWMConfig.ChannelMask,RunTimeUs);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;PWM_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;pwm&nbsp;faild!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Start&nbsp;pwm&nbsp;sunccess!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;   //改变PWM波形输出频率&nbsp;&nbsp;   uint16_t&nbsp;Precision[8];&nbsp;&nbsp;   uint16_t&nbsp;&nbsp;Prescaler[8];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;8;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;Prescaler[i]&nbsp;=&nbsp;2;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;Precision[i]&nbsp;=&nbsp;100;&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;PWM_SetFrequency(DevHandle,PWMConfig.ChannelMask,Prescaler,Precision);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;PWM_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Set&nbsp;frequency&nbsp;faild!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rPWM_Stop\n\r\n\r描述： \n\r\n\r停止PWM通道输出PWM波形。\n\r\n\r\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;PWM_Stop(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;ChannelMask);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rChannelMask&nbsp; 需要输出波形的通道号，每个bit位代表一个通道，bit0对应PWM_CH0，对应位为1，该通道输出波形。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2pwm.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   ret&nbsp;=&nbsp;PWM_Stop(DevHandle,PWMConfig.ChannelMask);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;PWM_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Stop&nbsp;pwm&nbsp;faild!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ret;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Stop&nbsp;pwm&nbsp;sunccess!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\r","usb2pwm","topics\\函数说明/usb2pwm.htm","目录\n\r  概述   SNIFFER_Init  SNIFFER_StartRead  SNIFFER_StopRead  SNIFFER_WriteData  SNIFFER_ReadData  SNIFFER_ContinueWriteData  SNIFFER_ChangeContinueWriteData  SNIFFER_StopContinueWrite\n\r概述&nbsp;\n\r\n\r本文主要介绍关于USB2XXX的并口操作相关函数，也就是读写控制D0到D7接口的函数，利用并口操作函数可以快速的读写控制并口，并口最大读写速度可达25MBye/s。\n\r\n\r在写数据的时候，CE和WE会自动变低电平，数据写完毕之后自动变高电平，在读数据的时候，CE和RE自动变低电平，数据读完毕之后自动变高电平。\n\r\n\r在调用这些函数前需要调用设备操作相关函数，比如扫描设备，打开设备等，详情请查看《设备操作相关函数说明》。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //定义函数返回错误代码&nbsp;&nbsp;  #define&nbsp;SNIFFER_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp; (0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;  #define&nbsp;SNIFFER_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;  #define&nbsp;SNIFFER_ERR_USB_WRITE_FAIL&nbsp;&nbsp;   (-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;   #define&nbsp;SNIFFER_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;&nbsp;   (-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;   #define&nbsp;SNIFFER_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;   #define&nbsp;SNIFFER_ERR_EVENT_TIMEOUT&nbsp;&nbsp;&nbsp;&nbsp;   (-5)&nbsp;&nbsp;//事件发送超时&nbsp;&nbsp;   &nbsp;&nbsp;   #define&nbsp;SNIFFER_SAMPLE_MODE_1CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)&nbsp;&nbsp;   #define&nbsp;SNIFFER_SAMPLE_MODE_2CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)&nbsp;&nbsp;   #define&nbsp;SNIFFER_SAMPLE_MODE_4CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4)&nbsp;&nbsp;   #define&nbsp;SNIFFER_SAMPLE_MODE_8CH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(8)&nbsp;&nbsp;   &nbsp;&nbsp;   #define&nbsp;SNIFFER_READ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(0)&nbsp;&nbsp;   #define&nbsp;SNIFFER_WRITE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)&nbsp;&nbsp;   &nbsp;&nbsp;   //定义从机模式下连续读取数据的回调函数&nbsp;&nbsp;   typedef&nbsp;&nbsp;int&nbsp;(WINAPI&nbsp;SNIFFER_GET_DATA_HANDLE)(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;*pData,int&nbsp;DataNum);//接收数据回掉函数&nbsp;&nbsp;\n\rSNIFFER_Init\n\r\n\r描述：\n\r\n\r初始化配置并口，配置其读写速度，读写模式，采样模式等。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SNIFFER_Init(int&nbsp;DevHandle,char&nbsp;WriteFlag,unsigned&nbsp;int&nbsp;SampleRateHz,char&nbsp;SampleMode);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rWriteFlag&nbsp; 配置并口是都操作还是写操作，0-读操作，1-写操作。\n\r\n\rSampleRateHz&nbsp; 读写操作并口的频率，单位为Hz，只能在以下几个值间进行选择：25000000，20000000，10000000，5000000，2500000，1000000，700000。\n\r\n\rSampleMode&nbsp; 配置并口采集位数，1-1bit，2-2bit，4-4bit，8-8bit，一般传入8即可，也就是采集8bit，1字节数据，该参数只有在读操作时有效。\n\r\n\r返回值：\n\r\n\r配置并口状态，0-配置成功，其他值配置失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2sniffer.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   //配置并口为读数据模式,每次采集1字节数据，数据读取速率为5MByte/s&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_Init(DevHandle,0,5000000,8);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;printf(\"初始化配置并口失败!\\n\");&nbsp;&nbsp;   &nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSNIFFER_StartRead\n\r\n\r描述：\n\r\n\r启动并口连续读取数据，读取到的数据通过回调函数方式传出。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SNIFFER_StartRead(int&nbsp;DevHandle,SNIFFER_GET_DATA_HANDLE&nbsp;*pGetDataHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rpGetDataHandle&nbsp; 读到数据后的回掉函数，必须传入有效的回调函数，否则无法获取到并口读到的数据。\n\r\n\r返回值：\n\r\n\r启动并口读数据状态，0-启动成功，其他值，启动失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2sniffer.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   //此处为接收数据回调函数，在这里处理接收到的数据&nbsp;&nbsp;   void&nbsp;SnifferGetData(int&nbsp;DeviceIndex,unsigned&nbsp;char&nbsp;*pData,int&nbsp;DataNum)&nbsp;&nbsp;   {&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"获取到%d字节数据\\n\",DataNum);&nbsp;&nbsp;   }&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   //启动sniffer并注册回调函数&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_StartRead(DevHandle,SnifferGetData);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"启动并口读数据失败!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"启动并口读数据成功!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSNIFFER_StopRead\n\r\n\r描述：\n\r\n\r停止并口连续读取数据。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SNIFFER_StopRead(int&nbsp;DevHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\r返回值：\n\r\n\r停止读数据状态，0-停止成功，其他值，停止读数据出错。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2sniffer.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   //停止并口读数据操作&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_StopRead(DevHandle);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;printf(\"停止并口读操作失败!\\n\");&nbsp;&nbsp;   &nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSNIFFER_WriteData\n\r\n\r描述：\n\r\n\r将数据通过并口发送出去，数据发送频率为SNIFFER_Init函数的SampleRateHz参数设置值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SNIFFER_WriteData(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rpWriteData&nbsp; 待发送的数据存储缓冲区指针。\n\r\n\rWriteLen&nbsp; 待发送的数据字节数。\n\r\n\r返回值：\n\r\n\r并口写数据状态，0-写数据成功，其他值，写数据失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2sniffer.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;DataNum;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;&nbsp;ret;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[10240];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   //配置sniffer&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_Init(DevHandle,1,20000000);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Init&nbsp;sniffer&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;   //并口写数据&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_WriteData(DevHandle,WriteBuffer,sizeof(WriteBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;write&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;write&nbsp;success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSNIFFER_ReadData\n\r\n\r描述：\n\r\n\r直接通过并口读取数据，数据读取频率为SNIFFER_Init函数的SampleRateHz参数设置值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SNIFFER_ReadData(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rpReadData&nbsp; 存储读取数据的存储缓冲区指针。\n\r\n\rReadLen&nbsp; 待读取的数据字节数。\n\r\n\r返回值：\n\r\n\r并口写数据状态，0-读数据成功，其他值，写数据失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2sniffer.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;DataNum;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;&nbsp;ret;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[10240];&nbsp;&nbsp;   //配置sniffer&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_Init(DevHandle,0,20000000,8);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Init&nbsp;sniffer&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;   //并口读数据&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_ReadData(DevHandle,ReadBuffer,sizeof(ReadBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;read&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;read&nbsp;success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSNIFFER_ContinueWriteData\n\r\n\r描述：\n\r\n\r并口连续模式写数据，调用该函数后，数据存放到USB2XXX内部数据缓冲区，然后数据通过并口循环发送出去，直到调用停止写数据函数为止。数据发送频率为SNIFFER_Init函数中的SampleRateHz参数值。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SNIFFER_ContinueWriteData(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rpWriteData&nbsp; 待发送的数据存储缓冲区指针。\n\r\n\rWriteLen&nbsp; 待发送的数据字节数。\n\r\n\r返回值：\n\r\n\r并口写数据状态，0-写数据成功，其他值，写数据失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2sniffer.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;DataNum;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;&nbsp;ret;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[10240];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   //配置sniffer&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_Init(DevHandle,1,20000000,8);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Init&nbsp;sniffer&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;   //并口连续写数据，并口将缓冲区中的数据循环发送&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_ContinueWriteData(DevHandle,WriteBuffer,sizeof(WriteBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;continue&nbsp;write&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;continue&nbsp;write&nbsp;success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSNIFFER_ChangeContinueWriteData\n\r\n\r描述：\n\r\n\r更改连续写数据模式下适配器内部数据缓冲区中的数据。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SNIFFER_ChangeContinueWriteData(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\rpWriteData&nbsp; 待发送的数据存储缓冲区指针。\n\r\n\rWriteLen&nbsp; 待发送的数据字节数。\n\r\n\r返回值：\n\r\n\r并口写数据状态，0-写数据成功，其他值，写数据失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2sniffer.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;DataNum;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;&nbsp;ret;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[10240];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   //配置sniffer&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_Init(DevHandle,1,20000000,8);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Init&nbsp;sniffer&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;   //并口连续写数据，并口将缓冲区中的数据循环发送&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_ContinueWriteData(DevHandle,WriteBuffer,sizeof(WriteBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;continue&nbsp;write&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;continue&nbsp;write&nbsp;success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;   //更改连续发送数据缓冲区中的数据   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i+1;&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_ChangeContinueWriteData(DevHandle,WriteBuffer,sizeof(WriteBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;continue&nbsp;write&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;continue&nbsp;write&nbsp;success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSNIFFER_StopContinueWrite\n\r\n\r描述：\n\r\n\r停止并口连续写数据。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SNIFFER_StopContinueWrite(int&nbsp;DevHandle);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice函数获得。\n\r\n\r返回值：\n\r\n\r并口写数据状态，0-写数据成功，其他值，写数据失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2sniffer.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;DataNum;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   int&nbsp;&nbsp;ret;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[10240];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   //配置sniffer&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_Init(DevHandle,1,20000000,8);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Init&nbsp;sniffer&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;   //并口连续写数据，并口将缓冲区中的数据循环发送&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_ContinueWriteData(DevHandle,WriteBuffer,sizeof(WriteBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;continue&nbsp;write&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Sniffer&nbsp;continue&nbsp;write&nbsp;success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;   //写5秒钟的数据&nbsp;&nbsp;   Sleep(5000);&nbsp;&nbsp;   //停止循环发送数据&nbsp;&nbsp;   ret&nbsp;=&nbsp;SNIFFER_StopContinueWrite(DevHandle);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SNIFFER_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Stop&nbsp;continue&nbsp;write&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Stop&nbsp;continue&nbsp;write&nbsp;success!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\r","usb2sniffer","topics\\函数说明/usb2sniffer.htm","目录\n\r  概述  SPI_Init  SPI_WriteBytes  SPI_WriteBytesAsync  SPI_ReadBytes  SPI_WriteReadBytes  SPI_WriteBytesOfEvent  SPI_ReadBytesOfEvent  SPI_WriteReadBytesOfEvent  SPI_WriteBits  SPI_ReadBits  SPI_WriteReadBits  SPI_SlaveWriteBytes  SPI_SlaveReadBytes  SPI_SlaveReadWriteBytes  SPI_SlaveWriteReadBytes  SPI_SlaveContinueRead  SPI_SlaveGetBytes  SPI_SlaveContinueWriteReadStop  SPI_SlaveContinueWrite  SPI_FlashInit  SPI_FlashReadID  SPI_FlashEraseSector  SPI_FlashEraseChip  SPI_FlashWrite  SPI_FlashRead  SPI_FlashReadFast  SPI_BlockWriteBytes  SPI_BlockReadBytes  SPI_BlockWriteReadBytes  SPI_BlockWriteBytesOfEvent  SPI_BlockReadBytesOfEvent  SPI_BlockWriteReadBytesOfEvent\n\r概述&nbsp;\n\r\n\r本文主要介绍关于USB2XXX的SPI操作相关函数，在调用这些函数前需要调用设备操作相关函数，比如扫描设备，打开设备等，详情请查看《设备操作相关函数说明》。\n\r\n\r下面是本文函数可能会用到的一些宏定义：\n\r  //定义SPI通道&nbsp;&nbsp;   #define&nbsp;SPI1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (0x00)&nbsp;&nbsp;   #define&nbsp;SPI1_CS0&nbsp;&nbsp;&nbsp;&nbsp;(0x00)&nbsp;&nbsp;   #define&nbsp;SPI1_CS1&nbsp;&nbsp;&nbsp;&nbsp;(0x10)&nbsp;&nbsp;   #define&nbsp;SPI1_CS2&nbsp;&nbsp;&nbsp;&nbsp;(0x20)&nbsp;&nbsp;   #define&nbsp;SPI1_CS3&nbsp;&nbsp;&nbsp;&nbsp;(0x30)&nbsp;&nbsp;   #define&nbsp;SPI1_CS4&nbsp;&nbsp;&nbsp;&nbsp;(0x40)&nbsp;&nbsp;   &nbsp;&nbsp;   #define&nbsp;SPI2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(0x01)&nbsp;&nbsp;   #define&nbsp;SPI2_CS0&nbsp;&nbsp;&nbsp;&nbsp;(0x01)&nbsp;&nbsp;   #define&nbsp;SPI2_CS1&nbsp;&nbsp;&nbsp;&nbsp;(0x11)&nbsp;&nbsp;   #define&nbsp;SPI2_CS2&nbsp;&nbsp;&nbsp;&nbsp;(0x21)&nbsp;&nbsp;   #define&nbsp;SPI2_CS3&nbsp;&nbsp;&nbsp;&nbsp;(0x31)&nbsp;&nbsp;   #define&nbsp;SPI2_CS4&nbsp;&nbsp;&nbsp;&nbsp;(0x41)&nbsp;&nbsp;   //定义工作模式&nbsp;&nbsp;   #define&nbsp;SPI_MODE_HARD_FDX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0&nbsp;//硬件控制（全双工模式）&nbsp;&nbsp;   #define&nbsp;SPI_MODE_HARD_HDX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1&nbsp;//硬件控制（半双工模式）&nbsp;&nbsp;   #define&nbsp;SPI_MODE_SOFT_HDX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   2&nbsp;//软件控制（半双工模式）&nbsp;&nbsp;   #define&nbsp;SPI_MODE_SOFT_ONE_WIRE&nbsp;&nbsp;   3&nbsp;//单总线模式，数据线输入输出都为MOSI&nbsp;&nbsp;   #define&nbsp;SPI_MODE_SOFT_FDX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   4&nbsp;//软件控制（全双工模式）&nbsp;&nbsp;   //定义主从机模式&nbsp;&nbsp;   #define&nbsp;SPI_MASTER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;//主机&nbsp;&nbsp;   #define&nbsp;SPI_SLAVE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0&nbsp;//从机&nbsp;&nbsp;   //定义数据移位方式&nbsp;&nbsp;   #define&nbsp;SPI_MSB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;//高位在前&nbsp;&nbsp;   #define&nbsp;SPI_LSB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   1&nbsp;//低位在前&nbsp;&nbsp;   //定义片选输出极性&nbsp;&nbsp;   #define&nbsp;SPI_SEL_LOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;//片选输出低电平&nbsp;&nbsp;   #define&nbsp;SPI_SEL_HIGH&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;//片选输出高电平&nbsp;&nbsp;   &nbsp;&nbsp;   //定义EVENT引脚,注意EVENT引脚不要跟SPI通信引脚冲突&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P0&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;0)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P1&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;1)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P2&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;2)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P3&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;3)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P4&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;4)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P5&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;5)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P6&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;6)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P7&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;7)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P8&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;8)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P9&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;9)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P10&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;10)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P11&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;11)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P12&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;12)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P13&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;13)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P14&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;14)&nbsp;&nbsp;   #define&nbsp;SPI_EVENT_P15&nbsp;&nbsp;&nbsp;&nbsp;(1&lt;&lt;15)&nbsp;&nbsp;   &nbsp;&nbsp;   //定义事件类型&nbsp;&nbsp;   #define&nbsp;EVENT_TYPE_LOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0x00&nbsp;&nbsp;   #define&nbsp;EVENT_TYPE_HIGH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0x11&nbsp;&nbsp;   #define&nbsp;EVENT_TYPE_RISING&nbsp;&nbsp;&nbsp;   0x01&nbsp;&nbsp;   #define&nbsp;EVENT_TYPE_FALLING&nbsp;&nbsp;0x10&nbsp;&nbsp;   &nbsp;&nbsp;   //定义从机模式下连续读取数据的回调函数&nbsp;&nbsp;   typedef&nbsp;&nbsp;int&nbsp;(WINAPI&nbsp;*PSPI_GET_DATA_HANDLE)(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pData,int&nbsp;DataNum);//接收数据回掉函数&nbsp;&nbsp;   &nbsp;&nbsp;   //定义初始化SPI的数据类型&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_SPI_CONFIG{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;Mode;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//SPI控制方式:0-硬件控制（全双工模式）,1-硬件控制（半双工模式），2-软件控制（半双工模式）,3-单总线模式，数据线输入输出都为MOSI,4-软件控制（全双工模式）&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;Master;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//主从选择控制:0-从机，1-主机&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;CPOL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//时钟极性控制:0-SCK空闲时为低电平，1-SCK空闲时为高电平&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;CPHA;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//时钟相位控制:0-第一个SCK时钟采样，1-第二个SCK时钟采样&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;LSBFirst;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数据移位方式:0-MSB在前，1-LSB在前&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;SelPolarity;&nbsp;&nbsp;&nbsp;&nbsp;//片选信号极性:0-低电平选中，1-高电平选中&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;int&nbsp;ClockSpeedHz;&nbsp;&nbsp;&nbsp;&nbsp;//SPI时钟频率:单位为HZ，硬件模式下最大50000000，最小390625，频率按2的倍数改变&nbsp;&nbsp;   }SPI_CONFIG,*PSPI_CONFIG;&nbsp;&nbsp;   &nbsp;&nbsp;   //定义SPI&nbsp;Flash器件配置参数数据类型&nbsp;&nbsp;   typedef&nbsp;struct&nbsp;_SPI_FLASH_CONFIG{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CMD_WriteEnable;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使能写命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CMD_WriteDisable;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//禁止写命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CMD_WritePage;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//写数据命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;WritePageAddressBytes;&nbsp;&nbsp;&nbsp;&nbsp;//写数据时的地址宽度，单位为字节&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CMD_EraseSector;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//扇区擦出命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;EraseSectorAddressBytes;&nbsp;&nbsp;//扇区擦出的地址宽度，单位为字节&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CMD_EraseBulk;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//块擦出命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CMD_EraseChip;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//整片擦出命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CMD_ReadID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//读芯片ID命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CMD_ReadData;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//读数据命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;ReadDataAddressBytes;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//读数据时的地址宽度，单位为字节&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CMD_ReadFast;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//快速模式读数据命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;ReadFastAddressBytes;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//快速读数据时的地址宽度，单位为字节&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CMD_ReadStatus;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//读取状态寄存器命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;CMD_WriteStatus;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//写状态寄存器命令&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;ID[16];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//芯片ID存储数组&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;ID_Length;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;//ID长度，单位为字节&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;PageSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//页大小，单位为字节&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;NumPages;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//芯片总的页数&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;SectorSize;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//扇区大小，单位为字节&nbsp;&nbsp;   }SPI_FLASH_CONFIG,*PSPI_FLASH_CONFIG;&nbsp;&nbsp;   &nbsp;&nbsp;   //定义函数返回错误代码&nbsp;&nbsp;   #define&nbsp;SPI_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;   #define&nbsp;SPI_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;   #define&nbsp;SPI_ERR_USB_WRITE_FAIL&nbsp;&nbsp;(-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;   #define&nbsp;SPI_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;   (-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;   #define&nbsp;SPI_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   (-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;   #define&nbsp;SPI_ERR_PARAMETER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-5)&nbsp;&nbsp;//参数错误&nbsp;&nbsp;   #define&nbsp;SPI_ERR_EVENT_TIMEOUT&nbsp;&nbsp;&nbsp;(-6)&nbsp;&nbsp;//检测Event超时&nbsp;&nbsp;\n\rSPI_Init\n\r\n\r描述：\n\r\n\r初始化配置USB2SPI适配器。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_Init(int&nbsp;DevHandle,int&nbsp;SPIIndex,&nbsp;PSPI_CONFIG&nbsp;pConfig);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，从机模式下只能用SPI1_CS0或SPI2_CS0，主机模式下可以使用SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpConfig&nbsp; 初始化配置结构体指针，具体取值说明见文章开头的说明。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   //配置SPI总线相关参数&nbsp;&nbsp;&nbsp;   SPIConfig.Mode&nbsp;=&nbsp;0;&nbsp;&nbsp;   SPIConfig.ClockSpeedHz&nbsp;=&nbsp;25000000;&nbsp;&nbsp;   SPIConfig.CPHA&nbsp;=&nbsp;0;&nbsp;&nbsp;   SPIConfig.CPOL&nbsp;=&nbsp;0;&nbsp;&nbsp;   SPIConfig.LSBFirst&nbsp;=&nbsp;0;&nbsp;&nbsp;   SPIConfig.Master&nbsp;=&nbsp;1;&nbsp;&nbsp;   SPIConfig.SelPolarity&nbsp;=&nbsp;0;&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_Init(DevHandle,SPIIndex,&amp;SPIConfig);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"初始化配置USB2SPI适配器失败!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_WriteBytes\n\r\n\r描述：\n\r\n\r主机模式下SPI发送数据，该函数必须等到SPI数据发送完毕之后才会返回，对于SPI时钟频率较低，单次发送的数据量较大的情况，函数执行时间可能会比较长。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_WriteBytes(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle &nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex &nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpWriteData &nbsp; 待发送的数据缓冲区指针。\n\r\n\rWriteLen &nbsp; 待发送的数据字节数，单次发送的数据不能超过20*1024字节。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   //SPI发送数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_WriteBytes(DevHandle,SPIIndex,WriteBuffer,sizeof(WriteBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"SPI发送数据失败!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_WriteBytesAsync\n\r\n\r描述：\n\r\n\r主机异步模式下发送数据，调用该函数后，数据会传递到适配器内部数据缓冲区中，然后启动DMA开始数据传输，函数返回。下一次再次调用该函数的时候，数据会发送到适配器内部数据缓冲区，然后先判断上一次的数据是否发送完毕，若已经发送完毕则再次启动DMA开始数据传输，函数返回。\n\r\n\r使用该函数可以最大速度输出SPI数据，适配器接收数据是采用的双缓区方式，所以不用担心数据被覆盖。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_WriteBytesAsync(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpWriteData&nbsp; 待发送的数据缓冲区指针。\n\r\n\rWriteLen&nbsp; 待发送的数据字节数，单次发送的数据不能超过20*1024字节。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   //SPI发送数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_WriteBytesAsync(DevHandle,SPIIndex,WriteBuffer,sizeof(WriteBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"SPI发送数据失败!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_ReadBytes\n\r\n\r描述：\n\r\n\r主机模式下读取数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_ReadBytes(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpReadData&nbsp; 待接收的数据缓冲区指针。\n\r\n\rReadLen&nbsp; 接收数据字节数，单次接收的数据数不能超过20*1024字节。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   //SPI接收数据&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_ReadBytes(DevHandle,SPIIndex,ReadBuffer,sizeof(ReadBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"SPI接收数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;Data:\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;sizeof(ReadBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(((i+1)%16)==0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_WriteReadBytes\n\r\n\r描述：\n\r\n\r主机模式发送接收数据，半双工模式下，先发送数据，然后再接收数据。全双工模式下发送数据和接收数据同时进行。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_WriteReadBytes(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen,int&nbsp;IntervalTimeUs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpWriteData&nbsp; 待发送的数据缓冲区指针。\n\r\n\rWriteLen&nbsp; 待发送的数据字节数，单次发送的数据不能超过20*1024字节。\n\r\n\rpReadData&nbsp; 待接收的数据缓冲区指针。\n\r\n\rReadLen&nbsp; 接收数据字节数，单次接收的数据数不能超过20*1024字节。\n\r\n\rIntervalTimeUs&nbsp; 半双工模式下，发送数据和接收数据之间的时间间隔，单位为微秒(us)。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   //SPI待发送的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   //SPI发送接收数据&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_WriteReadBytes(DevHandle,SPIIndex,WriteBuffer,sizeof(WriteBuffer),ReadBuffer,sizeof(ReadBuffer),500);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"SPI发送接收数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;Data:\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;sizeof(ReadBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(((i+1)%16)==0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_WriteBytesOfEvent\n\r\n\r描述：\n\r\n\r主机模式SPI事件发送数据，该函数必须等到指定引脚发生指定事件之后才进行SPI数据发送操作，若SPI时钟频率较低，单次发送的数据量较大的情况，函数执行时间可能会比较长。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_WriteBytesOfEvent(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen,int&nbsp;EventPin,unsigned&nbsp;char&nbsp;EventType,int&nbsp;TimeOutOfMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpWriteData&nbsp; 待发送的数据缓冲区指针。\n\r\n\rWriteLen&nbsp; 待发送的数据字节数，单次发送的数据不能超过20*1024字节。\n\r\n\rEventPin&nbsp; 等待事件输入的GPIO引脚，每个bit位对应一个引脚，比如P0为0x01，P2为0x04，P15为0x8000。\n\r\n\rEventType&nbsp;&nbsp; 等待件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿。\n\r\n\rTimeOutOfMs&nbsp; 等待事件超时时间，单位为毫秒，等待超时后该函数直接返回，不执行SPI任何操作。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   //SPI发送数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_WriteBytesOfEvent(DevHandle,SPIIndex,WriteBuffer,sizeof(WriteBuffer),0x01,0x10,1000);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"SPI发送数据失败!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_ReadBytesOfEvent\n\r\n\r描述：\n\r\n\r主机模式下等到有效事件后SPI接收数据，若超时后则直接返回，不做任何SPI操作。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_ReadBytesOfEvent(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen,int&nbsp;EventPin,unsigned&nbsp;char&nbsp;EventType,int&nbsp;TimeOutOfMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpReadData&nbsp; 待接收的数据缓冲区指针。\n\r\n\rReadLen&nbsp; 接收数据字节数，单次接收的数据数不能超过20*1024字节。\n\r\n\rEventPin&nbsp; 等待事件输入的GPIO引脚，每个bit位对应一个引脚，比如P0为0x01，P2为0x04，P15为0x8000。\n\r\n\rEventType&nbsp;&nbsp; 等待件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿。\n\r\n\rTimeOutOfMs&nbsp; 等待事件超时时间，单位为毫秒，等待超时后该函数直接返回，不执行SPI任何操作。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   //SPI接收数据&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_ReadBytesOfEvent(DevHandle,SPIIndex,ReadBuffer,sizeof(ReadBuffer),0x01,0x10,1000);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"SPI接收数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;Data:\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;sizeof(ReadBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(((i+1)%16)==0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_WriteReadBytesOfEvent\n\r\n\r描述：\n\r\n\r主机模式事件发送接收数据，半双工模式下，先发送数据，然后再接收数据。全双工模式下发送数据和接收数据同时进行。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_WriteReadBytesOfEvent(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen,int&nbsp;IntervalTimeUs,int&nbsp;EventPin,unsigned&nbsp;char&nbsp;EventType,int&nbsp;TimeOutOfMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpWriteData&nbsp; 待发送的数据缓冲区指针。\n\r\n\rWriteLen&nbsp; 待发送的数据字节数，单次发送的数据不能超过20*1024字节。\n\r\n\rpReadData&nbsp; 待接收的数据缓冲区指针。\n\r\n\rReadLen&nbsp; 接收数据字节数，单次接收的数据数不能超过20*1024字节。\n\r\n\rIntervalTimeUs&nbsp; 半双工模式下，发送数据和接收数据之间的时间间隔，单位为微秒(us)。\n\r\n\rEventPin&nbsp; 等待事件输入的GPIO引脚，每个bit位对应一个引脚，比如P0为0x01，P2为0x04，P15为0x8000。\n\r\n\rEventType&nbsp;&nbsp; 等待件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿。\n\r\n\rTimeOutOfMs&nbsp; 等待事件超时时间，单位为毫秒，等待超时后该函数直接返回，不执行SPI任何操作。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   //SPI待发送的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   //SPI发送接收数据&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_WriteReadBytesOfEvent(DevHandle,SPIIndex,WriteBuffer,sizeof(WriteBuffer),ReadBuffer,sizeof(ReadBuffer),500,0x01,0x10,1000);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"SPI发送接收数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;Data:\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;sizeof(ReadBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(((i+1)%16)==0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_WriteBits\n\r\n\r描述：\n\r\n\r发送任意bit数二进制数据流，注意必须将USB2SPI适配器配置为软件SPI时才能使用。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_WriteBits(int&nbsp;DevHandle,int&nbsp;SPIIndex,char&nbsp;*pWriteBitStr);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpWriteBitStr&nbsp; 待发送的二进制数据字符串，如：“101100101101”。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   //SPI发送接收数据&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_WriteBits(DevHandle,SPIIndex,\"10010110111101\");&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"SPI发送数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_ReadBits\n\r\n\r描述：\n\r\n\r主机模式读取任意bit数二进制数据流，注意必须将USB2SPI适配器配置为软件SPI时才能使用。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_ReadBits(int&nbsp;DevHandle,int&nbsp;SPIIndex,char&nbsp;*pReadBitStr,int&nbsp;ReadBitsNum);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpReadBitStr&nbsp; 存储读取到的二进制数据字符串缓冲器。\n\r\n\rReadBitsNum&nbsp; 准备读取的二进制数据bit数。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   char&nbsp;ReadBuffer[128];&nbsp;&nbsp;   //SPI发送接收数据&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_ReadBits(DevHandle,SPIIndex,ReadBuffer,32);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"SPI读取数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_WriteReadBits\n\r\n\r描述：\n\r\n\r主机模式写读取任意bit数二进制数据流，注意必须将USB2SPI适配器配置为软件SPI时才能使用。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_WriteReadBits(int&nbsp;DevHandle,int&nbsp;SPIIndex,char&nbsp;*pWriteBitStr,char&nbsp;*pReadBitStr,int&nbsp;ReadBitsNum);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpWriteBitStr&nbsp; 待发送的二进制数据字符串，如：“101100101101”。\n\r\n\rpReadBitStr&nbsp; 存储读取到的二进制数据字符串缓冲区指针。\n\r\n\rReadBitsNum&nbsp; 准备读取的二进制数据bit数。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   char&nbsp;ReadBuffer[128];&nbsp;&nbsp;   //SPI发送接收数据&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_WriteReadBits(DevHandle,SPIIndex,\"10110011\",ReadBuffer,32);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"SPI写读取数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_SlaveWriteBytes\n\r\n\r描述：\n\r\n\r从机模式下将数据传输到数据发送缓冲区，等到主机的片选信号和时钟信号到来之后再将其数据发送出去。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_SlaveWriteBytes(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI2_CS0.\n\r\n\rpWriteData&nbsp; 待传输的数据缓冲区指针。\n\r\n\rWriteLen&nbsp; 待传输的数据字节数，最大值为20*1024.\n\r\n\rTimeOutMs&nbsp; 等待数据被主机读取的超时时间，单位为毫秒，在超时时间内若数据被主机读取，则返回被主机读取的数据字节数。若该参数为0，则一直等待，直到数据全部发送出去为止。\n\r\n\r返回值：\n\r\n\r函数执行状态，小于0函数执行出错，大于0表示成功被主机读取的字节数。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   //SPI待发送的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_SlaveWriteBytes(DevHandle,SPIIndex,WriteBuffer,sizeof(WriteBuffer),5000);&nbsp;&nbsp;   if(ret&nbsp;&lt;&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"从机模式写数据失败!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_SlaveReadBytes\n\r\n\r描述：\n\r\n\r从机模式读数据，调用该函数后，适配器将等待接收主机发送数据，当数据大于或等于ReadLen参数字节数时返回，或者超时时间到之后返回。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_SlaveReadBytes(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI2_CS0.\n\r\n\rpReadData&nbsp; 待接收数据的数据缓冲区指针，缓冲区大小建议不要小于40960。\n\r\n\rpReadLen&nbsp; 待接收的数据字节数，若在超时时间内没有接收到指定的字节数，则返回实际接收到的数据字节数。\n\r\n\rTimeOutMs&nbsp; 等待接收到数据的超时时间，单位为毫秒，在超时时间内若接收到数据，则函数直接返回，若该参数为0，则一直等待，直到读取到指定字节数为止。\n\r\n\r返回值：\n\r\n\r函数执行状态，小于0函数调用失败，大于等于0则为成功获取到的数据字节数。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_SlaveReadBytes(DevHandle,SPIIndex,ReadBuffer,100,1000);&nbsp;&nbsp;   if(ret&nbsp;&lt;&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"从机模式读数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;Data:\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;ret;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(((i+1)%16)==0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_SlaveReadWriteBytes\n\r\n\r描述：\n\r\n\r从机模式下读写数据，若是全双工模式，则读写数据同时进行。若是半双工模式，这先接收数据，然后再发送数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_SlaveReadWriteBytes(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadDataLen,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteDataLen,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI2_CS0.\n\r\n\rpReadData&nbsp; 待接收数据的数据缓冲区指针，缓冲区大小建议不要小于40960。\n\r\n\rpReadDataLen&nbsp; 待接收的数据字节数，若在超时时间内没有接收到指定的字节数，则返回实际接收到的数据字节数。\n\r\n\rpWriteData&nbsp; 待发送数据的数据缓冲区指针。\n\r\n\rpWriteDataLen&nbsp; 待发送的数据字节数。\n\r\n\rTimeOutMs&nbsp; 等待接收到数据的超时时间，单位为毫秒，在超时时间内若接收到数据，则函数直接返回，若该参数为0，则一直等待，直到成功发送或者接收到指定字节数为止\n\r\n\r返回值：\n\r\n\r小于0则函数调用出错，返回值高16位为成功发送的数据字节数，低16为成功读取到的数据字节数。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;64;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   //从机半双工模式下先接收100字节数据，接收到数据后再从机模式发送64字节数据&nbsp;&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_SlaveReadWriteBytes(DevHandle,SPIIndex,ReadBuffer,100,WriteBuffer,64,1000);&nbsp;&nbsp;   if(ret&nbsp;&lt;&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"从机模式读写数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Success&nbsp;Write&nbsp;Data&nbsp;Num&nbsp;=&nbsp;%d\\n\",(ret&nbsp;&gt;&gt;16)&amp;0xFFFF);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Success&nbsp;Read&nbsp;Data&nbsp;Num&nbsp;=&nbsp;%d\\n\",ret&amp;0xFFFF);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;(ret&amp;0xFFFF);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(((i+1)%16)==0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_SlaveWriteReadBytes\n\r\n\r描述：\n\r\n\r从机模式下写读数据，若是全双工模式，则写读数据同时进行。若是半双工模式，这先发送数据，然后再读取数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_SlaveWriteReadBytes(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteDataLen,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadDataLen,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI2_CS0.\n\r\n\rpWriteData&nbsp; 待发送数据的数据缓冲区指针。\n\r\n\rpWriteDataLen&nbsp; 待发送的数据字节数。\n\r\n\rpReadData&nbsp; 待接收数据的数据缓冲区指针，缓冲区大小建议不要小于40960。\n\r\n\rpReadDataLen&nbsp; 待接收的数据字节数，若在超时时间内没有接收到指定的字节数，则返回实际接收到的数据字节数。\n\r\n\rTimeOutMs&nbsp; 等待接收到数据的超时时间，单位为毫秒，在超时时间内若接收到数据，则函数直接返回，若该参数为0，则一直等待，直到成功发送或者接收到指定字节数为止\n\r\n\r返回值：\n\r\n\r小于0则函数调用出错，返回值高16位为成功发送的数据字节数，低16为成功读取到的数据字节数。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;64;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   //从机半双工模式下先接收100字节数据，接收到数据后再从机模式发送64字节数据&nbsp;&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_SlaveWriteReadBytes(DevHandle,SPIIndex,WriteBuffer,64,ReadBuffer,100,1000);&nbsp;&nbsp;   if(ret&nbsp;&lt;&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"从机模式读写数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Success&nbsp;Write&nbsp;Data&nbsp;Num&nbsp;=&nbsp;%d\\n\",(ret&nbsp;&gt;&gt;16)&amp;0xFFFF);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Success&nbsp;Read&nbsp;Data&nbsp;Num&nbsp;=&nbsp;%d\\n\",ret&amp;0xFFFF);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;(ret&amp;0xFFFF);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(((i+1)%16)==0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_SlaveContinueRead\n\r\n\r描述：\n\r\n\r从机模式下连续读取数据，调用该函数会自动启动一个数据读取线程，读到数据后会通过回调函数的方式将读到的数据传出。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_SlaveContinueRead(int&nbsp;DevHandle,int&nbsp;SPIIndex,PSPI_GET_DATA_HANDLE&nbsp;pSlaveReadDataHandle);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI2_CS0.\n\r\n\rpSlaveReadDataHandle&nbsp; 接收到数据之后的回调函数指针，其定义原型请参考本文开头部分说明。若传入NULL，则不会启动自动接收数据线程，可以通过调用SPI_SlaveGetBytes函数获取适配器接收到的数据。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   //SPI从机模式接收到数据的回调函数，该函数中将数据存储在data.txt文本文档中&nbsp;&nbsp;   int&nbsp;SPI_SlaveReadData(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pData,int&nbsp;DataNum)&nbsp;&nbsp;   {&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;FILE&nbsp;*pFile=fopen(\"data.txt\",\"a\");&nbsp;//获取文件的指针&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if(pFile&nbsp;==&nbsp;NULL){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"打开文件失败！\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Read&nbsp;Data&nbsp;Count:&nbsp;%d\\n\",DataNum);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;DataNum;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(pFile,\"%02X&nbsp;\",pData[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",pData[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(((i+1)%32)==0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(pFile,\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;fflush(pFile);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;   //启动连续模式读取数据，接收到数据之后会自动调用其回调函数&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_SlaveContinueRead(DevHandle,SPIIndex,SPI_SlaveReadData);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"启动从机模式连续读数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_SlaveGetBytes\n\r\n\r描述：\n\r\n\r获取从机模式下接收到数据缓冲区中的数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_SlaveGetBytes(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;TimeOutOfMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI2_CS0.\n\r\n\rpReadData&nbsp; 数据存储缓冲区指针。建议把该缓冲区设置大一点，尽量大于40960字节，以防读回来的数据太大，导致缓冲区溢出。\n\r\n\rTimeOutOfMs 若缓冲区中没有数据，等待数据的时间，单位为毫秒。\n\r\n\r返回值：\n\r\n\r小于0，函数调用出错，大于等于0，为读到的有效数据字节数。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;DataNum;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   DataNum&nbsp;=&nbsp;SPI_SlaveGetBytes(DevHandle&nbsp;,SPIIndex&nbsp;,ReadBuffer,1000);   printf(\"获取到%d字节数据\\n\",DataNum);&nbsp;&nbsp;\n\rSPI_SlaveContinueWriteReadStop\n\r\n\r描述：\n\r\n\r停止从机模式连续写读数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_SlaveContinueWriteReadStop(int&nbsp;DevHandle,int&nbsp;SPIIndex);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI2_CS0.\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_SlaveContinueWriteReadStop(DevHandle&nbsp;,SPIIndex);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"停止从机模式连续读数据出错！\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_SlaveContinueWrite\n\r\n\r描述：\n\r\n\rSPI从机模式下连续发送数据，也就是将数据放到数据缓冲区中，主机来读取的时候会自动循环发送。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_SlaveContinueWrite(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI2_CS0.\n\r\n\rpWriteData&nbsp; 发送到适配器内部数据缓冲区中的数据指针。\n\r\n\rWriteLen&nbsp;待发送的数据字节数。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   //SPI待发送的数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_SlaveContinueWrite(DevHandle,SPIIndex,WriteBuffer,sizeof(WriteBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"从机模式连续写数据失败!\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_FlashInit\n\r\n\r描述：\n\r\n\r初始化配置25系列SPI Flash读写相关参数。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_FlashInit(int&nbsp;DevHandle,int&nbsp;SPIIndex,int&nbsp;ClockSpeed,&nbsp;PSPI_FLASH_CONFIG&nbsp;pConfig);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rClockSpeedHz&nbsp; SPI时钟频率:单位为Hz，最大50000000，最小390625，按2的倍数改变。\n\r\n\rpConfig 25系列SPI Flash读写配置参数结构体指针，具体取值参考本文开头SPI_FLASH_CONFIG结构体定义部分，也可以参考我们提供的范例程序源码。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   //根据W25Q64配置相关参数&nbsp;&nbsp;   SPI_FLASH_CONFIG&nbsp;SPIFlashConfig;&nbsp;&nbsp;   SPIFlashConfig.CMD_EraseSector&nbsp;=&nbsp;0x20;&nbsp;&nbsp;   SPIFlashConfig.CMD_ReadData&nbsp;=&nbsp;0x03;&nbsp;&nbsp;   SPIFlashConfig.CMD_ReadFast&nbsp;=&nbsp;0x0B;&nbsp;&nbsp;   SPIFlashConfig.CMD_ReadID&nbsp;=&nbsp;0x9F;&nbsp;&nbsp;   SPIFlashConfig.CMD_ReadStatus&nbsp;=&nbsp;0x05;&nbsp;&nbsp;   SPIFlashConfig.CMD_WriteEnable&nbsp;=&nbsp;0x06;&nbsp;&nbsp;   SPIFlashConfig.CMD_WritePage&nbsp;=&nbsp;0x02;&nbsp;&nbsp;   SPIFlashConfig.CMD_EraseChip&nbsp;=&nbsp;0xC7;&nbsp;&nbsp;   SPIFlashConfig.EraseSectorAddressBytes&nbsp;=&nbsp;3;&nbsp;&nbsp;   SPIFlashConfig.ID_Length&nbsp;=&nbsp;3;&nbsp;&nbsp;   SPIFlashConfig.NumPages&nbsp;=&nbsp;32768;&nbsp;&nbsp;   SPIFlashConfig.PageSize&nbsp;=&nbsp;256;&nbsp;&nbsp;   SPIFlashConfig.ReadDataAddressBytes&nbsp;=&nbsp;3;&nbsp;&nbsp;   SPIFlashConfig.ReadFastAddressBytes&nbsp;=&nbsp;3;&nbsp;&nbsp;   SPIFlashConfig.SectorSize&nbsp;=&nbsp;4096;&nbsp;&nbsp;   SPIFlashConfig.WritePageAddressBytes&nbsp;=&nbsp;3;&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_FlashInit(DevHandle,SPIIndex,50000000,&amp;SPIFlashConfig);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"初始化配置SPI&nbsp;Flash适配器出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_FlashReadID\n\r\n\r描述：\n\r\n\r读取25 SPI Flash芯片的ID。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_FlashReadID(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pID);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpID&nbsp; 存储芯片ID值指针，其长度由SPIFlashConfig.ID_Length决定。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   //读取芯片ID&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_FlashReadID(DevHandle,SPIIndex,SPIFlashConfig.ID);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"获取SPI&nbsp;Flash&nbsp;ID出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }else{&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"ID&nbsp;=&nbsp;\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;SPIFlashConfig.ID_Length;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X\",SPIFlashConfig.ID[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_FlashEraseSector\n\r\n\r描述：\n\r\n\r擦出SPI Flash扇区数据。被擦除的扇区数据全部变成0xFF.\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_FlashEraseSector(int&nbsp;DevHandle,int&nbsp;SPIIndex,int&nbsp;StartSector,int&nbsp;NumSector);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rStartSector&nbsp; 起始扇区号，注意是起始扇区号，不是实际的地址。\n\r\n\rNumSector&nbsp; 准备擦出数据的扇区数。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   //擦出芯片第一扇区数据&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_FlashEraseSector(DevHandle,SPIIndex,0,1);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"扇区擦出出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_FlashEraseChip\n\r\n\r描述：\n\r\n\r擦出整片数据,整片数据都变成0xFF.\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_FlashEraseChip(int&nbsp;DevHandle,int&nbsp;SPIIndex);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   //擦出芯片的所有数据，该函数会检测擦出状态，一直等待擦出完毕之后才会返回，所以该函数消耗时间可能会比较长&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_FlashEraseChip(DevHandle,SPIIndex);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"芯片擦出出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_FlashWrite\n\r\n\r描述：\n\r\n\r向芯片指定起始地址写入数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_FlashWrite(int&nbsp;DevHandle,int&nbsp;SPIIndex,int&nbsp;StartAddr,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteLen);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rStartAddr&nbsp; 写数据起始地址，该地址可以在有效地址范围内的任意值。\n\r\n\rpWriteData&nbsp; 写数据缓冲区指针。\n\r\n\rWriteLen&nbsp; 写数据字节数，该参数可以为小于或等于20*1024的任意值。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   uint8_t&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;270;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;TestBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_FlashWrite(DevHandle,SPIIndex,250,WriteBuffer,270);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"写数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_FlashRead\n\r\n\r描述：\n\r\n\r从芯片的指定地址读取数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;SPI_FlashRead(int&nbsp;DevHandle,int&nbsp;SPIIndex,int&nbsp;StartAddr,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rStartAddr&nbsp; 读数据起始地址，该地址可以在有效地址范围内的任意值。\n\r\n\rpReadData&nbsp; 读数据缓冲区指针。\n\r\n\rReadLen&nbsp; 读数据字节数，该参数可以为小于或等于20*1024的任意值。\n\r\n\r返回值：\n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_FlashRead(DevHandle,SPIIndex,0,ReadBuffer,sizeof(ReadBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"读数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(ReadBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if((i%16)==0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   }&nbsp;&nbsp;   printf(\"\\n\\n\");&nbsp;&nbsp;\n\rSPI_FlashReadFast\n\r\n\r描述：\n\r\n\r快速模式读数据，该模式可以使用最大的SPI时钟频率。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SPI_FlashReadFast(int&nbsp;DevHandle,int&nbsp;SPIIndex,int&nbsp;StartAddr,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadLen);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rStartAddr&nbsp; 读数据起始地址，该地址可以在有效地址范围内的任意值。\n\r\n\rpReadData&nbsp; 读数据缓冲区指针。\n\r\n\rReadLen&nbsp; 读数据字节数，该参数可以为小于或等于20*1024的任意值。\n\r\n\r返回值： \n\r\n\r函数执行状态，0为成功，其他值为失败。 \n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_FlashReadFast(DevHandle,SPIIndex,0,ReadBuffer,sizeof(ReadBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"读数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(ReadBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;if((i%16)==0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   }&nbsp;&nbsp;   printf(\"\\n\\n\");&nbsp;&nbsp;\n\rSPI_BlockWriteBytes \n\r\n\r描述：\n\r\n\r主机Block模式写数据，也就是将SPI_WriteBytes函数多次操作合并为一个操作，Block模式可以较大的提高数据传输效率。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SPI_BlockWriteBytes(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;BlockSize,int&nbsp;BlockNum,int&nbsp;IntervalTimeUs);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpWriteData&nbsp; 写数据缓冲区首地址。\n\r\n\rBlockSize&nbsp; 每次写数据大小，单位为字节。\n\r\n\rBlockNum&nbsp; 写数据次数，块大小和块数乘积不能大于10K。\n\r\n\rIntervalTimeUs&nbsp; 每次写数据之间的时间间隔，单位为微妙。\n\r\n\r返回值： \n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   int&nbsp;BlockSize&nbsp;=&nbsp;10;&nbsp;&nbsp;   int&nbsp;BlockNum&nbsp;=&nbsp;30;&nbsp;&nbsp;   int&nbsp;i&nbsp;=&nbsp;0,j&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;IntervalTimeUs&nbsp;=&nbsp;20;&nbsp;&nbsp;   //准备数据，SPI写BlockNum次数据，每次写BlockSize字节数据，每次写数据之间的时间间隔为IntervalTimeUs微妙，每次写数据之间，片选信号会自动无效&nbsp;&nbsp;   for(i=0;i&lt;BlockNum;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;BlockSize;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i*BlockSize+j]&nbsp;=&nbsp;j;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_BlockWriteBytes(DevHandle,SPIIndex,WriteBuffer,BlockSize,BlockNum,IntervalTimeUs);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Block写数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_BlockReadBytes\n\r\n\r描述：\n\r\n\r主机Block模式读数据，也就是将SPI_ReadBytes函数多次操作合并为一次操作，使用该函数可以提高数据发送效率。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SPI_BlockReadBytes(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;BlockSize,int&nbsp;BlockNum,int&nbsp;IntervalTimeUs);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpReadData&nbsp; 读数据缓冲区首地址。\n\r\n\rBlockSize&nbsp; 每次读数据大小，单位为字节。\n\r\n\rBlockNum&nbsp; 读数据次数，块大小和块数乘积不能大于10K。\n\r\n\rIntervalTimeUs&nbsp; 每次读数据之间的时间间隔，单位为微妙。\n\r\n\r返回值： \n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   int&nbsp;BlockSize&nbsp;=&nbsp;10;&nbsp;&nbsp;   int&nbsp;BlockNum&nbsp;=&nbsp;30;&nbsp;&nbsp;   int&nbsp;i&nbsp;=&nbsp;0,j&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;IntervalTimeUs&nbsp;=&nbsp;20;&nbsp;&nbsp;   //读BlockNum次数据，每次读BlockSize字节数据，每次读数据之间的时间间隔为IntervalTimeUs微妙，每次读数据之间，片选信号会自动无效&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_BlockReadBytes(DevHandle,SPIIndex,ReadBuffer,BlockSize,BlockNum,IntervalTimeUs);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Block读数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_BlockWriteReadBytes\n\r\n\r描述：\n\r\n\r主机Block模式写读数据，也就是将SPI_WriteReadBytes多次操作合并为一个操作。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SPI_BlockWriteReadBytes(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteBlockSize,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadBlockSize,int&nbsp;BlockNum,int&nbsp;IntervalTimeUs);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpWriteData&nbsp; 写数据缓冲区首地址。\n\r\n\rWriteBlockSize&nbsp; 每次写数据大小，单位为字节。\n\r\n\rpReadData&nbsp; 读数据缓冲区首地址。\n\r\n\rReadBlockSize&nbsp; 每次读数据大小，单位为字节。\n\r\n\rBlockNum&nbsp; 写读数据次数，块大小和块数乘积不能大于10K。\n\r\n\rIntervalTimeUs&nbsp; 每次写读数据之间的时间间隔，单位为微妙。\n\r\n\r返回值： \n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   int&nbsp;WriteBlockSize&nbsp;=&nbsp;10;&nbsp;&nbsp;   int&nbsp;ReadBlockSize&nbsp;=&nbsp;2;&nbsp;&nbsp;   int&nbsp;BlockNum&nbsp;=&nbsp;30;&nbsp;&nbsp;   int&nbsp;i&nbsp;=&nbsp;0,j&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;IntervalTimeUs&nbsp;=&nbsp;20;&nbsp;&nbsp;   //准备数据，SPI写读BlockNum次数据，每次写WriteBlockSize字节数据然后读ReadBlockSize字节数据，每次写读数据之间的时间间隔为IntervalTimeUs微妙，每次写读数据之间，片选信号会自动无效&nbsp;&nbsp;   for(i=0;i&lt;BlockNum;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;BlockSize;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i*BlockSize+j]&nbsp;=&nbsp;j;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_BlockWriteReadBytes(DevHandle,SPIIndex,WriteBuffer,WriteBlockSize,ReadBuffer,ReadBlockSize,BlockNum,IntervalTimeUs);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Block写读数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_BlockWriteBytesOfEvent\n\r\n\r描述：\n\r\n\r事件Block模式写数据，也就是将SPI_WriteBytes函数多次操作合并为一个操作，Block模式可以较大的提高数据传输效率。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SPI_BlockWriteBytesOfEvent(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;BlockSize,int&nbsp;BlockNum,int&nbsp;EventPin,unsigned&nbsp;char&nbsp;EventType,int&nbsp;TimeOutOfMs);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpWriteData&nbsp; 写数据缓冲区首地址。\n\r\n\rBlockSize&nbsp; 每次写数据大小，单位为字节。\n\r\n\rBlockNum&nbsp; 写数据次数，块大小和块数乘积不能大于10K。\n\r\n\rEventPin&nbsp; 等待事件输入的GPIO引脚，每个bit位对应一个引脚，比如P0为0x01，P2为0x04，P15为0x8000。\n\r\n\rEventType&nbsp;&nbsp; 等待件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿。\n\r\n\rTimeOutOfMs&nbsp; 等待事件超时时间，单位为毫秒，等待超时后该函数直接返回，不执行SPI任何操作。\n\r\n\r返回值： \n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   int&nbsp;BlockSize&nbsp;=&nbsp;10;&nbsp;&nbsp;   int&nbsp;BlockNum&nbsp;=&nbsp;30;&nbsp;&nbsp;   int&nbsp;i&nbsp;=&nbsp;0,j&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;IntervalTimeUs&nbsp;=&nbsp;20;&nbsp;&nbsp;   //准备数据，SPI写BlockNum次数据，每次写BlockSize字节数据，每次写数据都必须等到P0引脚下降沿事件发生后进行，每次写数据之间，片选信号会自动无效&nbsp;&nbsp;   for(i=0;i&lt;BlockNum;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;BlockSize;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i*BlockSize+j]&nbsp;=&nbsp;j;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_BlockWriteBytesOfEvent(DevHandle,SPIIndex,WriteBuffer,BlockSize,BlockNum,0x01,0x10,100);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Block写数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_BlockReadBytesOfEvent\n\r\n\r描述：\n\r\n\r事件Block模式读数据，也就是将SPI_ReadBytes函数多次操作合并为一次操作，使用该函数可以提高数据发送效率。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SPI_BlockReadBytesOfEvent(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;BlockSize,int&nbsp;BlockNum,int&nbsp;EventPin,unsigned&nbsp;char&nbsp;EventType,int&nbsp;TimeOutOfMs);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpReadData&nbsp; 读数据缓冲区首地址。\n\r\n\rBlockSize&nbsp; 每次读数据大小，单位为字节。\n\r\n\rBlockNum&nbsp; 读数据次数，块大小和块数乘积不能大于10K。\n\r\n\rEventPin&nbsp; 等待事件输入的GPIO引脚，每个bit位对应一个引脚，比如P0为0x01，P2为0x04，P15为0x8000。\n\r\n\rEventType&nbsp;&nbsp; 等待件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿。\n\r\n\rTimeOutOfMs&nbsp; 等待事件超时时间，单位为毫秒，等待超时后该函数直接返回，不执行SPI任何操作。\n\r\n\r返回值： \n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   int&nbsp;BlockSize&nbsp;=&nbsp;10;&nbsp;&nbsp;   int&nbsp;BlockNum&nbsp;=&nbsp;30;&nbsp;&nbsp;   int&nbsp;i&nbsp;=&nbsp;0,j&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;IntervalTimeUs&nbsp;=&nbsp;20;&nbsp;&nbsp;   //读BlockNum次数据，每次读BlockSize字节数据，每次读数据都必须等待P0引脚的下降沿事件，每次读数据之间，片选信号会自动无效&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_BlockReadBytesOfEvent(DevHandle,SPIIndex,ReadBuffer,BlockSize,BlockNum,0x01,0x10,100);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Block读数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rSPI_BlockWriteReadBytesOfEvent\n\r\n\r描述：\n\r\n\r事件Block模式写读数据，也就是将SPI_WriteReadBytesOfEvent多次操作合并为一个操作。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;SPI_BlockWriteReadBytesOfEvent(int&nbsp;DevHandle,int&nbsp;SPIIndex,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;WriteBlockSize,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;ReadBlockSize,int&nbsp;BlockNum,int&nbsp;EventPin,unsigned&nbsp;char&nbsp;EventType,int&nbsp;TimeOutOfMs);&nbsp;&nbsp;\n\r\n\r\n\r参数：\n\r\n\rDevHandle&nbsp; 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rSPIIndex&nbsp; SPI通道号，可取以下值：SPI1_CS0，SPI1_CS1，SPI1_CS2，SPI1_CS3，SPI1_CS4，SPI2_CS0，SPI2_CS1，SPI2_CS2，SPI2_CS3，SPI2_CS4.\n\r\n\rpWriteData&nbsp; 写数据缓冲区首地址。\n\r\n\rWriteBlockSize&nbsp; 每次写数据大小，单位为字节。\n\r\n\rpReadData&nbsp; 读数据缓冲区首地址。\n\r\n\rReadBlockSize&nbsp; 每次读数据大小，单位为字节。\n\r\n\rBlockNum&nbsp; 写读数据次数，块大小和块数乘积不能大于10K。\n\r\n\rEventPin&nbsp; 等待事件输入的GPIO引脚，每个bit位对应一个引脚，比如P0为0x01，P2为0x04，P15为0x8000。\n\r\n\rEventType&nbsp;&nbsp; 等待件类型，0x00-低电平，0x11-高电平，0x10-下降沿，0x01上升沿。\n\r\n\rTimeOutOfMs&nbsp; 等待事件超时时间，单位为毫秒，等待超时后该函数直接返回，不执行SPI任何操作。\n\r\n\r返回值： \n\r\n\r函数执行状态，0为成功，其他值为失败。\n\r\n\r\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb2spi.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;   int&nbsp;ret;&nbsp;&nbsp;   int&nbsp;SPIIndex&nbsp;=&nbsp;SPI1_CS0;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;WriteBuffer[20*1024];&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;ReadBuffer[20*1024];&nbsp;&nbsp;   int&nbsp;WriteBlockSize&nbsp;=&nbsp;10;&nbsp;&nbsp;   int&nbsp;ReadBlockSize&nbsp;=&nbsp;2;&nbsp;&nbsp;   int&nbsp;BlockNum&nbsp;=&nbsp;30;&nbsp;&nbsp;   int&nbsp;i&nbsp;=&nbsp;0,j&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;IntervalTimeUs&nbsp;=&nbsp;20;&nbsp;&nbsp;   //准备数据，SPI写读BlockNum次数据，每次写WriteBlockSize字节数据然后读ReadBlockSize字节数据，每次写读数据时必须等待P0引脚的下降沿事件，每次写读数据之间，片选信号会自动无效&nbsp;&nbsp;   for(i=0;i&lt;BlockNum;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(j=0;j&lt;BlockSize;j++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i*BlockSize+j]&nbsp;=&nbsp;j;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;SPI_BlockWriteReadBytesOfEvent(DevHandle,SPIIndex,WriteBuffer,WriteBlockSize,ReadBuffer,ReadBlockSize,BlockNum,0x01,0x10,100);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;SPI_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Block写读数据出错!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\r","usb2spi","topics\\函数说明/usb2spi.htm","目录\n\r  概述  UART_Init  UART_WriteBytes  UART_WriteBytesAsync  UART_WriteBytesInterval  UART_ReadBytes  UART_ClearData\n\r概述\n\r\n\rUSB2XXX有2路UART总线，2路UART可以同时使用，每路UART都有一个数据发送控制引脚，配置成485模式之后可以自动输出控制信号，该信号可以跟485收发器芯片的数据方向控制引脚连接，如此就可以实现输出485的信号。下面是本文函数可能会用到的一些宏定义： \n\r  //定义初始化UART初始化数据类型&nbsp;&nbsp;  typedef&nbsp;struct&nbsp;_UART_CONFIG{&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;int&nbsp;&nbsp;BaudRate;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //波特率&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;char&nbsp;WordLength;&nbsp;&nbsp;&nbsp;//数据位宽，0-8bit,1-9bit&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;char&nbsp;StopBits;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //停止位宽，0-1bit,1-0.5bit,2-2bit,3-1.5bit&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;char&nbsp;Parity;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //奇偶校验，0-No,4-Even,6-Odd&nbsp;&nbsp;  &nbsp;&nbsp;unsigned&nbsp;char&nbsp;TEPolarity;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   //TE输出控制，0x80-输出TE信号，且低电平有效，0x81-输出TE信号，且高电平有效，0x00不输出TE信号&nbsp;&nbsp;  }UART_CONFIG,*PUART_CONFIG;&nbsp;&nbsp;  &nbsp;&nbsp;  //定义函数返回错误代码&nbsp;&nbsp;   #define&nbsp;UART_SUCCESS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(0)&nbsp;&nbsp;&nbsp;//函数执行成功&nbsp;&nbsp;   #define&nbsp;UART_ERR_NOT_SUPPORT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-1)&nbsp;&nbsp;//适配器不支持该函数&nbsp;&nbsp;   #define&nbsp;UART_ERR_USB_WRITE_FAIL&nbsp;&nbsp;&nbsp;&nbsp;   (-2)&nbsp;&nbsp;//USB写数据失败&nbsp;&nbsp;   #define&nbsp;UART_ERR_USB_READ_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(-3)&nbsp;&nbsp;//USB读数据失败&nbsp;&nbsp;   #define&nbsp;UART_ERR_CMD_FAIL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;(-4)&nbsp;&nbsp;//命令执行失败&nbsp;&nbsp;   //数据位宽&nbsp;&nbsp;   #define&nbsp;UART_WORD_LENGTH_8BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;   #define&nbsp;UART_WORD_LENGTH_9BIT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;   //停止位&nbsp;&nbsp;   #define&nbsp;UART_STOP_BITS_1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0&nbsp;&nbsp;   #define&nbsp;UART_STOP_BITS_05&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;   #define&nbsp;UART_STOP_BITS_2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   2&nbsp;&nbsp;   #define&nbsp;UART_STOP_BITS_15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;   //奇偶校验位&nbsp;&nbsp;   #define&nbsp;UART_PARITY_NO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0&nbsp;&nbsp;   #define&nbsp;UART_PARITY_EVEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;   #define&nbsp;UART_PARITY_ODD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;   //TE控制信号输出&nbsp;&nbsp;   #define&nbsp;UART_TE_DISEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   0x00&nbsp;&nbsp;   #define&nbsp;UART_TE_EN_LOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x80&nbsp;&nbsp;   #define&nbsp;UART_TE_EN_HIGH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0x81&nbsp;&nbsp;\n\rUART_Init\n\r\n\r描述：\n\r\n\r初始化配置UART，必须要调用该函数之后才能调用其他数据收发函数。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;UART_Init(int&nbsp;DevHandle,&nbsp;unsigned&nbsp;char&nbsp;Channel,&nbsp;PUART_CONFIG&nbsp;pConfig);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rChannel&nbsp; UART通道索引号，取值0或1。\n\r\n\rpConfig&nbsp; UART初始化配置参数，详细取值见该结构体定义说明。\n\r\n\r返回值：\n\r\n\r函数执行状态，0表示函数执行成功，其他值表示函数执行失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2uart.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   //配置UART总线相关参数&nbsp;&nbsp;   UART_CONFIG&nbsp;UARTConfig;&nbsp;&nbsp;   unsigned&nbsp;char&nbsp;UARTIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   UARTConfig.BaudRate&nbsp;=&nbsp;115200;&nbsp;&nbsp;   UARTConfig.Parity&nbsp;=&nbsp;UART_PARITY_NO;&nbsp;&nbsp;   UARTConfig.StopBits&nbsp;=&nbsp;UART_STOP_BITS_1;&nbsp;&nbsp;   UARTConfig.WordLength&nbsp;=&nbsp;UART_WORD_LENGTH_8BIT;&nbsp;&nbsp;   ret&nbsp;=&nbsp;UART_Init(DevHandle[0],UARTIndex,&amp;UARTConfig);&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;UART_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Initialize&nbsp;device&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rUART_WriteBytes\n\r\n\r描述：\n\r\n\rUART发送数据，该函数为阻塞函数，也就是说必须要等到所有数据成功发送完毕之后才返回。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;UART_WriteBytes(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;Channel,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;DataSize);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rChannel&nbsp; UART通道索引号，取值0或1。\n\r\n\rpWriteData&nbsp; UART发送数据缓冲区首地址，也就是数据发送指针。\n\r\n\rDataSize&nbsp; 待发送的数据字节数。\n\r\n\r返回值：\n\r\n\r函数执行状态，0表示函数执行成功，其他值表示函数执行失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2uart.h\"&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;   uint8_t&nbsp;UARTIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   uint8_t&nbsp;WriteBuffer[1024];&nbsp;&nbsp;   //UART发送数据&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;UART_WriteBytes(DevHandle[0],UARTIndex,WriteBuffer,sizeof(WriteBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;UART_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"UART&nbsp;write&nbsp;data&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rUART_WriteBytesAsync\n\r\n\r描述：\n\r\n\rUART异步模式发送数据，调用该函数后，数据会发送到适配器中，然后判断上一次的数据是否发送完毕，若已经发送完毕则启动DMA传输数据，函数立即返回，否则等待上一次的数据发送完毕之后再启动DMA开始发送数据，使用此函数可以提高UART发送数据带宽。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;UART_WriteBytesAsync(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;Channel,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;DataSize);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rChannel&nbsp; UART通道索引号，取值0或1。\n\r\n\rpWriteData&nbsp; UART发送数据缓冲区首地址，也就是数据发送指针。\n\r\n\rDataSize&nbsp; 待发送的数据字节数。\n\r\n\r返回值：\n\r\n\r函数执行状态，0表示函数执行成功，其他值表示函数执行失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2uart.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   uint8_t&nbsp;UARTIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   uint8_t&nbsp;WriteBuffer[1024];&nbsp;&nbsp;   //UART发送数据&nbsp;&nbsp;   for(int&nbsp;i=0;i&lt;sizeof(WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;   ret&nbsp;=&nbsp;UART_WriteBytesAsync(DevHandle[0],UARTIndex,WriteBuffer,sizeof(WriteBuffer));&nbsp;&nbsp;   if(ret&nbsp;!=&nbsp;UART_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"UART&nbsp;write&nbsp;data&nbsp;error!\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rUART_WriteBytesInterval\n\r\n\r描述：\n\r\n\rUART间隔模式发送数据，也就是每个字节之间会增加指定的延时时间。\n\r\n\r原型：\n\r  int&nbsp;WINAPI&nbsp;UART_WriteBytesInterval(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;Channel,unsigned&nbsp;char&nbsp;*pWriteData,int&nbsp;DataSize,unsigned&nbsp;char&nbsp;IntervalTimeMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数： \n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rChannel&nbsp; UART通道索引号，取值0或1。\n\r\n\rpWriteData&nbsp; UART发送数据缓冲区首地址，也就是数据发送指针。\n\r\n\rDataSize&nbsp; 待发送的数据字节数。\n\r\n\rIntervalTimeMs 发送数据字节间间隔时间，单位为毫秒。\n\r\n\r返回值：\n\r\n\r函数执行状态，0表示函数执行成功，其他值表示函数执行失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt; &nbsp;&nbsp;  #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;  #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;  #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;  #include&nbsp;\"usb2uart.h\" &nbsp;&nbsp;  &nbsp;&nbsp;  uint8_t&nbsp;UARTIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;  uint8_t&nbsp;WriteBuffer[1024];&nbsp;&nbsp;  //UART发送数据 &nbsp;&nbsp;  for ( int&nbsp;i=0;i&lt; sizeof (WriteBuffer);i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;WriteBuffer[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;   }&nbsp;&nbsp;  ret&nbsp;=&nbsp;UART_WriteBytesInterval(DevHandle[0],UARTIndex,WriteBuffer,sizeof(WriteBuffer),2);&nbsp;&nbsp;  if (ret&nbsp;!=&nbsp;UART_SUCCESS){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"UART&nbsp;write&nbsp;data&nbsp;error!\\n\" );&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;0;&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rUART_ReadBytes\n\r\n\r描述：\n\r\n\r获取UART接收数据缓冲区中的数据，调用该函数后会自动清除已经获取到的数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;UART_ReadBytes(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;Channel,unsigned&nbsp;char&nbsp;*pReadData,int&nbsp;TimeOutMs);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rChannel&nbsp; UART通道索引号，取值0或1。\n\r\n\rpReadData&nbsp; UART接收数据缓冲区首地址，也就是数据存储指针。\n\r\n\rTineOutMs&nbsp; 接收数据超时时间，若在超时时间内没有接收到数据则会一直等待，直到接收到数据或者超时时间到为止。\n\r\n\r返回值：\n\r\n\r大于等于0表示接收到的数据字节数，小于0表示读取数据出错。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2uart.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   uint8_t&nbsp;ReadBuffer[10*1024];&nbsp;&nbsp;   uint8_t&nbsp;UARTIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret,ReadDataNum&nbsp;=&nbsp;0;&nbsp;&nbsp;   ret&nbsp;=&nbsp;UART_ReadBytes(DevHandle[0],UARTIndex,ReadBuffer,5000);&nbsp;&nbsp;   if(ret&nbsp;&gt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;ReadDataNum&nbsp;+=&nbsp;ret;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;ret;i++){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"%02X&nbsp;\",ReadBuffer[i]);&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(((i+1)%16)==0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\n\");&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"\\nReadDataNum&nbsp;=&nbsp;%d\\n\",ReadDataNum);&nbsp;&nbsp;   }else&nbsp;if(ret&nbsp;&lt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"ret&nbsp;=&nbsp;%d\\n\",ret);&nbsp;&nbsp;   }&nbsp;&nbsp;\n\rUART_ClearData\n\r\n\r描述：\n\r\n\r清除适配器已经接收到的UART数据。\n\r\n\r原型： \n\r  int&nbsp;WINAPI&nbsp;UART_ClearData(int&nbsp;DevHandle,unsigned&nbsp;char&nbsp;Channel);&nbsp;&nbsp;\n\r\n\r\n\r\n\r\n\r参数：\n\r\n\rDevHandle 设备句柄，本质为设备序号的低4字节，可以通过调用USB_ScanDevice 函数获得。\n\r\n\rChannel&nbsp; UART通道索引号，取值0或1。\n\r\n\r返回值：\n\r\n\r函数执行状态，0表示函数执行成功，其他值表示函数执行失败。\n\r\n\r示例：\n\r  #include&nbsp;&lt;stdlib.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;stdio.h&gt;&nbsp;&nbsp;   #include&nbsp;&lt;string.h&gt;&nbsp;&nbsp;   #include&nbsp;\"usb_device.h\"&nbsp;&nbsp;   #include&nbsp;\"usb2uart.h\"&nbsp;&nbsp;   &nbsp;&nbsp;   uint8_t&nbsp;ReadBuffer[10*1024];&nbsp;&nbsp;   uint8_t&nbsp;UARTIndex&nbsp;=&nbsp;0;&nbsp;&nbsp;   int&nbsp;ret,ReadDataNum&nbsp;=&nbsp;0;&nbsp;&nbsp;   ret&nbsp;=&nbsp;UART_ClearData(DevHandle[0],UARTIndex   if(ret&nbsp;==&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"Clear datasuccess\\n\");&nbsp;&nbsp;   }else&nbsp;if(ret&nbsp;&lt;&nbsp;0){&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;printf(\"ret&nbsp;=&nbsp;%d\\n\",ret);&nbsp;&nbsp;   }&nbsp;&nbsp;\n\r","usb2uart","topics\\函数说明/usb2uart.htm","概述\n\r\n\r函数使用说明文档，主要介绍USB2XXX二次开发API函数功能和参数如何传递。功能模块罗列\n\r  usb_device——&nbsp;设备管理相关函数说明，比如设备扫描，设备打开等；  usb2gpio——GPIO控制相关函数说明；  usb2adc——ADC相关函数说明；  usb2dac——DAC相关函数说明；  usb2sniffer——并口操作相关函数说明；  usb2spi——SPI总线相关函数说明；  usb2lin_ex——LIN总线相关函数说明；  usb2pwm——PWM相关函数说明；  usb2iic——I2C/IIC总线相关函数说明；  usb2uart——UART总线相关函数说明  usb2can——CAN总线相关函数说明；  usb2canfd——CANFD相关函数说明；  can_uds——CAN总线UDS相关函数说明；  lin_uds——LIN总线UDS相关函数说明；  ControlCAN——兼容周立功的CAN设备相关函数说明；  usb2cnt——脉冲计数器相关函数说明；  i2c_sniffer——I2C数据监控相关函数说明；  can_bootloader——基于CAN总线的Bootloader相关函数说明；\n\r\n\r\n\r&nbsp;","函数说明","topics\\函数说明/函数说明.htm","目录\n\r    1   前言    2 软件安装，驱动安装       3   硬件连接及使用     3.1 监控LIN总线数据     3.2 向从机读写数据 \n\r  1.前言              \n\r\n\r本文档介绍如何快速使用USB转LIN适配器，主要目的是让用户能快速的了解USB转LIN产品如何使用，产品其他功能可以参考《TCANLINPro软件使用教程》。\n\r\n\r2.软件安装，驱动安装\n\r\n\r2.1 软件下载\n\r\n\r软件下载地址：TCANLINPro软件下载-重庆图莫斯电子科技有限公司官网 (toomoss.com)\n\r\n\r\n\r\n\r打开下载页面后会出现如上图所示软件下载列表，根据自己使用的系统下载对应版本的软件即可。2.2 软件安装2.2.1 Windows系统安装\n\r\n\r在windows端，可能会存在杀毒软件误报我们软件有威胁，在下载安装软件前，建议先关闭杀毒软件，以免出现安装异常。将下载文件解压出来后，双击解压出来的文件即可开始安装，根据提示一路下一步即可，安装完成后会自动安装驱动程序，无需单独安装驱动程序。2.2.2 Linux系统安装\n\r\n\rLinux端下载下来后为\".tar.gz\"类型文件，比如使用“tar&nbsp; -zxvf &nbsp;TCANLINPro_v1.7.tar.gz”命令解压文件，解压出来后，进入程序目录，用管理员权限执行“sudo ./install.sh”命令安装程序，程序安装完毕之后会自动运行程序。2.2.3 Mac系统安装\n\r\n\rMac系统下为“.dmg”格式文件，双击改文件，点击“打开”，然后将里面的文件夹拖出来放到本地目录。选择软件包，点击鼠标右键，选择“显示包内容”，然后找到“Contents/MacOS/TCANLINPro”文件，双击它即可启动程序。\n\r\n\r注意：必须按照上面所述启动程序，否则无法在LIN视图显示收发的数据！3.硬件连接及使用3.1 监控LIN总线数据 \n\r\n\r若要抓取现有总线数据，比如取抓当前车上氛围灯的控制数据，空调控制器的控制数据，灯和空调都是通过LIN总线连接到车上LIN总线上的，且都在正常工作，这种情况下就可以使用LIN从机监控。3.1.1 硬件连接\n\r\n\r \n\r\n\r 如上图所示为监控LIN总线数据的接线示意图，所谓监控LIN总线数据是指去抓取现有LIN总线上的数据，在LIN总线上至少有一个主机和一个从机在进行通信（只有主机在发送数据也能监控），LIN所有数据传输都是主机发起，从机是不能主动发送数据出来的，比如车窗控制器，水泵，氛围灯，空调控制器，这些都属于LIN从机，它是不能主动发送数据出来，所以不能将他们连接到我们设备进行数据监控（从机不会发送数据出来），若需要控制从节点，可以参考后续章节说明。\n\r\n\r UTA0401产品外壳上的【12V】引脚就是上图中的VBAT引脚，该引脚即可以作为电源引脚给外部设备供电，也可以作为输入引脚，给内部LIN总线电路供电，作为数据监控时，若LIN总线高电平是12V，那么可以不接该引脚，只将LIN和GND接到LIN总线上的LIN和GND线即可，若LIN高电平是24V电压，那么只需要将该引脚接入24V电压即可。\n\r\n\r LIN和GND具体使用引脚可以参考【引脚定义说明文档】或者参考产品外壳上的引脚功能定义说明。3.1.2 软件配置\n\r\n\r \n\r\n\r打开软件后，主界面如上图所示，点击对应的LIN后面的【启动】按钮后，弹出LIN配置界面，如下图所示：\n\r\n\r \n\r\n\r监控数据，主从模式选择为【从机】，若知道总线波特，则输入对应的波特率值即可，若LIN总线高电平是12V，那么VBAT输出选择12V即可，若LIN总线电压高于12V，比如为24V，那么此处也可以选择12V，然后在VBAT引脚外接24V电压。\n\r\n\r若不清楚总线上的波特率，可以点击【探测波特率】对总线波特率进行探测，点击后如下图所示：\n\r\n\r \n\r\n\r注意！由于是去监控LIN总线数据，所以我们认为LIN总线上本身是有数据在传输的，所以需要勾选【总线上接有其他主机，并且有数据在传输】，然后点击【开始】按钮，探测到波特率后，会自动显示探测到的波特率值。\n\r\n\r若在此处没有探测到波特率，有以下几种可能：\n\r\n\r1，总线上本身没有数据在传输；\n\r\n\r2，接线错误，比如LIN线没接对，或者是GND没接对；\n\r\n\r3，该总线不是标准的LIN总线（可以用示波器或者逻辑分析仪抓波形发给我们确认）；\n\r\n\r探测到波特率后，回到参数配置界面，点击【确定】即可，若抓到了数据，数据就会在主界面进行显示，如下图所示：\n\r\n\r 3.2 向从机读写数据 \n\r\n\r若用户手上只有一个LIN从机模块，比如一个汽车用水泵，一个车载氛围灯，或者一个空气质量监控器，它们都是LIN总线接口的，并没有连接到车上，但是想要通过LIN去控制它们，或者从它们内部读取一些数据出来，那么就可以将我们适配器配置为主机模式去控制。3.2.1 硬件连接\n\r\n\r使用我们适配器给LIN从机模块供电：\n\r\n\r \n\r\n\r使用外部电源给LIN从机模块供电：\n\r\n\r 3.2.2 软件配置\n\r\n\r点击对应LIN通道后面的启动后，弹出LIN配置界面，如下图所示：\n\r\n\r \n\r\n\r主从模式配置为【主机】，若知道波特率，则配置为对应正确的波特率，若不知道波特率可以点击【探测波特率】探测节点波特率。\n\r\n\r注意：适配器配置为主机模式波特率，探测原理是在某个波特率下，向从节点发送帧头，看是否有数据响应，若有数据响应，则认为当前波特率没问题，但是有些从机节点不支持主机读数据操作，所以这种情况下是无法探测到正确波特率的。\n\r\n\r若是通过我们适配器给从机设备供电，需要配置VBAT输出【12V】，并且VBAT引脚需要连接到LIN从机模块的电源正极。\n\r\n\r若不需要使用我们适配器给从机节点供电，那么也需要配置VBAT输出【12V】，是因为适配器内部的LIN相关电路需要该12V，否则LIN无法正常工作。\n\r\n\r同步间隔宽度默认即可，若需要更宽的同步间隔宽度，可根据实际需求进行配置。\n\r\n\r配置好相关参数后，点击【确定】后，如下图所示：\n\r\n\r\n\r\n\r此时，界面上并不会有任何数据，因为我们设备是主机，所以读写数据都要主机去操作才行，点击菜单【发送LIN数据】-&gt;【普通发送】，弹出如下图所示界面：\n\r\n\r\n\r\n\r若需要主机发送数据给从机，那么需要配置好写数据ID，并设置好需要发送的数据，填写完毕后，点击【发送】即可实现一次数据发送，若需要连续发送，可以设置发送次数大于1，或者将数据添加到列表后，在列表里面发送，发送后会在主界面显示发送的数据，如下图所示：\n\r\n\r\n\r\n\r主界面上若没有显示发送出去的数据，那么有可能是LIN总线跟电源正极或者是GND短路了，若是数据出现错误，那么有可能该ID是从机发送数据，需要把帧类型选择为【主机读】模式。\n\r\n\r若想要向从机读取数据，需要先配置好读数据ID，并将数据类型配置为【主机读】，然后点击发送，如下图所示：\n\r\n\r\n\r\n\r若正常读到了数据，那么就会在数据栏显示读到的数据，若没有读到数据，那么就会在事件栏显示【SLAVE NO RESPONSE】，也就是从机没有正常响应数据。\n\r\n\r若出现从机没正常响应数据，一般是因为以下几个原因：\n\r\n\r1，波特率配置错误；\n\r\n\r2，接线错误；\n\r\n\r3，读数据ID配置错误（当前ID不支持读操作）；\n\r\n\r若不清楚读数据是哪一个ID，也可以通过如下配置快速测出哪些ID可以读数据：\n\r\n\r\n\r\n\r然后再回到主界面，看下哪些ID有响应数据，那么这些ID就是可以返回数据的。\n\r\n\r&nbsp;\n\r\n\r&nbsp; &nbsp;","USB转LIN总线适配器快速入门手册","topics\\快速入门/USB转LIN总线适配器快速入门手册.htm","目录\n\r  前言  直接下载  使用git克隆\n\r\n\r\n\r\n\r\n\r前言\n\r\n\r本文收集整理所有关于USB2XXX二次开发的工程及源码，简单的应用示例可能没有专门的文档介绍，但是程序会有详细的注释，稍微复杂的示例会有专门的一篇文档进行介绍。为了方便大家下载，所有工程源码包都放到git上下载。\n\r\n\r注意：推荐使用git或者在gitee上下载源码，上面的源码一般都是最新版本的！直接下载\n\r\n\r打开网页浏览连接(复制到浏览器里面打开)：http://www.toomoss.com/download/4-cn.html，如下图所示：\n\r\n\r&nbsp;使用git克隆\n\r\n\r使用\n\r\n\rgit clone git@gitee.com:toomoss/USB2XXX_Example.git  \n\r\n\r命令即可将源码克隆到本地。TortoiseGit使用简易教程\n\r\n\r1，下载git并安装；\n\r\n\rgit软件下载链接：https://git-scm.com/\n\r2，下载TortoiseGit并安装；\n\r\n\rTortoiseGit下载链接：https://tortoisegit.org/\n\r\n\r3，在将要克隆程序的目录点击鼠标右键，弹出下图所示：\n\r\n\r\n\r\n\r选择Git Clone…\n\r\n\r4，在弹出的对话框中填入我们程序的git链接，如下图所示：\n\r\n\r\n\r\n\r点击“OK”即开始拷贝代码文件到本地目录，拷贝界面如下所示：\n\r\n\r\n\r\n\r拷贝完毕之后在本地目录下将有一个USB2XXX_Example目录，里面的文件就是我们最新的二次开发示例源码文件，如下图所示：\n\r\n\r","如何快速获取二次开发范例程序源码","topics\\如何快速获取二次开发范例程序源码.htm","目录\n\r  前言\n\r  硬件连接\n\r  软件使用\n\r\n\r\n\r\n\r\n\r前言\n\r\n\rUSB2XXX的I2C监控功能是基于USB2XXX的并口读取数据功能实现的，USB2XXX的并口可以连续不断的接收数据到上位机端，然后上位机端根据读取到的数据进行分析处理，最终解析出I2C总线数据，然后在上位机软件界面上显示出来。\n\r\n\r因为USB2XXX适配器并不会解析数据，它只做数据采集功能，利用PC的强大数据处理能力，可以将原始的高低电平解析出I2C协议的数据，底层数据采集和数据分析处理采用2个独立的线程实现，这样可以保证数据不会被丢失。硬件连接\n\r\n\rUSB2XXX的引脚定义可以参考《引脚定义说明文档》，硬件连接示意图如下所示：\n\r\n\r\n\r\n\r注意：I2C监控功能跟I2C适配功能接线是不一样的，I2C监控功能使用的是D0到D7引脚，对于不带外壳的板子，D0到D7在双排排针测，电路板上有丝印。对于带外壳版本的，D0到D7是跟P0到P7共用的，所以在接线的时候需要注意下，另外为了保证数据的可靠性传输，被监控端的电源GND跟我们USB2XXX的GND也必须接一起。\n\r\n\r\n\r\n\r软件使用\n\r\n\r点击软件集合中的“I2C监控器”即可启动I2C监控软件，如下图所示：\n\r\n\r\n\r\n\r软件启动后的主界面如下图所示：\n\r\n\r启动设置\n\r\n\r点击软件上的“操作”-&gt;“启动”按钮即可弹出启动设置界面，如下图所示：\n\r\n\r\n\r\n\r设备号：选择当前连接到电脑上的USB2XXX设备，若此处没有显示可以选择的设备，则可能电脑没有连接USB2XXX设备或者是设备驱动没有被正确识别。\n\r\n\r通道号：我们使用并口的D0和D1两个引脚接入I2C总线，所以通道号选择为0，若使用了并口的D2和D3，则通道号选择为1，以此类推。\n\r\n\r采样率：采样率设置一般大于I2C总线速率的4倍即可，我们选择5MHz，基本上已经可以采集高达1Mbps速度的I2C总线数据了。\n\r\n\r总线电压：选择当前总线高电平电压，该设置选项只针对带外壳版本的适配器有效，不带外壳版本的适配器只能监控3.3V以上电压的I2C总线。\n\r\n\r显示模式：选择抓取到总线数据后，在主界面上显示的模式，选择“详细”则可以显示I2C数据传输的所有数据，包括START,STOP等信号，若选择“简单”模式，则只显示解析到的数据。\n\r\n\r显示地址：此处留空，则显示总线上的所有数据，若填某个具体的从机地址值，则在主界面只显示跟这个从机相关的数据。\n\r\n\r设置好之后点击“确定”按钮即可启动I2C监控功能。监控数据\n\r\n\r启动I2C监控之后，我们并不需要在软件上做什么操作，当I2C总线上有数据之后，在软件界面上会以列表的形式显示监控到的数据，数据缓存是以文件方式缓存，所以能缓存数据的大小仅仅取决于你硬盘的容量，若你硬盘容量够大，你完全不用担心数据缓存的问题。\n\r\n\r接收到数据之后如下图所示：\n\r\n\r\n\r\n\r行号：表示当前解析到的I2C数据在缓存文件中对应的行数，可以不用管。\n\r\n\r类型：表示当前行数据的类型，I2C总线总共4种类型，起始（START），地址（ADDR），数据（DATA），停止（STOP）。\n\r\n\r地址：表示当前行数据对应的设备地址，比如当前行为一个普通的数据，这个数据对应的设备地址即为该列对应的值。\n\r\n\r读/写：指示当前数据传输的方向，若是主机向从机传输数据，则为写，若是从机向主机传输数据，则为读。\n\r\n\r数据(HEX)：具体的数据十六进制，也就是除了设备地址之外的数据，这个数据有可能是寄存器地址，也可能是寄存器对应的值。\n\r\n\r数据(ASCII)：具体的数据ASCII码，也就是将数据转换为ASCII进行显示，对于不能显示的字符用圆点来显示。\n\r\n\r响应：当前数据最后一个脉冲读到的SDA信号是高电平还是低电平，若是高电平则显示“NACK”，反之显示“ACK”。\n\r\n\r时间戳：接收到当前数据时对应的时间戳。解析设置\n\r\n\r很多时候，为了方便阅读，我们希望数据自动转换为我们预先定义好的字符串，而不是冷冰冰的十六进制数据，这对于I2C总线协议的分析会有很大的帮助，比如解析SMBus或者PMBus协议，目前该软件需要自己添加协议文件，后面我们会提供很多已经配置好的协议解析文件，点击软件的“操作”-&gt;“配置协议解析”按钮即可打开协议配置界面，如下图所示：\n\r\n\r\n\r\n\r字符串：这里设置我们解析到相应的数据之后，在主界面需要显示的字符串，这个字符串是方便我们自己阅读数据，所以按照自己对协议的理解写入字符串即可。\n\r\n\r类型：指显示字符串时，匹配的数据的数据类型，数据类型有两个可选，ADDR和DATA，若选择了DATA，还需要设置解析对应的具体数值。\n\r\n\r数据(HEX)：当类型设置为DATA时，需要设置具体的数据值。\n\r\n\r显示偏移：也就是数据匹配之后，字符串应该在匹配数据之后的多少行进行显示，比如我们要将24C02的任意子地址显示为“EEPROM子地址”字符串，那么我们匹配的数据就是24C02的设备地址，它之后偏移一行就是子地址，所以该偏移量设置为1。\n\r\n\r读/写：指示当前需要解析显示的数据是主机发送的数据还是从机发送的数据，若是主机发送的数据则为WRITE，否则为READ。\n\r\n\r地址(HEX)：指示当前需要解析显示的数据对应的从机地址，该地址为7bit模式地址。解析模式监控数据\n\r\n\r配置好协议解析列表文件之后，我们就可以以协议解析的模式进行显示数据了，点击软件的“操作”-&gt;“开启协议解析”即可开启协议解析功能，当新解析到I2C总线的数据之后，就会根据协议解析配置文件解析显示数据，如下图所示：\n\r\n\r\n\r\n\r在“数据(Hex)”栏目，“[]”内的字符串就是协议解析之后显示的字符串，这对芯片协议分析是非常有帮助的！合并模式显示数据\n\r\n\r有时候数据若比较多，若每一个数据都显示一行，数据会比较分散，这时我们就可以使用合并显示数据模式显示数据，这样类似操作的数据就会合并显示在一行以内，点击软件的“操作”-&gt;“合并显示”即可开启合并显示功能，如下图所示：\n\r\n\r\n\r\n\r注意：合并显示模式下不能进行协议解析，当开启合并显示模式之后，合并显示功能会自动关闭。\n\r\n\r&nbsp;","I2C监控软件使用教程","topics\\软件使用/I2C监控软件使用教程.htm","目录\n\r  1.   设备管理  2.   启动设备  2.1 启动CAN设备  2.2 启动LIN设备  3.   数据显示视图  3.1 普通视图  3.2 CAN视图显示设置  3.3 LIN视图设置  3.4 CAN DBC视图  3.5 曲线视图  3.6 LIN LDF视图  4.   发送CAN数据  4.1 普通发送  4.2 DBC发送  4.3   DBC发送（信号变化）  4.4 数据回放  4.5 列表文件发送  5.   发送LIN数据  5.1 普通发送  5.2 LDF发送  5.3 LDF列表发送  5.4   LDF列表发送(信号变化)  5.5 UDS协议发送  5.6 数据回放  5.7 列表文件发送  5.8 设置从机响应数据  6.   高级功能  6.1 CAN总线状态  6.2 CAN总线中继   6.3 CAN固件升级  6.4   CAN/LIN总线利用率  6.5 LIN固件升级  6.6 MLX芯片烧写  6.7   CAN&amp;LIN互转  6.8 CAN转PWM  6.9 PWM波形输出\n\r 1. 设备管理\n\r\n\r\n\r  在软件的设备管理视图里面，可以同时启动多个设备，多个通道总线，所有的CAN通道和LIN通道都可以同时独立工作，互不影响；\n\r2. 启动设备 2.1 启动CAN设备 \n\r\n\r\n\r  点击CAN对应通道后面的【启动】按钮，会弹出CAN参数配置界面，主要是配置CAN总线波特率，工作模式，终端电阻接入方式；  工作模式有【正常模式】和【自发自收】模式，在没有外部接收CAN数据设备的情况下，可以使用自发自收模式测试软件功能，在正常使用的情况下，得配置为【正常模式】；  终端电阻的配置是通过软件配置的，若CAN总线上没有终端电阻，则需要在软件上使能终端电阻，否则可能会导致CAN数据无法正常收发；  常规CAN波特率在【仲裁域波特率】里面配置，若设备是支持CANFD的，那么可以根据实际需求配置【数据域波特率】；  波特率可以选择为【自定义】，然后自己设置波特率参数即可实现自定义任意波特率，点击【波特率计算器】，可以打开波特率参数计算软件，输入需要设置的波特率后，会自动计算出多组波特率参数供选择；  若不清楚总线波特率，可以点击【探测波特率】按钮，对总线波特率进行探测。\n\r2.2 启动LIN设备 \n\r\n\r\n\r  点击LIN对应通道后面的【启动】按钮，会弹出LIN参数配置界面；  根据通信对象，设置好波特率，若是去监控现有总线上的数据，但是不知道当前总线上的具体波特率，那么可以将【主从模式】配置为【从机】，然后点击【探测波特率】按钮即可探测总线上数据传输的波特率值；  根据实际需求选择【主从模式】，LIN通信是有主从关系的，若要通信的对象是从设备，那么我们的适配器就得配置为【主机】，若是要去监控总线上的数据，那么我们设备就得配置为【从机】；  主机模式下，可配置同步间隔宽度，一般情况下默认13位即可；  VBAT输出可配置为12V，5V或者不输出，老版本的适配器不支持5V输出，只支持12V或者不输出，12V输出最大电流不能超过100mA；  适配器内部的5V转12V输出能力比较弱，最大输出电流大概有100mA左右，所以在外部设备功率不大的情况下，可以使用我们的设备12V给外部设备供电，在通信环境中有强电磁干扰的情况下，比如控制大电流继电器，大功率电机，这时把适配器的12V端口外接12V电源，可以大幅提升数据通信抗干扰能力；\n\r3. 数据显示视图 3.1 普通视图 \n\r\n\r\n\r  点击启动CAN或者LIN后，会自动打开一个普通数据显示视图，在这个视图界面里面，可以看到CAN或者LIN的原始数据，若同时启动了多个CAN或者LIN视图，可以新增CAN或者LIN视图进行数据查看，也可以在当前视图里面选择不同设备，不同通道的数据进行查看；  可将当前视图里面的数据导出为文件，也可以清空数据，暂停显示，滚动显示，还可以配置为更新显示；  点击【更新显示】后，会在当前视图的下方打开更新显示窗口，更新显示模式下，只会显示同一个ID最新的数据，若数据发生了变化，那么该字节数据会显示为蓝色，同时也会统计当前ID接收到的帧数；\n\r3.2 CAN视图显示设置 \n\r\n\r\n\r  点击CAN总线视图里面的【显示设置】后，可以弹出显示设置界面，在这个界面里面，可以对显示信息进行按需设置；\n\r3.3 LIN视图设置 \n\r\n\r\n\r  点击LIN总线视图里面的【显示设置】后，可以弹出显示设置界面，在这个界面里面，可以对显示信息进行按需设置；\n\r  3.4 CAN DBC视图  \n\r\n\r\n\r  点击【新增CAN视图】-&gt;【新增DBC视图】后，可以打开DBC数据解析视图界面，点击【打开文件】，选择需要进行数据解析的DBC文件，若适配器接收到了CAN数据，或者发送了CAN数据，那么数据就会在该界面进行解析显示；   若想实时将解析的数据保存为文件，可点击【保存数据】按钮，然后选择文件保存路径即可；\n\r   3.5 曲线视图 \n\r\n\r\n\r  点击【新增CAN视图】-&gt;【新增CAN曲线视图】后，即可打开数据曲线，表盘显示界面；   点击【加载DBC文件】按钮，选择DBC文件，然后在列表中选中需要显示数据的信号，点击鼠标右键，即可选择【曲线显示】，【表盘显示】，【布尔量显示】，每种显示效果如上图所示；   若没有DBC文件，那么也可以通过点击【新增信号】按钮，添加自定义信号，然后进行数据显示；   CAN和LIN数据图形显示方式都一样，不同的是CAN是使用DBC文件，LIN是使用LDF文件，所以后面就不单独对LIN数据图形显示做单独的介绍；\n\r   3.6 LIN LDF视图  \n\r\n\r\n\r  点击【新增LIN视图】-&gt;【新增LDF视图】，即可打开LDF视图界面，在该界面中，点击【打开文件】按钮，选择LDF文件后，再进行LIN数据收发时，就能实时解析LIN总线数据；  若需要将解析的数据实时保存为文件，可以点击【保存数据】按钮，然后选择数据文件存储路径即可；\n\r4. 发送CAN数据 4.1 普通发送 \n\r\n\r\n\r  点击【发送CAN数据】-&gt;【普通发送】后，即可打开普通CAN数据发送界面，如上图所示；  在需要进行简单的数据大量发送时，可以设置好发送次数，以及每次发送帧数，设置好之后点击【发送】按钮即可开始数据的发送，再次点击即可停止数据发送；  发送数据时可以设置ID递增，数据递增模式，数据也可以添加到列表里面进行发送；  列表中的帧可以顺序发送，也可以并行发送，并行发送时，延时时间最好能大于10ms，这样才能保证每帧的间隔时间基本准确；  列表中的数据可以写入到适配器内部后，将适配器通过USB充电器供电，即可自动循环发送列表中的数据，点击【写入设备】后，也可以配置为按钮触发方式发送，比如在LIN1跟GND之间接一个按钮，按下之后就发送一次；  若需要清除写入设备中的离线发送数据，可以在适配器固件升级界面进行清除；  点击发送数据界面上右上角的绿色加号，可以新增一个发送数据界面，如此可以实现同时发送多个通道的数据；\n\r4.2 DBC发送 \n\r\n\r\n\r  点击【发送CAN数据】-&gt;【DBC发送】后，可以打开DBC数据发送界面，如上图所示；  加载DBC文件后，可以在消息列表中点击鼠标右键将需要发送的消息添加到发送列表中，点击选中发送列表中的消息后，可以在下方设置该消息内部每个信号的值，信号值修改后会立即生效；  点击【列表发送】即可开始发送数据，数据可配置为顺序发送或者并行发送，再次点击可停止发送；\n\r4.3 DBC发送（信号变化） \n\r\n\r\n\r  点击【发送CAN数据】-&gt;【DBC发送(信号变化)】后，可以打开DBC信号数据变化发送界面，如上图所示；  将需要发送的帧添加到发送列表后（点击鼠标右键添加），选择需要变化数据发送的帧，然后在下方设置信号数据变化方式即可，每种变化都有对应的参数进行设置，需要配置好参数，否则可能无法得到预期的数据变化效果；  可以在曲线视图里面监控信号数据变化的信号数据，以此来验证发送出去的数据是否是自己预期的数据；\n\r4.4 数据回放 \n\r\n\r\n\r  点击【发送CAN数据】-&gt;【数据回放】后即可打开数据回放界面；  通过我们适配器抓到的CAN数据，然后将数据导出为文件后，可以将文件进行数据回放发送到CAN总线，或者是在软件内部回放；  回放数据的时候可以设置指定ID数据回放，或者过滤指定ID的数据；\n\r4.5 列表文件发送 \n\r\n\r\n\r  点击【发送CAN数据】-&gt;【列表文件发送】后即可打开列表文件发送界面；  选择列表文件所在目录，软件会自动识别当前目录下的文件类型，并将支持发送的文件名称在界面上显示出来；  点击列表中的【发送】按钮可以启动数据发送，再次点击可停止发送；  可以循环发送或者并行发送列表中的数据文件，也可以顺序发送列表中的数据文件；  数据在进行发送时，会显示数据发送进度，以及当前数据发送完毕百分比；\n\r5. 发送LIN数据 5.1 普通发送 \n\r\n\r \n\r  点击【发送LIN数据】-&gt;【普通发送】后即可打LIN数据普通发送界面；  发送数据必须在适配器被配置为【主机】模式后才能正常操作，因为只有LIN总线数据才能进行主动数据收发；  【数据类型】里面有【同步间隔】，【主机写】，【主机读】3个选项，【同步间隔】仅仅发送一个同步间隔信号，不会发送其他数据，发送同步间隔一般用于LIN总线上设备唤醒操作，【主机写】发送数据，除了发送正常的帧头之外，还可以发送数据，【主机读】只实现发送帧头，然后等待从机来填充数据域，最后将从机发送的数据接收到并传输到上位机端；  添加到发送列表中的数据，同样可以通过点击【写入设备】将数据写入适配器内部，适配器通过USB充电器供电后就可以自动发送列表中的数据；  列表中的数据可以导出文件，方便下次直接导入文件；\n\r5.2 LDF发送 \n\r\n\r \n\r  点击【发送LIN数据】-&gt;【LDF发送】后即可打LIN LDF数据发送界面；  界面内容会根据LDF文件内容自动生成，在主机模式下，可以设置发送出去的数据，也可以向从机读取数据，并解析显示在界面；  在从机模式下，接收到数据后，会根据LDF文件自动解析并显示在界面，也可以在界面设置需要向主机反馈的数据；  可以选择执行某一个调度表，也可以选择执行所有调度表；\n\r5.3 LDF列表发送 \n\r\n\r \n\r  点击【发送LIN数据】-&gt;【LDF列表发送】后即可打LIN   LDF列表数据发送界面；   相对【LDF发送】界面，列表模式发送界面可以灵活的添加需要发送的帧，同时更方便的编辑每个帧，每个信号的数据，推荐使用该模式发送数据；   在从机模式下，也可以编辑从机向主机返回的数据，但是在这个界面不能实时解析显示接收到的数据，需要解析显示数据，得在【新增LIN视图】-&gt;【新增LDF视图】界面进行查看； \n\r5.4 LDF列表发送(信号变化) \n\r\n\r \n\r  点击【发送LIN数据】-&gt;【LDF列表发送(信号变化)】后即可打LIN   LDF列表数据发送界面；  将需要发送的消息添加到发送列表后，点击某一个消息的某一个信号，可以编辑该信号的数据发送变化方式；  此模式发送数据只支持主机模式下发送数据，不能编辑从机模式下数据变化返回给主机；  编辑信号数据变化模式时，可以实时显示波形；\n\r5.5 UDS协议发送 \n\r\n\r \n\r  点击【发送LIN数据】-&gt;【UDS协议发送】后即可打LIN   UDS协议数据发送界面；  有的LIN设备数据通信需要用到UDS协议方式进行通信，在该界面发送界面更为方便，不需要自己去分包数据，只需要设置好服务ID，该ID对应的参数，底层会自动根据UDS协议方式打包数据并发送；  可以勾选是否需要响应数据，若需要响应数据，可设置数据响应超时时间，接收到响应的数据后，会在操作记录里面进行显示，底层所有的数据收发都会在【新增LIN视图】里面进行显示；  可以将需要的操作添加到列表里面循环执行，适用于对时间要求比较严格的应用场合；\n\r5.6 数据回放 \n\r\n\r \n\r  点击【发送LIN数据】-&gt;【数据回放】后即可打LIN数据回放界面；  在LIN视图里面保存的数据，可以在此处进行回放，回放时可以设置过滤某些ID的数据，或者指定发送某些ID的数据；  可以单独设置某些ID的校验模式，可以选择控制数据发送到总线或者只是在软件内部发送；\n\r5.7 列表文件发送 \n\r\n\r \n\r  点击【发送LIN数据】-&gt;【列表文件发送】后即可打LIN数据回放界面；  点击【选择目录】选择包含数据列表文件的目录，软件会自动识别所有支持的文件，然后在列表中显示出来，点击列表中的【发送】按钮，可以控制每个文件的数据发送；  点击【列表发送】按钮，可以顺序或者并行发送列表中的数据列表文件；  勾选【循环发送】后，数据可循环发送；\n\r5.8 设置从机响应数据 \n\r\n\r \n\r  点击【发送LIN数据】-&gt;【设置从机响应数据】后即可打开LIN从机模式下向主机返回数据的配置界面；  将需要反馈给主机的ID数据类型配置为【从机写】，然后配置好校验模式和数据即可，配置完毕后，点击【设置数据】按钮即可；   主机模式下该界面无效；\n\r6. 高级功能  6.1 CAN总线状态  \n\r\n\r  \n\r   点击【高级功能】-&gt;【CAN总线状态】后即可打开CAN总线状态界面；   在无法进行CAN数据收发时，可以打开该界面查看是否有CAN总线错误发生，如此可以初步判断问题所在；\n\r6.2 CAN总线中继  \n\r\n\r  \n\r   点击【高级功能】-&gt;【CAN总线中继】后即可打开CAN总线中继界面；   CAN总线中继可以在线转换，也可以写入设备，在设备中转换，在线转换延时较长，但是可以看到所有收发的数据，在设备上转换，延时最短，但是无法看到中继之后转发的数据；   将转换规则添加到列表后，软件会根据列表中的转换规则进行中继，列表中的转换规则数据可以导出为文件保存；\n\r6.3 CAN固件升级  \n\r\n\r  \n\r   点击【高级功能】-&gt;【CAN固件升级】后即可打开CAN固件升级界面；   该功能是实现对CAN总线上的节点进行固件升级，我们提供有固件升级协议文档，以及STM32单片机，TMS320F28335/2808芯片固件升级固件源码；   固件支持文件AES加密传输功能，可以保证固件安全性；\n\r6.4 CAN/LIN总线利用率  \n\r\n\r  \n\r   点击【高级功能】-&gt;【CAN/LIN总线利用率】后即可打开CAN/LIN总线利用率界面；   可试试显示当前总线数据收发速度，以及总线当前利用率，点击【实时保存】可以将数据实时保存到文件；\n\r6.5 LIN固件升级  \n\r\n\r  \n\r   点击【高级功能】-&gt;【LIN固件升级】后即可打开LIN固件升级界面；   跟CAN固件升级一样，也是实现对LIN总线上的节点进行固件升级，使用的协议跟CAN总线固件升级协议一样；   提供STM32F1单片机的固件源码，可以很方便的移植到其他单片机上；\n\r6.6 MLX芯片烧写  \n\r\n\r  \n\r  点击【高级功能】-&gt;【MLX芯片烧写】后即可打开迈来芯氛围灯芯片烧写界面；   打开软件后，可根据接入的设备数量，自动生成烧写列表，列表中可以单独烧写，也可以一键烧写，方便大批量量产；   可以设置循环烧写次数，每次烧写间隔时间，可以将烧写结果记录在文件中，方便自动化批量烧写芯片，提高生成效率；   也可以设置程序烧写完毕后自动发送功能测试指令，测试指令文件为【普通发送】里面保存出来的列表文件；\n\r6.7 CAN&amp;LIN互转  \n\r\n\r  \n\r   点击【高级功能】-&gt;【CAN&amp;LIN互转】后即可打开CAN&amp;LIN互转界面；   可以将转换规则添加到列表里面，点击【在线转换】后软件在线转换数据，注意，使用该功能，需要先启动CAN和LIN；   也可以点击【写入设备】将转换规则写入适配器内部，然后将适配器通过USB数据充电器供电后，自动进入数据转换模式；   LIN为主机或者为从机时，转换方式不太一样，具体转换规则可以参考界面上的转换说明；\n\r6.8 CAN转PWM  \n\r\n\r  \n\r   点击【高级功能】-&gt;【CAN转PWM】后即可打开CAN转PWM界面；   简单的说就是将接收到的CAN数据转换成PWM输出，具体转换规则参考软件上的转换说明，在我们软件安装目录下也有CAN转PWM的DBC文件，通过【DBC发送】可以分方便的发送数据；   收到CAN数据后，软件会根据收到的参数显示输出的PWM波形，通过软件上显示的波形可以初步评估输出的波形是否为我们需要的波形；   该功能适用于在没有CAN总线接口，而只有PWM控制接口的控制场合，\n\r6.9 PWM波形输出  \n\r\n\r \n\r   点击【高级功能】-&gt;【PWM波形输出】后即可打开PWM波形输出界面；   PWM是通过LIN总线接口输出PWM波形，勾选【使能适配器5V转12V】后，PWM输出的波形时12V，可不勾选，然后外接5到36V电压到12V电压接口，就可以实现5V到36V的PWM电压输出；   PWM输出最大频率建议不要超过100KHz，否则可能会导致波形上升沿比较缓慢，而波形比较差的情况；   可以在软件上配置波形输出时间，脉冲输出个数，也可以点击【写入设备】，再将适配器通过USB充电器供电后自动输出PWM方波；\n\r\n\r\n\r &nbsp;","TCANLINPro软件功能说明","topics\\软件使用/TCANLINPro软件功能说明.htm","9.4&nbsp;按键功能配置\n\r\n\r点击菜单【工具集合】-&gt;【按键功能配置】即可打开按键功能配置界面，打开后如下图所示：\n\r\n\r\n\r\n\r在适配器的LIN引脚和GND引脚之间接入一个常开按键，就可以用按键来控制其他CAN/LIN通道发送CAN/LIN数据，并且不需要上位机软件，只需要将适配器通过一个USB充电器给适配器供电就能实现按键控制CAN/LIN数据发送。\n\r  按键引脚根据实际硬件连接来选择，若选择为【无】，那么就是不接任何按键，直接上电后自动发送数据；\n\r  数据类型就是你要通过这个按键控制发送的数据，选择CAN或者LIN；\n\r  发送通道就是选择通过这个按键控制数据发送的通道号；\n\r  按键触发类型根据实际需求进行选择，按键输入默认是上拉输入，所以平时是高电平，一般可以选择【下降沿】或者【低电平】触发，【下降沿】触发就是按一次发送一次，【低电平】触发就是按下的时候一直发送，放开之后不发送；\n\r  点击【选择文件】选择需要发送的数据文件，这个文件在【发送CAN数据】-&gt;【普通发送】或者【发送LIN数据】-&gt;【普通发送】界面操作，也就是将数据添加到列表后，再导出的列表数据文件；\n\r  点击【写入设备】，数据会写入到适配器内部数据存储区域，然后将适配器通过一个USB充电器供电，大概10秒后就会进入按键控制功能。\n\r","9.4 按键功能配置","topics\\软件使用/TCANLINPro软件使用教程/9.4_按键功能配置.htm","3.2 CAN DBC视图\n\r\n\r点击菜单【新增CAN视图】-&gt;【新增DBC视图】即可打开普通CAN DBC视图，打开后如下图所示：\n\r\n\r \n\r\n\r1.打开DBC文件：在正常使用DBC文件解析CAN数据之前，需要先点击【打开文件】按钮，选择DBC文件，若解析后显示中文有乱码，可以根据文件的编码在软件上选择对应的编码格式。 \n\r\n\r2.显示过滤：若显示的数据太多，需要过滤显示数据，可以在【数据过滤】里面设置需要显示的数据关键词，这样界面上就可以显示只包含关键词的数据。 \n\r\n\r3.展开子项：点击【展开所有】按钮，可以展开所有子项，如此方便查看每一帧数据解析后的数据。 \n\r\n\r &nbsp;","3.2 CAN DBC视图","topics\\软件使用/TCANLINPro软件使用教程/CAN_DBC视图.htm","9.3&nbsp;CAN串口配置\n\r\n\r点击菜单【工具集合】-&gt;【CAN串口配置】即可打开CAN串口配置界面，打开后如下图所示：\n\r\n\r\n\r\n\r注意，只有支持串口控制的适配器才支持该功能，也就是型号为UTA0404的适配器才支持该功能。9.3.1 串口参数配置\n\r\n\r串口支持RS232和RS485总线，具体使用的引脚可以参考《引脚定义说明文档》，两种总线不能同时使用，某一个时刻只能使用其中一种，在适配器内部都是接入到相同串口的。\n\r\n\r通信协议使用的是Modbus-RTU协议，协议细节请参考《使用串口控制CAN和LIN实现数据收发》文档。9.3.2 CAN参数配置\n\r\n\rCAN参数配置主要是配置CAN波特率，若总线上没有终端电阻的话，需要选择使能终端电阻，若需要正常收发数据，则工作模式配置为【正常模式】。\n\r\n\r若需要其他波特率，可以将波特率选择为自定义，然后再下面填入对应的波特率参数即可。9.3.3 CAN调度表设置\n\r\n\rCAN可以配置发送数据调度表或者接收数据调度表，每个调度表最多只能配置32帧数据，需要根据实际需求配置好对应的ID和数据，若需要获取接收到的数据，或者是更改发送出去的数据，都可以通过串口进行控制。","9.3 CAN串口配置","topics\\软件使用/TCANLINPro软件使用教程/CAN串口配置.htm","8.4 CAN固件升级\n\r\n\r点击菜单【高级功能】-&gt;【CAN固件升级】即可打开CAN固件升级界面，打开后如下图所示：\n\r\n\r\n\r\n\r该功能为CAN Bootloader上位机功能，需要配合单片机程序才能正常使用，单片机程序可以使用我们提供的线程代码，或者是基于我们现成代码和协议移植的代码，其详细介绍可以参考《基于USB2CAN适配器实现的CAN Bootloader 》。","8.4 CAN固件升级","topics\\软件使用/TCANLINPro软件使用教程/CAN固件升级.htm","8.2 CAN过滤设置\n\r\n\r点击菜单【高级功能】-&gt;【CAN过滤设置】即可打开CAN接收过滤设置界面，打开后如下图所示：\n\r\n\r\n\r\n\r上图为简易设置界面，只需要把需要对应的ID填入界面中即可，然后选择是接收这些ID的数据还是不接收这些ID的数据，再点击【设置过滤器】即可生效。\n\r\n\r若需要接收指定范围ID的数据，那么可以使用【范围设置】来配置过滤规则，如下图所示：\n\r\n\r\n\r\n\r编辑完毕之后点击【设置过滤器】按钮后立即生效。","8.2 CAN过滤设置","topics\\软件使用/TCANLINPro软件使用教程/CAN过滤设置.htm","8.7 CAN&amp;LIN互转\n\r\n\r点击菜单【高级功能】-&gt;【CAN&amp;LIN互转】即可打开CAN&amp;LIN互转界面，打开后如下图所示：\n\r\n\r\n\r\n\rLIN可以根据实际需求配置为主机模式或者从机模式，不同模式下数据转换方式不一样，具体转换规则如下：\n\r\n\r\n\r\n\r注意，在CAN数据转到LIN数据时，若CAN_Data栏有数据，那么就需要将接收到的CAN数据跟列表里面填入的CAN数据进行对比，完全相同之后才会进行数据转换，若不需要对数据进行对比，则删除CAN_Data栏数据即可。LIN转CAN也一样。\n\r\n\r转换规则编辑完毕之后，点击【在线转换】即可，若需要进行离线转换，可以点击【写入设备】按钮，将转换规则数据写入适配器内部，再将适配器通过USB充电器供电即可。\n\r\n\r点击【新增一行】可新增一行规则数据。\n\r\n\r点击【清空列表】可以将现有列表中的数据清除。\n\r\n\r点击【保存文件】可以将列表中的规则数据保存为一个文件，方便下次直接打开使用。\n\r\n\r点击【打开文件】可以打开之前保存的规则数据文件。","8.7 CAN和LIN互转","topics\\软件使用/TCANLINPro软件使用教程/CAN和LIN互转.htm","6.3 CAN数据回放\n\r\n\r点击菜单【发送CAN数据】-&gt;【数据回放】即可打开普通CAN数据回放发送界面，打开后如下图所示：\n\r\n\r\n\r\n\r数据回放操作可以实现将抓到的CAN总线数据进行回放分析，同时也可以过滤某些不需要的数据，或者发送指定ID的数据。\n\r\n\r1.设备通道：选择已经启动了的CAN设备通道，若此处为空白，说明当前没启动任何设备通道；\n\r\n\r2.添加文件：选择需要进行数据回放的文件，这些文件可以为CAN普通视图界面保存的文件，也可以为普通发送数据界面保存的列表文件；\n\r\n\r3.发送到总线：勾选后，数据会通过CAN总线发送出去，若不勾选，则数据只是在软件内部发送，若打开了CAN视图，则会在CAN视图显示发送出去的数据；\n\r\n\r4.列表循环：勾选后会循环发送列表中的数据，直到手动停止为止；\n\r\n\r5.列表发送：点击后开始循环发送列表中的数据，再次点击停止发送；\n\r\n\r6.发送设置：点击列表中的设置图标，可以设置当前需要发送的ID，点击后如下图所示：\n\r\n\r\n\r\n\r可根据需求设置发送速度，发送速度大于1就是加速发送，发送速度小于1就是放慢发送，设置为1即为原速度发送；\n\r\n\r可根据需求设置发送步长，比如设置为100，那么每点击一次列表中的【发送】按钮，那么每次就发送100条数据，然后停止发送，再次点击【发送】按钮就再次发送100条数据，若需要连续发送，只需要设置为0或者-1即可；\n\r\n\rID列表中对应ID被勾选后就会被发送，若没有被勾选则不会被发送，ID若是x结尾的，则表示该ID为扩展帧ID。\n\r\n\r7.发送进度：发送进度栏可以指示当前数据发送进度，若需要改变发送数据起始位置，可以用鼠标拖动到想要发送的位置即可。\n\r\n\r&nbsp;\n\r\n\r&nbsp;\n\r\n\r&nbsp;","6.3 CAN数据回放","topics\\软件使用/TCANLINPro软件使用教程/CAN数据回放.htm","8.8 CAN转PWM\n\r\n\r点击菜单【高级功能】-&gt;【CAN转PWM】即可打开CAN转PWM界面，打开后如下图所示：\n\r\n\r\n\r\n\r打开这个界面后，若收到满足条件的CAN数据，那么就会自动转换成对应频率和占空比的PWM信号，并通过LIN通道输出，具体转换规则如上图所示。\n\r\n\r在软件安装目录下的“dbc_files/can2pwm.dbc”文件就是CAN转PWM的DBC文件，可以点击【发送CAN数据】-&gt;【DBC发送】，然后导入这个DBC文件，在界面上就可以设置PWM输出的相关参数，如下图所示：\n\r\n\r\n\r\n\r点击【列表发送】就能通过CAN总线发送我们设定的数据。\n\r\n\r&nbsp;","8.8 CAN转PWM","topics\\软件使用/TCANLINPro软件使用教程/CAN转PWM.htm","8.3 CAN总线中继\n\r\n\r点击菜单【高级功能】-&gt;【CAN总线中继】即可打开CAN中继界面，打开后如下图所示：\n\r\n\r\n\r\n\r转换规则说明：\n\r\n\r        &nbsp;ConvertType    &nbsp;转换说明      &nbsp;CAN1-&gt;CAN2    &nbsp;接收到CAN1帧之后，先根据规则对比数据（对比CAN1_ID,CAN1_Type,CAN1_IDE,CAN1_RTR,CAN1_Data(留空就不对比数据)），若条件满足，则根据DataType配置进行数据转发，若是原始转发，则收到CAN1什么数据就转发什么数据，若是特定数据，则发送CAN2_Data里面的数据。      &nbsp;CAN1&lt;-CAN2    &nbsp;接收到CAN2帧之后，先根据规则对比数据（对比CAN2_ID,CAN2_Type,CAN2_IDE,CAN2_RTR,CAN2_Data(留空就不对比数据)），若条件满足，则根据DataType配置进行数据转发，若是原始转发，则收到CAN2什么数据就转发什么数据，若是特定数据，则发送CAN1_Data里面的数据。      &nbsp;CAN1&lt;-&gt;CAN2    &nbsp;转换规则跟前两条一样，收到CAN1数据后向CAN2转发，收到CAN2数据后，向CAN1转发。\n\r\n\r编辑好转换数据后，点击【在线转换】会弹出如下界面：\n\r\n\r\n\r\n\r转换类型分【实时转换】和【在线转换】：\n\r\n\r【在线转换】——在线转换就是转换逻辑在上位机中实现，上位机收到CAN数据后，再根据转换规则来实现数据的转换，使用此方式实时性比较差，但是可以完整的看到CAN1和CAN2两端收发的数据，这种转换适用于数据速度不是很快，但是要完整查看转换数据的情况。\n\r\n\r【实时转换】——转换逻辑在适配器内部实现，实时性高，但是转发之后的数据在上位机软件中无法看到，若【中继类型】选择的是【自定义转换数据】，那么就会按照转换规则表里面的转换规则对数据进行转换，若是设置的【CAN1-&gt;CAN2】，那么CAN1收到的数据会直接通过CAN2转发出去，若是设置的【CAN1&lt;-CAN2】,那么CAN2收到数据之后会通过CAN1完整的转发出去，若是设置的【CAN1&lt;-&gt;CAN2】,则收到CAN1后通过CAN2转发，收到CAN2后通过CAN1转发。\n\r\n\r离线操作说明：\n\r\n\r若需要脱离上位机进行离线转换，可以点击【写入设备】将数据写入适配器，然后适配器通过普通的USB充电器供电，大概10秒后就会自动进入离线中继模式。\n\r\n\r点击【从设备读出】按钮，可以将写入设备的转换数据读出，并在列表中显示。\n\r\n\r其他操作说明：\n\r\n\r点击【新增一行】可以新增一行规则数据，点击【清空列表】，可以将规则列表中的数据清空，点击【打开文件】可以导入之前导出的文件，点击【保存文件】可以将列表中的数据导出为文件，方便下次导入使用。","8.3 CAN总线中继","topics\\软件使用/TCANLINPro软件使用教程/CAN总线中继.htm","8.1 CAN总线状态\n\r\n\r点击菜单【高级功能】-&gt;【CAN总线状态】即可打开CAN总线状态界面，打开后如下图所示：\n\r\n\r\n\r\n\r在进行CAN总线通信的时候，可能会因为各种原因导致通信不正常，打开这个界面可以做一些简单的诊断。\n\r\n\r比如在监控CAN总线数据的时候，不能监控到数据，打开CAN总线状态界面有接收错误，那么一般都是因为波特率不匹配导致。","8.1 CAN总线状态","topics\\软件使用/TCANLINPro软件使用教程/CAN总线状态.htm","6.2 CAN DBC发送\n\r\n\r点击菜单【发送CAN数据】-&gt;【DBC发送】即可打开普通CAN DBC数据发送界面，打开后如下图所示：\n\r\n\r \n\r\n\r打开DBC发送数据界面后，点击【选择文件】选择DBC文件，成功解析DBC文件后会在界面左边显示当前DBC文件里面包含的消息，双击消息名称即可将该消息添加到发送列表，也可以在消息名称上点击鼠标右键进行添加。将消息添加到列表后，选择对应的消息，下方就可以显示当前消息包含的信号，然后在信号列表里面就可以设置每个信号的值。\n\r\n\r数据设置好之后，点击【列表发送】即可发送列表中的数据，若发送次数为-1，则为循环发送数据，直到手动停止为止，若发送模式选择为并行发送，那么消息列表中的每个消息都会开启一个发送数据线程发送数据，数据发送间隔时间即为列表中的【间隔】值。","6.2 CAN DBC发送","topics\\软件使用/TCANLINPro软件使用教程/DBC发送.htm","7.2 LIN LDF发送\n\r\n\r点击菜单【发送LIN数据】-&gt;【LDF发送】，然后会弹出LDF文件选择对话框，选择好LDF文件后，软件会根据LDF文件自动生成数据发送界面，打开后如下图所示：\n\r\n\r\n\r\n\r每一个调度表显示在一个Table里面，可以选择执行某一个调度表，或者执行所有调度表，调度表界面中可以修改的数据为发送数据，不可以修改的为读取数据，界面上的数据修改后，需要点击【更新数据】才会将数据更新后通过LIN总线发送。\n\r\n\r1.设备通道：选择当前已经启动的LIN通道，若此处为空，则没有启动任何LIN通道；\n\r\n\r2.调度表：选择需要执行的调度表，最后一个选项为执行所有调度表；\n\r\n\r3.更新数据：若当前正在执行调度表，点击【更新数据】后，界面上的数据才会更新到LIN总线上，也就是说，更改了界面上的数据后，需要点击【更新数据】才能生效；\n\r\n\r4.循环执行：循环执行当前选择的调度表，需要手动停止执行；\n\r\n\r5.单次执行：点击一次执行一次调度表；\n\r\n\r6.LDF文件：选择当前需要解析显示的LDF文件；","7.2 LIN LDF发送","topics\\软件使用/TCANLINPro软件使用教程/LDF发送.htm","7.3 LIN LDF列表发送\n\r\n\r点击菜单【发送LIN数据】-&gt;【LDF列表发送】即可打开LIN LDF列表模式发送数据界面，如下图所示：\n\r\n\r\n\r\n\r界面主要分为4个区域，下面为每个区域的详细说明：\n\r  帧列表，从LDF文件里面解析到的帧列表，调度表。当选择某一帧或者某一个调度表后，点击鼠标右键，可以将该帧或者该调度表添加到待发送的帧列表中；\n\r  待发送的帧列表，B0到B7是该帧的数据，若当前字节数据显示为“XX”，说明该帧为读操作，数据是其他节点返回的，不需要在此处填入数据。若当前字节显示为“--”，说明当前字节是无效的，也无需填入；\n\r  帧信号列表，当在发送帧列表中选择某一帧后，此处显示当前选择帧的信号列表，若当前帧是可以编辑数据的，那么可以在信号列表中编辑待发送的数据；\n\r  信号值编码，当选择信号列表中的某一个信号之后，在此处显示当前信号的所有值编码。\n\r\n\r\n\r若当前通道配置为主机模式，当点击【列表发送】时，会将帧列表中勾选的帧依次发送出去，具体发送的数据或者从从机读取到的数据可以在【LIN视图】或者【LDF视图】中看到。\n\r\n\r若当前配置为从机模式，当点击【列表发送】时，会根据待发送帧列表中的数据配置从机ID模式，从机模式下，每一帧只能显示一行。\n\r\n\r&nbsp;","7.3 LIN LDF列表发送","topics\\软件使用/TCANLINPro软件使用教程/LDF列表发送.htm","4.2&nbsp;LIN LDF视图\n\r\n\r点击菜单【新增LIN视图】-&gt;【新增LDF视图】即可打开普通LIN LDF视图，打开后如下图所示：\n\r\n\r \n\r\n\r1.打开LDF文件： 在正常使用LDF文件解析LIN数据之前，需要先点击【打开文件】按钮，选择LDF文件，若解析后显示中文有乱码，可以根据文件的编码在软件上选择对应的编码格式。\n\r\n\r2.显示过滤：若显示的数据太多，需要过滤显示数据，可以在【数据过滤】里面设置需要显示的数据关键词，这样界面上就可以显示只包含关键词的数据。 \n\r\n\r  3.展开子项：点击【展开所有】按钮，可以展开所有子项，如此方便查看每一帧数据解析后的数据。 \n\r\n\r4.更新显示：若选择了【更新显示】，那么相同ID的数据只会显示最新的数据，历史数据会被覆盖，若不选择【更新显示】，那么会显示所有接收到的数据，注意，不用更新显示模式，随着接收到的数据增多，软件占用的内存也会增多，这种情况只适合于在数据量不多，或者接收数据时间不长的情况下使用。 ","4.2 LIN LDF视图","topics\\软件使用/TCANLINPro软件使用教程/LIN_LDF视图.htm","9.2&nbsp;LIN串口配置\n\r\n\r点击菜单【工具集合】-&gt;【LIN串口配置】即可打开LIN串口配置界面，打开后如下图所示：\n\r\n\r\n\r\n\r注意，只有支持串口控制的适配器才支持该功能，也就是型号为UTA0404的适配器才支持该功能。9.2.1 串口参数配置\n\r\n\r串口支持RS232和RS485总线，具体使用的引脚可以参考《引脚定义说明文档》，两种总线不能同时使用，某一个时刻只能使用其中一种，在适配器内部都是接入到相同串口的。\n\r\n\r通信协议使用的是Modbus-RTU协议，协议细节请参考《使用串口控制CAN和LIN实现数据收发》文档。9.2.2 LIN参数配置\n\r\n\r可以将LIN配置为从机或者主机模式，从机模式下可以将对应ID配置为主机发送数据或者从机接收数据，然后再通过串口来获取从机接收到的数据，或者是设置从机模式响应的数据。\n\r\n\r若配置为主机模式，则可以将对应ID配置为主机写或者主机读，然后再通过串口来设置主机发送出去的数据，或者获取主机读取到的从机数据。\n\r\n\r配置好参数后，点击【写入】即可写入适配器，适配器重新上电后生效，若需要读取之前写入的数据，则点击【读出】即可，数据会直接在软件界面上显示。","9.2 LIN串口配置","topics\\软件使用/TCANLINPro软件使用教程/LIN串口配置.htm","8.5 LIN固件升级\n\r\n\r点击菜单【高级功能】-&gt;【LIN固件升级】即可打开LIN固件升级界面，打开后如下图所示：\n\r\n\r\n\r\n\r该功能为LIN Bootloader上位机功能，需要配合单片机程序才能正常使用，单片机程序可以使用我们提供的线程代码，或者是基于我们现成代码和协议移植的代码，LIN升级使用的协议跟CAN升级使用的协议是类似的，其详细介绍可以参考《基于USB2CAN适配器实现的CAN Bootloader 》。","8.5 LIN固件升级","topics\\软件使用/TCANLINPro软件使用教程/LIN固件升级.htm","7.5 LIN列表文件发送\n\r\n\r点击菜单【发送LIN数据】-&gt;【列表文件发送】即可打开LIN列表文件发送界面，如下图所示：\n\r\n\r\n\r\n\r只有在LIN被配置为主机模式时才能使用该功能，选择列表文件目录后，会自动识别目录下的列表文件，然后根据文件名称在界面上显示，点击界面上的发送进度图标可以启动或者停止数据发送。","7.5 LIN列表文件发送","topics\\软件使用/TCANLINPro软件使用教程/LIN列表文件发送.htm","7.1 LIN普通发送\n\r\n\r点击菜单【发送LIN数据】-&gt;【普通发送】即可打开普通LIN数据发送界面，打开后如下图所示：\n\r\n\r\n\r\n\r界面主要分为【普通发送】和【列表发送】两部分。普通发送一般是发送较为简单的数据，列表发送可以发送较大量，多帧不同ID的数据。7.1.1 普通发送1.设备通道：选择需要发送数据的设备通道号，若此处为空白，说明没有任何设备通道启动，或者启动的通道配置为从机模式了，只有在主机模式下才能发送数据；\n\r\n\r2.数据类型： 可以选择【同步间隔】（只发送同步间隔）、【主机写】（发送同步间隔+0x55+PID+数据+校验）、【主机读】（发送同步间隔+0x55+PID，然后接收从机返回的数据）；\n\r\n\r3.帧ID： LIN数据对应的帧ID，若数据类型是【同步间隔】，该设置无效。无需填高2位的校验位，底层会自动加上，ID范围为0x00到0x3F；\n\r\n\r4.数据： 需要发送的LIN数据，最多为8字节，十六进制格式，每个字节之间用空格隔开，若数据类型是【同步间隔】和【主机读】，数据不需要填；\n\r\n\r5.编辑数据 ：按照二进制模式编辑数据；\n\r\n\r6.校验模式： 可以选择【标准校验】（只计算数据项）和【增强校验】（计算PID和数据项）；\n\r\n\r7.帧周期： 当前帧发送后的延时时间，单位为毫秒；\n\r\n\r8.发送次数： 当前数据发送次数；\n\r\n\r9.每次发送帧数： 每次数据发送帧数；\n\r\n\r10.每次间隔时间： 每次发送数据之间的间隔时间，单位为毫秒；\n\r\n\r11.ID递增： 勾选后，ID每次自动增加1，增加到0x3F之后重新从0x00开始；\n\r\n\r12.数据递增： 根据【起始字节】和【递增字节数】设置自动递增数据；\n\r\n\r13.发送进度： 显示当前数据发送进度；\n\r\n\r14.发送耗时： 显示当前数据发送消耗时间，单位为秒；\n\r\n\r15.添加到列表： 将当前数据添加到列表中；\n\r\n\r16.发送： 点击后开始发送数据，若正在发送数据，点击后停止发送数据；7.1.2 列表发送\n\r\n\r 列表操作：\n\r\n\r1.全选：点击后选中列表中的所有帧；\n\r\n\r2.反选：反选列表中的所有帧，去掉原来选中的，勾选原来没有选中的；\n\r\n\r3.上移：点击一次，将选中行整体上移一行；\n\r\n\r4.下移：点击一次，将选中行整体下移一行；\n\r\n\r5.删除：删除当前选中行；\n\r\n\r6.清空：清空列表中的所有数据；\n\r\n\r7.导入：导入之前导出的列表文件；\n\r\n\r8.导出：将列表中的数据导出为文件；\n\r\n\r离线操作：\n\r\n\r1.写入设备：点击后会将列表中的数据写入适配器，适配器通过USB充电器供电后（不接入电脑），会根据当前配置自动发送列表中的数据，实现离线发送数据功能；\n\r\n\r\n\r\n\r点击【写入设备】后会弹出如上图所示界面，这个界面用于控制数据的发送方式，若需要上电后自动循环发送数据，那么【按键选择】就选择【无】即可，若数据需要通过一个外部按键来控制，则选择对应的按键控制通道，比如选择LIN1，那么只需要在LIN1和GND之间接一个按键就能手动控制数据发送，触发类型一般选择为【下降沿】或者【低电平】，【下降沿】表示按下一次按键就控制数据发送一次，要松开后再次按下才会再次触发，而【低电平】表示按钮按下的时候发送数据，松开后就不发送数据了。\n\r\n\r2.从设备读出：将设备中的离线数据读出并在列表中显示出来；\n\r\n\r列表操作：\n\r\n\r1.发送次数：列表中的数据发送次数，若设置为-1，则循环发送数据，直到手动停止为止；\n\r\n\r2.循环发送：勾选后将循环发送列表中的数据，直到手动停止为止；\n\r\n\r3.列表发送：点击后开始发送列表中的数据；\n\r\n\r4.更新数据：若正在发送列表中的数据，且需要在不停止发送的时候更改发送数据，只需要更改列表中的数据后点击【更新数据】按钮即可。7.1.3 多通道同时发送\n\r\n\r若需要同时发送多个通道的数据，只需要点击下图箭头所示图标即可新增一个发送数据界面，然后在新增界面进行数据发送即可。\n\r\n\r\n\r\n\r然后切换到新的页面，编辑好数据，控制数据发送即可，两个页面数据发送是独立的，不会有任何干扰。","7.1 LIN普通发送","topics\\软件使用/TCANLINPro软件使用教程/LIN普通发送.htm"," 7.4 LIN数据回放\n\r\n\r 点击菜单【发送LIN数据】-&gt;【数据回放】即可打开LIN数据回放界面，如下图所示：\n\r\n\r&nbsp; \n\r\n\r 只有在LIN被配置为主机模式下才能使用数据回放功能。\n\r\n\r1.设备通道： 当被配置为主机模式的LIN设备通道，若当前选择为空，则表示当前没有启动为LIN主机模式的设备通道；\n\r\n\r2.发送到总线： 勾选后，数据会通过LIN总线发送出去，若不勾选，那么数据只在软件内部发送；\n\r\n\r3.列表循环： 勾选后会循环发送列表中的数据，直到手动停止为止；\n\r\n\r4.添加文件： 选择当前需要回放的数据文件，这个文件一般为LIN配置为从机模式时，在LIN总线上抓到的数据；\n\r\n\r5.列表发送： 点击后依次发送列表中被选中行的数据文件；\n\r\n\r6.发送设置：点击列表中的设置图标，可以设置当前需要发送的ID，点击后如下图所示：\n\r\n\r \n\r\n\r 设置界面会罗列文件中的所有ID，可以设置不同ID的数据类型，比如设置为主机写或者是主机读，只需要勾选对应的ID即可，若同一个ID在主机写和主机读里面都没有被勾选，那么这个ID不会被发送；\n\r\n\r可根据需求设置发送步长，比如设置为100，那么每点击一次列表中的【发送】按钮，那么每次就发送100条数据，然后停止发送，再次点击【发送】按钮就再次发送100条数据，若需要连续发送，只需要设置为0或者-1即可；\n\r\n\r7.发送进度：发送进度栏可以指示当前数据发送进度，若需要改变发送数据起始位置，可以用鼠标拖动到想要发送的位置即可。","7.4 LIN数据回放","topics\\软件使用/TCANLINPro软件使用教程/LIN数据回放.htm","8.5 MLX芯片读写\n\r\n\r点击菜单【高级功能】-&gt;【MLX芯片读写】即可打开MLX芯片读写界面，打开后如下图所示：\n\r\n\r8.5.1 概述\n\r\n\r在使用MLX81106/MLX81107/MLX81108/MLX81109/MLX80110芯片开发的车载氛围灯后，需要批量对芯片进行程序烧录，若一对一的烧录方式，其效率是比较低的，而且官方提供的烧录器价格昂贵，软件操作繁琐，且不支持一次性烧录多个芯片，基于此问题我们提供了一种更高效率，操作更简单的程序烧录解决方案，且支持自动测试。8.5.2 硬件连接\n\r\n\r将USB转LIN适配器的LIN口跟需要烧录程序的芯片LIN接口对接，一个USB转LIN适配器接一个或两个芯片，然后将多个USB转LIN适配器通过USB-HUB连接到电脑，如下示意图：\n\r\n\r\n\r\n\r如上图所示，我们可以并联多个适配器实现在软件上同时烧多个芯片，这样可以大大的提高芯片程序烧写效率。目前最新版本软件支持Fast LIN协议，烧写速度跟官方的LIN Master一致，但是我们支持多个适配器并行烧录，所以在烧写效率上将会大大提高。8.5.3 软件使用\n\r\n\r\n\r\n\r1，烧写设备列表\n\r\n\r烧写设备列表是在打开软件时根据当前连接到计算机的LIN适配器自动生成的，连接了多少个设备，那么就会自动生成对应数量的烧写列表；\n\r\n\r在每个烧写列表前有个勾选项，若当前通道不使用，则可以去掉勾选，在进行一键烧写的时候就不会对该通道进行任何操作；\n\r\n\r节点数即为当前通道LIN总线上所连接的MLX芯片数量，若当前只接了一个芯片，则设置为1即可，若设置大于1，则在烧录数据之前会自动分配节点地址，然后根据节点地址依次烧录；\n\r\n\r点击【写入】按钮可以手动烧写当前通道芯片；\n\r\n\r2，测试文件列表\n\r\n\r当芯片烧写完毕后，若在此处添加了测试文件，那么适配器会自动发送测试文件里面的LIN数据，比如可以在文件中编辑点亮LED的指令，芯片烧写完毕后就会自动点亮LED。测试列表文件在TCANLINPro软件的【发送LIN数据】-&gt;【普通发送】界面进行编辑。\n\r\n\r3，写数据设置\n\r\n\r选择引导程序，该程序为MLX官方提供的引导程序，可以找MLX官方代理索取；\n\r\n\r用户程序，为用户自己写的氛围灯功能程序，该文件一般向芯片程序开发人员索取；\n\r\n\rNVRAM文件，为芯片内部NVRAM/EEPROM区域数据文件，若此处为空，则不烧录NVRAM/EEPROM区域数据；\n\r\n\r日志文件，若需要记录烧录日志，那么选择日志文件保存路径即可；\n\r\n\r速度设置，目前速度设置范围为20Kbps到50Kbps，速度越低，烧写数据更不容易出错，但是烧写速度越慢，推荐最大设置为40Kbps；\n\r\n\r烧写次数，点击【一键烧写】后，会根据烧写次数进行烧写，每烧写完一次，剩余次数减一，直到烧写次数为0为止，每次烧写之间的时间间隔可设置；\n\r\n\r4，读数据设置\n\r\n\r读芯片数据，每次只能读取指定通道数据，可根据需求读取用户程序或者NVRAM/EEPROM数据，若芯片被设置为读保护，则无法读出数据；\n\r\n\r选择数据存储文件路径和名称后，设置好起始地址和读数据字节数（都为十六进制）后，点击【读出】就可以将芯片中的数据读到所选择的文件中，文件类型可选择hex文件和bin文件。","8.6 MLX芯片读写","topics\\软件使用/TCANLINPro软件使用教程/MLX芯片烧写.htm","8.9 PWM波形输出和探测\n\r\n\r点击菜单【高级功能】-&gt;【PWM波形输出】即可打开PWM输出界面，打开后如下图所示：\n\r\n\r\n\r\n\r根据自己实际需求，调整PWM输出相关参数，再点击【输出PWM】按钮即可在对应的LIN通道输出PWM信号，若需要停止输出只需要再次点击该按钮即可。\n\r\n\r若需要连续输出，【输出波形时间】设置为0即可。\n\r\n\r若需要探测PWM，则不能使能PWM输出，然后再点击【探测PWM】按钮，就可以自动探测到接入LIN总线接口的PWM信号。\n\r\n\r可根据自己需求，设置PWM输出占空比是否变化，软件支持\"等差循环变化\"，“等比循环变化\"，\"正弦波变化\"，\"三角波变化\"，\"矩形波变化\"，\"随机数变化\"，\"自定义序列\"这几种变化形式，占空比每10ms改变一次，比如设置的变化周期是1000，那么底层会按照100次变化为一个周期进行循环变化。","8.9 PWM波形输出和探测","topics\\软件使用/TCANLINPro软件使用教程/PWM波形输出.htm","概述\n\r\n\r此文档主要内容为TCANLINPro软件的功能说明和详细使用方法介绍。","TCANLINPro软件使用教程","topics\\软件使用/TCANLINPro软件使用教程/TCANLINPro软件使用教程.htm","6. 发送CAN数据\n\r\n\r 根据不同的数据发送需求，实现了多种不同的数据发送方式，用户可根据自己实际需求选择对应的数据发送方式。\n\r\n\r 【普通发送】：普通数据发送为原始CAN数据发送，可以单次发送数据，单次发送多帧数据，也可以把数据添加到列表里面循环发送，该发送适合于发送数据内容较为简单的应用场景。\n\r\n\r 【DBC发送】：根据已有的DBC文件进行数据发送，加载DBC文件之后可以将需要发送的消息帧添加到列表中进行单次或者循环发送，由于数据是经过DBC文件解析后显示的，所以可以很方便的修改待发送的数据。\n\r\n\r 【数据回放】：将CAN总线监控到的数据保存为文件后，可以使用数据回放功能将数据重新发送到CAN总线上。\n\r\n\r 【列表文件发送】：用户可将待发送的消息列表文件放在某一个目录下，然后选择该目录后会根据文件名称自动生成数据发送界面，在这个界面上可以很方便的控制数据的发送。","6. 发送CAN数据","topics\\软件使用/TCANLINPro软件使用教程/发送CAN数据.htm","7. 发送LIN数据\n\r\n\r根据不同的数据发送需求，实现了多种不同的数据发送方式，用户可根据自己实际需求选择对应的数据发送方式。\n\r\n\r【普通发送】：普通模式发送LIN数据，或者将数据添加到列表中循环发送；\n\r\n\r【LDF发送】：通过LDF文件生成数据发送界面；\n\r\n\r【LDF列表发送】：通过LDF文件发送数据，可以灵活的将不同帧添加到发送列表中，发送数据方式更加灵活，建议使用该方式；\n\r\n\r【数据回放】：将抓到的LIN总线数据保存为文件后，通过软件进行数据回放；\n\r\n\r【列表文件发送】：用户可将待发送的消息列表文件放在某一个目录下，然后选择该目录后会根据文件名称自动生成数据发送界面，在这个界面上可以很方便的控制数据的发送；\n\r\n\r【设置ID模式】：若将LIN适配器配置为从机模式，设置从机模式下不同ID的数据模式。\n\r\n\r&nbsp;","7. 发送LIN数据","topics\\软件使用/TCANLINPro软件使用教程/发送LIN数据.htm","\n\r\n\rTODO","8. 高级功能","topics\\软件使用/TCANLINPro软件使用教程/高级功能.htm","\n\r\n\r&nbsp;\n\r\n\rNew Topic (Press Shift-Enter to insert a line break. Press Enter to add a paragraph return.)","9. 工具集合","topics\\软件使用/TCANLINPro软件使用教程/工具集合.htm","1. 功能简介\n\r\n\rTCANLINPro是重庆图莫斯电子科技有限公司出品的USB转CAN/CANFD/LIN/PWM/K总线系列产品的配套软件，使用此软件可以实现原始数据收发，数据保存回放，高层协议分析、解析显示等功能，还可以进行CAN中继，LIN中继，CAN和LIN互转等操作，此外还可以将数据写入适配器实现离线数据发送，转换等功能。此软件操作简单而不失功能强大，是进行CAN/LIN总线测试、监控、诊断、开发的好帮手。\n\r\n\r本文档将对软件功能做详细的介绍，同时也会说明每个功能的详细使用方法，阅读此文档将带给您对TCANLINPro软件的最全面的认识。","1. 功能简介","topics\\软件使用/TCANLINPro软件使用教程/功能简介.htm","6.4 CAN列表文件发送\n\r\n\r点击菜单【发送CAN数据】-&gt;【列表文件发送】即可打开普通CAN列表文件发送界面，打开后如下图所示：\n\r\n\r\n\r\n\r当选择列表文件目录后，软件会自动识别当前目录下的列表文件，并在界面上显示出来，单击界面上的图标即可启动或者停止发送列表文件数据。\n\r\n\r1.设备通道：选择已经启动了的CAN设备通道，若此处为空白，说明当前没启动任何设备通道；\n\r\n\r2.列表文件目录：选择列表文件所在目录，选择后，会自动识别目录下的列表文件，然后在列表中罗列显示出来；\n\r\n\r3.发送模式：可以选择【顺序发送】和【循环发送】；\n\r\n\r4.列表发送：点击后开始并行或者顺序发送列表中的数据文件，再次点击则会停止发送；","6.4 CAN列表文件发送","topics\\软件使用/TCANLINPro软件使用教程/列表文件发送.htm","3.1 普通CAN视图\n\r\n\r点击菜单【新增CAN视图】-&gt;【新增CAN视图】即可打开普通CAN视图，打开后如下图所示：\n\r\n\r3.1.1 设备通道选择\n\r\n\r 若启动了多个设备或多个通道，那么在这里会显示所有已经启动了的通道，在这里选择对应的通道，界面上就显示对应通道的数据。软件使用了特殊的数据缓存技术，可以无限制接收数据，软件占用内存和CPU占用率并不会因为数据量的增加而增加；3.1.2 视图操作\n\r\n\r \n\r\n\r暂停显示： 勾选后，视图停止新数据的刷新，但是数据还是在后台继续保存，去掉勾选后会在界面显示最新接收到的数据；\n\r\n\r滚动显示： 勾选后，接收到新数据会自动滚动到最底下并显示新的数据，若不勾选，则不会自动显示最新的数据；\n\r\n\r显示设置： 点击后会探测显示设置界面，主要是设置视图中所显示的项目，显示颜色，时间戳格式；\n\r\n\r \n\r\n\r更新显示： 勾选后，会打开更新显示窗口，在该窗口会合并显示相同ID数据，若数据有发生变化，会以蓝色高亮颜色显示\n\r\n\r 3.1.3 数据操作\n\r\n\r \n\r\n\r打开文件： 点击后，可以导入之前保存好的文件在软件视图中显示，注意，打开文件会清空当前视图中的数据，支持的文件格式有【.cdat】，【.csv】，【.txt】，【.asc】；\n\r\n\r保存文件：将界面上显示的数据保存为文件，目前支持【.cdat】，【.csv】，【.txt】，【.asc】，【.html】格式文件导出。【.cdat】为二进制文件，文件占用空间最小，数据导出速度最快，缺点是不方便数据查看和编辑，但是可以使用软件的数据回放功能将数据在软件上显示。其他格式文件为可显示字符格式文件，导出的文件都可以通过记事本查看和编辑，缺点是导出的文件体积较大，导出速度相对较慢；\n\r\n\r清空数据： 清空当前显示窗口接收到的所有数据；\n\r\n\r自动保存： 勾选后，会按照设置的规则将数据自动保存到文件中；\n\r\n\r \n\r\n\r 保存方式有【定量保存】和【定时保存】两种方式，【定量保存】就是当保存数据的文件包含的CAN帧数达到设定值后，再将数据继续保存到新的文件中。【定时保存】则是按照设定的时间自动分隔保存文件，而不管文件的大小。\n\r\n\r数据过滤： 过滤显示当前视图接收到的CAN帧，比如只想看某个特定ID的数据，禁止数据过滤功能后，视图还是会显示所有数据，数据过滤功能只是过滤当前显示的数据，并不是过滤当前数据的接收；\n\r\n\r \n\r\n\r若【ID列表】为空，那么就是显示所有数据，若里面填入了CAN ID值，那么会根据过滤类型设置显示这些ID的帧或者是不显示这些ID的帧，若【数据值】留空，则不对帧数据进行对比，若填有数据，则需要对比帧数据域数据。\n\r\n\r &nbsp;","3.1 普通CAN视图","topics\\软件使用/TCANLINPro软件使用教程/普通CAN视图.htm","4.1 普通LIN视图\n\r\n\r点击菜单【新增LIN视图】-&gt;【新增LIN视图】即可打开普通LIN视图，打开后如下图所示：\n\r\n\r 4.1.1 设备通道选择\n\r\n\r若启动了多个设备或多个通道，那么在这里会显示所有已经启动了的通道，在这里选择对应的通道，界面上就显示对应通道的数据。软件使用了特殊的数据缓存技术，可以无限制接收数据，软件占用内存和CPU占用率并不会因为数据量的增加而增加；4.1.2 视图操作\n\r\n\r \n\r\n\r暂停显示： 勾选后，视图停止新数据的刷新，但是数据还是在后台继续保存，去掉勾选后会在界面显示最新接收到的数据；\n\r\n\r滚动显示： 勾选后，接收到新数据会自动滚动到最底下并显示新的数据，若不勾选，则不会自动显示最新的数据；\n\r\n\r显示设置： 点击后会探测显示设置界面，主要是设置视图中所显示的项目，显示颜色，时间戳格式；\n\r\n\r\n\r\n\r更新显示： 勾选后，会打开更新显示窗口，在该窗口会合并显示相同ID数据，若数据有发生变化，会以蓝色高亮颜色显示。\n\r\n\r4.1.3 数据操作\n\r\n\r\n\r\n\r打开文件： 点击后，可以导入之前保存好的文件在软件视图中显示，注意，打开文件会清空当前视图中的数据，支持的文件格式有【.ldat】，【.csv】，【.txt】，【.asc】；\n\r\n\r保存文件：将界面上显示的数据保存为文件，目前支持【.ldat】，【.csv】，【.txt】，【.asc】，【.html】格式文件导出。【.ldat】为二进制文件，文件占用空间最小，数据导出速度最快，缺点是不方便数据查看和编辑，但是可以使用软件的数据回放功能将数据在软件上显示。其他格式文件为可显示字符格式文件，导出的文件都可以通过记事本查看和编辑，缺点是导出的文件体积较大，导出速度相对较慢；\n\r\n\r清空数据： 清空当前显示窗口接收到的所有数据；\n\r\n\r自动保存： 勾选后，会按照设置的规则将数据自动保存到文件中；\n\r\n\r\n\r\n\r保存方式有【定量保存】和【定时保存】两种方式，【定量保存】就是当保存数据的文件包含的LIN帧数达到设定值后，再将数据继续保存到新的文件中。【定时保存】则是按照设定的时间自动分隔保存文件，而不管文件的大小。\n\r\n\r 数据过滤： 过滤显示当前视图接收到的LIN帧，比如只想看某个特定ID的数据，禁止数据过滤功能后，视图还是会显示所有数据，数据过滤功能只是过滤当前显示的数据，并不是过滤当前数据的接收；\n\r\n\r  \n\r\n\r 若【ID列表】为空，那么就是显示所有数据，若里面填入了LIN ID值，那么会根据过滤类型设置显示这些ID的帧或者是不显示这些ID的帧，若【数据值】留空，则不对帧数据进行对比，若填有数据，则需要对比帧数据域数据。","4.1 普通LIN视图","topics\\软件使用/TCANLINPro软件使用教程/普通LIN视图.htm","6.1 CAN普通发送\n\r\n\r点击菜单【发送CAN数据】-&gt;【普通发送】即可打开普通CAN数据发送界面，打开后如下图所示：\n\r\n\r\n\r\n\r界面主要分为【普通发送】和【列表发送】两部分。普通发送一般是发送较为简单的数据，列表发送可以发送较大量，多帧不同ID的数据。 6.1.1 普通发送\n\r\n\r1.设备通道：选择需要发送数据的设备通道号，若此处为空白，说明没有任何设备通道启动，需要先启动CAN后再进入这个界面进行数据发送；\n\r\n\r2.帧类型：选择CAN标准帧或扩展帧；\n\r\n\r3.CAN类型：若使用的设备支持CANFD，则可选择发送普通CAN帧，CANFD帧，CANFD加速帧。CANFD帧数据域最大可携带64字节数据，数据域波特率跟仲裁域波特率一致，CANFD加速帧，数据域会按照启动CAN时设置的波特率进行发送数据；\n\r\n\r4.帧格式：若是普通CAN帧，帧格式可选择数据帧或者远程帧，若是CANFD帧，则只能是数据帧；\n\r\n\r5.帧ID：CAN帧ID，数据格式为十六进制；\n\r\n\r6.帧周期：每发送一帧之后的延时时间，单位为毫秒；\n\r\n\r7.数据长度：CAN帧数据域长度，若实际填入的数据少于设置的数据长度，那么其他数据用0填充；\n\r\n\r8.数据：CAN数据，数据格式为十六进制，按照字节方式填入，不同字节之间以空格隔开；\n\r\n\r9.编辑数据：对数据域数据进行可视化编辑；\n\r\n\r10.发送次数：点击【发送】按钮后，循环发送次数，若将发送次数设置为-1，那么点击【发送】按钮后会循环发送数据，直到再次点击【发送】按钮为止；\n\r\n\r11.每次发送帧数：每次发送的CAN帧数；\n\r\n\r12.每次间隔时间：每次发送数据之间的间隔时间，单位为毫秒；\n\r\n\r13.ID递增：勾选后，若发送帧数设置为N，那么每次发送的N帧，每一帧ID都在前一帧的基础上加一；\n\r\n\r14.数据递增：勾选后，按照【起始字节】，【递增字节数】设置自动递增数据，数据的递增是在每次发送N帧数据实现的；\n\r\n\r15.发送进度：显示当前发送数据的进度；\n\r\n\r16.发送耗时：当前发送数据消耗时间，单位为秒；\n\r\n\r17.添加到列表：点击后将当前编辑的数据添加到列表中；\n\r\n\r18.发送：点击后开始发送数据，若当前正在发送，点击后可停止发送数据；6.1.2 列表发送\n\r\n\r【列表操作】里面包含如下功能：\n\r\n\r1.全选：点击后选中列表中的所有帧；\n\r\n\r2.反选：反选列表中的所有帧，去掉原来选中的，勾选原来没有选中的；\n\r\n\r3.上移：点击一次，将选中行整体上移一行；\n\r\n\r4.下移：点击一次，将选中行整体下移一行；\n\r\n\r5.删除：删除当前选中行；\n\r\n\r6.清空：清空列表中的所有数据；\n\r\n\r7.导入：导入之前导出的列表文件；\n\r\n\r8.导出：将列表中的数据导出为文件；\n\r\n\r离线功能操作：\n\r\n\r1.写入设备：点击后会将列表中已经选择的数据写入适配器，适配器通过USB充电器供电后（不接入电脑），会根据当前配置自动发送列表中的数据，实现离线发送数据功能；\n\r\n\r\n\r\n\r点击【写入设备】后会弹出如上图所示界面，这个界面用于控制数据的发送方式，若需要上电后自动循环发送数据，那么【按键选择】就选择【无】即可，若数据需要通过一个外部按键来控制，则选择对应的按键控制通道，比如选择LIN1，那么只需要在LIN1和GND之间接一个按键就能手动控制数据发送，触发类型一般选择为【下降沿】或者【低电平】，【下降沿】表示按下一次按键就控制数据发送一次，要松开后再次按下才会再次触发，而【低电平】表示按钮按下的时候发送数据，松开后就不发送数据了。\n\r\n\r2.从设备读出：将设备中的离线数据读出并在列表中显示出来；\n\r\n\r列表数据发送控制：\n\r\n\r1.发送模式：可选择【顺序发送】（按照列表先后顺序发送CAN帧）和【并行发送】（列表中的每一行数据为一个发送线程，每帧之间的间隔时间为列表中的延时时间）；\n\r\n\r2.发送次数：列表中的数据发送次数，若设置为-1，则循环发送数据，直到手动停止为止；\n\r\n\r3.循环发送：勾选后将循环发送列表中的数据，直到手动停止为止；\n\r\n\r4.列表发送：点击后开始发送列表中的数据，再次点击停止数据发送；6.1.3 多通道同时发送\n\r\n\r若需要同时发送多个通道的数据，只需要点击下图箭头所示图标即可新增一个发送数据界面，然后在新增界面进行数据发送即可。\n\r\n\r\n\r\n\r然后切换到新的页面，编辑好数据，控制数据发送即可，两个页面数据发送是独立的，不会有任何干扰。","6.1 CAN普通发送","topics\\软件使用/TCANLINPro软件使用教程/普通发送.htm","2.1 启动CAN总线2.1.1 CAN波特率参数设置\n\r\n\r点击对应CAN通道后面的【启动】按钮，软件会弹出CAN总线参数配置界面，如下图所示：\n\r\n\r\n\r\n\r1. 总线协议：若适配器支持CANFD，则可以选择【CANFD】，否则默认为【CAN】，CAN兼容于CANFD，所以是带CANFD的设备，默认选择【CANFD】即可；\n\r\n\r2. CANFD标准：根据实际情况选择【Non ISO】或者【CANFD ISO】；\n\r\n\r3. 工作模式：若需要向CAN总线进行真实的数据收发，则选择【正常模式】，若只是测试验证我们软件功能，可以选择【自发自收】模式，注意，【自发自收】模式下不能向CAN总线接收或者发送数据；\n\r\n\r4. 终端电阻：若总线上没有额外的120欧终端电阻，则需要在此选择【使能】，若不需要接入终端电阻，这选择【禁止】即可；\n\r\n\r5. 仲裁域波特率：普通的CAN只需要设置仲裁域波特率即可，可以在波特率表里面选择对应的波特率，若里面没有需要的波特率，可以点击【波特率计算器】按钮弹出波特率计算器界面，在这个界面里面设置好需要的波特率后可以自动计算出多组波特率参数供选择；\n\r\n\r6. 数据域波特率：若是使用的CANFD设备，且要实现数据域加速功能，则还需要设置数据域波特率，设置方法跟仲裁域波特率设置类似；\n\r\n\r7. 探测波特率：若不清楚总线波特率，可以点击【探测波特率】按钮探测当前总线波特率，不管总线是否有数据传输，都可以探测波特率；\n\r\n\r点击【确定】后即可启动CAN总线，若没有警告提示，则是成功启动了CAN总线，启动CAN总线之后就可以进行后续的数据收发功能。2.1.2 CAN波特率参数计算\n\r\n\r若需要设置的波特率不在可选列表中，则可以点击【波特率计算器】打开波特率计算器，自动计算需要的波特率参数。\n\r\n\r\n\r\n\r【CAN时钟】会根据当前接入的适配器自动填入正确的值，不用去修改它，【波特率】填入需要的CAN波特率值，单位为Kbps，然后设置好采样点和误差范围，点击【计算】，列表中就会罗列出满足条件的波特率参数，双击对应行就会自动返回CAN参数配置界面，并将当前参数自动填入设置界面。2.1.3 CAN波特率自动识别\n\r\n\r点击【探测波特率】后，会弹出如下界面：\n\r\n\r\n\r\n\r【快速探测】是用常规使用的波特率去探测总线波特率，大多数情况下使用该模式探测即可，若该模式探测不到，可以使用【精确探测】，弹出出来波特率之后，双击波特率参数行即可自动返回CAN参数配置界面，并将当前波特率值自动填入参数配置界面。\n\r\n\r&nbsp;","2.1 启动CAN总线","topics\\软件使用/TCANLINPro软件使用教程/启动CAN总线.htm","2.2 启动LIN总线2.2.1 LIN参数设置\n\r\n\r点击对应LIN通道后面的【启动】按钮，软件会弹出LIN总线参数配置界面，如下图所示：\n\r\n\r\n\r\n\r1. 波特率值：不管是将LIN配置为主机或者是从机模式，都必须设置好正确的波特率值才能进行正常的数据通信，若是去监控现成的LIN总线数据（现成LIN总线上有数据传输），可以点击【探测波特率】按钮来自动识别当前数据传输波特率，然后手动输入识别到的波特率即可；\n\r\n\r2. 主从模式：若是要监控LIN总线数据，或者是模拟LIN从设备向主设备反馈数据，那么需要在这里选择为【从机】，若是要控制从设备，或者是向从设备读取数据，则需要配置为【主机】；\n\r\n\r3. VBAT输出：控制适配器VBAT引脚电压输出对应电压，若LIN总线需要其他电压（比如24V），则可以在此选择0V，然后在VBAT引脚接入24V电压即可；\n\r\n\r4. 探测波特率：若不清楚LIN总线波特率，可以点击【探测波特率】探测总线波特率值。2.2.2 LIN波特率识别\n\r\n\r点击【探测波特率】按钮后会打开波特率探测界面，如下图所示：\n\r\n\r\n\r  若所接总线上本身有数据在传输，比如有个LIN主机正在控制LIN从机进行数据传输，这种情况下可以勾选【总线上接有其他主机，并且有数据在传输】，提高波特率探测速度；  若只有一个从机，没有其他主机控制这个从机，那么就不要勾选【总线上接有其他主机，并且有数据在传输】，这样才有可能探测到波特率，这种情况下，也可能因为从机没有ID响应数据而导致探测不到波特率；  由于串行传输数据是可以容忍一定的误差的，所以可能会探测出来多个波特率值，实际使用的时候取中间值即可。\n\r\n\r\n\r&nbsp;\n\r\n\r&nbsp;","2.2 启动LIN总线","topics\\软件使用/TCANLINPro软件使用教程/启动LIN总线.htm","2. 设备管理\n\r\n\r\n\r\n\r打开软件后会默认打开设备管理视图，若在打开软件之前已经成功将设备连接到电脑，那么在设备管理界面会显示已经识别到的设备，若是先打开软件，再连接的设备，那么可以点击下【扫描设备】按钮来识别已经连接的设备。","2. 设备管理","topics\\软件使用/TCANLINPro软件使用教程/设备管理.htm","7.6 LIN设置从机ID模式\n\r\n\r点击菜单【发送LIN数据】-&gt;【设置ID模式】即可打开LIN从机ID模式设置界面，如下图所示：\n\r\n\r\n\r\n\r只有在LIN为从机模式时才能配置从机ID模式，可以将ID模式配置为【从机读】（接收到帧头后继续接收主机发送的数据）和【从机写】（接收到帧头之后，向LIN总线发送提前设置好的数据），点击【设置ID模式】按钮后生效。","7.6 LIN设置从机ID模式","topics\\软件使用/TCANLINPro软件使用教程/设置从机ID模式.htm","  5. 视图管理\n\r\n\r   \n\r\n\r  点击【视图管理】菜单，可以显示或者隐藏当前已经创建的视图。\n\r\n\r  &nbsp;","5. 视图管理","topics\\软件使用/TCANLINPro软件使用教程/视图管理.htm","9.1&nbsp;适配器固件升级\n\r\n\r点击菜单【工具集合】-&gt;【适配器固件升级】然后会弹出如下提示：\n\r\n\r\n\r\n\r点击【Yes】按钮就会进入产品固件升级界面，如下图所示：\n\r\n\r\n\r\n\r若【选择设备】里面是空的，可以点击下【扫描设备】按钮，若还没有，说明没有识别到设备，得在电脑的设备管理器里面查看下设备驱动是否正常，或者检查下设备跟电脑连接是否正常。9.1.1 固件下载\n\r\n\r若电脑是联网的，可以点击【下载固件】在线下载最新版本的固件，点击后如下图所示：\n\r\n\r\n\r\n\r可以双击列表中对应版本的文件，软件就会自动下载固件，下载完毕后会将固件文件路径自动填入到【固件文件】处。\n\r\n\r若列表中没有文件，可以点击【手动下载】到百度网盘下载对应的固件，或者联系我们技术支持提供最新版本的固件。9.1.2 升级固件\n\r\n\r下载好固件后，若在【固件文件】栏是空的，则需要点击【打开固件】手动选择固件文件路径，然后再点击【升级固件】即可，升级成功后会出现如下提示：\n\r\n\r9.1.3 其他操作\n\r\n\r点击【信息查询】可以查询到当前适配器的固件信息，主要是看编译日期和固件版本号，还有固件功能说明。\n\r\n\r点击【擦除数据】可以擦除适配器用户存储区域数据，比如之前有写入一些离线发送CAN/LIN数据，可以在这里将写入的数据全部擦除。\n\r\n\r&nbsp;\n\r\n\r&nbsp;","9.1 适配器固件升级","topics\\软件使用/TCANLINPro软件使用教程/适配器固件升级.htm","3. 新增CAN视图\n\r\n\r若需要显示CAN数据，则需要点击【新增CAN视图】菜单，然后根据实际情况打开对应的CAN视图，比如CAN DBC视图。","3. 新增CAN视图","topics\\软件使用/TCANLINPro软件使用教程/新增CAN视图.htm","4. 新增LIN视图\n\r\n\r若需要显示LIN数据，则需要点击【新增LIN视图】菜单，然后根据实际情况打开对应的LIN视图，比如LIN LDF视图。","4. 新增LIN视图","topics\\软件使用/TCANLINPro软件使用教程/新增LIN视图.htm","1.1 主界面结构\n\r\n\r\n\r\n\r软件主界面分为工具栏、设备管理视图、数据显示视图三大部分，具体如下：\n\r\n\r1. 工具栏： 实现对软件的每个功能进行打开或者关闭，不同的菜单下面包含了不同的功能，点击对应菜单的对应功能后会在主界面显示，或者以对话框的方式显示，不同版本的软件可能细节有所不同，具体功能以对应版本软件为准。\n\r\n\r2. 设备管理： 默认打开的视图，也可以根据实际情况关闭，主要是管理当前软件扫描到的设备，同时管理每个设备的CAN或者LIN通道的启动或停止。在没有启动CAN和LIN设备时，还可以查询当前设备信息，比如固件版本号，设备具备的功能等。\n\r\n\r3. 数据视图： 显示CAN或者LIN的原始数据，或者是经过上层协议解析过数据，可以同时打开多个视图，CAN和LIN的视图是分栏显示的，可以上下调整每个视图的显示高度。","1.1 主界面结构","topics\\软件使用/TCANLINPro软件使用教程/主界面结构.htm","目录\n\r  前言\n\r  主机模式读写\n\r  从机模式读写\n\r前言\n\r\n\r本文主要介绍USB2IIC软件的使用方法，并给出了I2C主机模式下对从机的常见3种操作模式，并给出了不同模式下I2C总线上输出的具体波形图，阅读本文对使用USB2IIC软件有非常大的帮助。\n\r\n\r软件的下载安装请参考《USB2XXX快速入门》。\n\r\n\rI2C总线硬件连接请参考《引脚定义说明文档》。\n\r\n\rI2C总线二次开发API函数说明请参考《usb2iic》\n\r\n\r\n\r\n\r打开软件后，主界面如下：\n\r\n\r\n\r\n\r设备索引：选择需要控制的USB2XXX设备，若当前有多个USB2XXX设备接入电脑，那么在这里就会有多个选择，若只接了一个，则只有一个选择，若此处是空白的，没有可选项，那么可能是没有接入USB2XXX设备或者是USB2XXX的驱动没能正常安装。\n\r\n\r通道索引：选择当前需要控制的I2C总线通道，每个通道对应的具体引脚可以参考《引脚定义说明文档》。\n\r\n\r主从模式：当前USB2XXX适配器的I2C为主机模式还是从机模式，若需要去控制从机，那么必须配置为主机模式，若需要接收主机发送的数据或者向主机返回数据，则选择为从机模式。\n\r\n\r内部上拉：I2C总线接口是开漏模式，所以要正常传输数据，I2C总线上必须接上拉电阻，若外接I2C总线上没有上拉电阻，则可以在软件上选择使能内部上拉（内部上拉电阻较大，大概为40K，建议还是外接1K到10K范围内的上拉电阻）。\n\r\n\r地址模式：当前I2C从机使用的地址模式，目前大多数I2C从机是使用的7bit地址，根据自己的从机就行对应选择即可，若对I2C的从机地址不是很明白，可以参考《IIC/I2C从地址之7位，8位和10位详解》文档。\n\r\n\r时钟频率：当前I2C总线的时钟频率，根据从机支持的最大时钟频率进行选择，若I2C总线接线太长，建议尽量降低时钟频率，这样可以减少数据传输出错的可能。\n\r\n\r从机地址：接到I2C总线上的从设备地址，该地址不包含读写位，比如24系列EEPROM包含读写位的地址一般是0xA0，那么去掉读写位之后的地址就是(0xA0&gt;&gt;1) = 0x50。若不清楚从机地址，可以点击菜单“操作”-&gt;“扫描从机”进行自动识别从机地址。\n\r\n\r接口电压：选择当前I2C总线输出的高电平电压，此选项只针对带电平转换功能的USB2XXX适配器有效。主机模式读写基础读写写数据\n\r\n\r点击“写数据”按钮，适配器会将界面中发送数据框中的数据发送到总线上，若发送从机地址时，若从机没有应答，那么后续的数据不会再继续发送。界面设置跟总线输出波形如下图所示：\n\r\n\r\n\r\n\r读数据\n\r\n\r点击“读数据”按钮，适配器会向总线上发送从机地址加读数据位，若从机有应答，则开始向从机读取数据，读取数据字节数为软件上设置的“读字节数”参数，读数据时软件设置和总线输出的波形如下图所示：\n\r\n\r\n\r\n\r写读数据\n\r\n\r点击“写读数据”，适配器会先将发送数据框中的数据发送出去，然后不产生STOP信号，直接产生RSTART信号开始向从机读取数据，该操作常用于向从机指定寄存器读取数据操作，写读数据操作软件设置和总线输出波形图如下所示：\n\r\n\r\n\r\n\r寄存器读写写数据\n\r\n\r点击“写数据”，适配器会在要发送的数据前面加上寄存器地址数据，地址字节数据由软件界面上设置，软件设置和对应的波形图如下所示：\n\r\n\r\n\r\n\r读数据\n\r\n\r点击“读数据”，适配器会先发送从机地址和寄存器地址，然后产生RSTART信号，向从机读取数据，读数据字节数为软件上设置的“读数据字节数”。读数据软件设置跟对应的波形如下图所示：\n\r\n\r\n\r\n\r列表读写\n\r\n\r列表模式读写数据是指将多个不同的操作放到一个列表里面，然后可以循环执行或者单次执行这个列表，因为在实际使用中，很多芯片的读写控制是需要按照一定的先后顺序发送指令的，同时也对时间有较为严格的要求，所以若都只是通过手动的收发数据，可能达不到实际的测试效果。\n\r\n\r\n\r  添加一行操作到列表，添加到列表后，可以根据实际情况选择操作类型，设置需要发送的数据或者需要读取的数据字节数，以及该条操作完成后需要的延时时间。  删除当前选择的列表行。  循环执行列表，点击后会循环执行列表中的所有指令，再点击下停止执行指令。  单次执行列表中的所有指令，点击一次就执行一次。  将列表中的所有数据保存为文件，方便下次直接打开使用。  打开之前保存到本地目录的列表文件。\n\r从机模式读写写数据\n\r\n\r在软件上配置为从机后，点击界面上的“写数据”，数据会写入适配器内部数据缓冲区中，这时主机端就可以通过读数据操作将从机发送数据缓冲区的数据读回，主机写数据操作界面如下图所示：\n\r\n\r读数据\n\r\n\r在软件上配置为从机后，点击界面上的“读数据”按钮，即可将从机接收数据缓冲区中的数据读到软件界面上显示，若从机接收数据缓冲区中没有数据，则不会有任何显示。\n\r\n\r主机发送数据给从机后，从机端并不会主动将数据显示在软件界面上，而需要手动点击“读数据”按钮才能读回数据并在主界面显示出来。","USB2IIC软件使用教程","topics\\软件使用/USB2IIC软件使用说明教程.htm","目录\n\r    前言    硬件连接    软件下载安装    软件使用\n\r\n\r\n\r\n\r\n\r前言\n\r\n\r使用该软件，可以非常方便的实时监控产品各个工作状态下的工作电流，瞬时功耗，同时也可以实时监控产品供电电压。数据可实时显示，波形显示，同时也可以实时记录到文件，方便后续进一步分析。硬件连接\n\r\n\r硬件连接如下图所示：\n\r\n\r\n\r\n\r注意：电源接口分输入和输出，输入接产品供电电源，输出接产品，若启动软件的时候勾选了【启动时自动调零】，则需要接入输入口电源接线，同时断开输出口电源接线。\n\r\n\r\n\r\n\r软件下载安装\n\r\n\r软件下载地址：http://www.toomoss.com/download/8-cn.htmlWindows系统：\n\r\n\r将软件文件从网站上下载下来之后，双击即可启动安装，一路下一步即可，软件安装最后一个步骤是安装USB驱动程序，也一路点击下一步即可，驱动正常安装后，在设备管理器里面的状态如下图所示：\n\r\n\r\n\r\n\r若在设备管理器里面，设备上有黄色叹号，那么驱动安装可能有问题，可以按照如下教程处理下：\n\r\n\rWin10怎么禁用驱动程序强制签名\n\r\n\r若还不能正常工作，可以联系我们技术支持解决问题。软件使用\n\r\n\r安装好软件后，在桌面会有如下图所示图标：\n\r\n\r\n\r\n\r双击该图标即可启动软件，启动软件后主界面如下图所示：\n\r\n\r\n\r\n\r若在启动软件的时候将功耗分析仪通过USB跟电脑连接后，会在【设备管理】栏目显示识别到的设备，若在此处没显示，那么可能是设备的驱动没正常安装，或者没有将设备接入电脑。启动设置\n\r\n\r软件识别到设备后，在【设备管理】里面点击【CH1】后面的【启动】按钮，弹出启动设置界面，如下图所示：\n\r\n\r\n\r\n\r采样频率：最低支持1Sps，最高支持500KSps，采样率越高，越能看到更多的电流变化细节，采样率越低，越能看到更多时间的数据，根据实际使用情况设置即可。\n\r\n\r显示点数：软件波形显示数据点数设置，设置越大，能显示的数据点数越多。\n\r\n\r使用调零参数：默认都是需要开启的，在出厂时已经写入调零参数到设备，但是在实际使用的时候若发现不接被测设备，也有较大的电流数据，那么需要在启动的时候勾选【启动时自动调零】，调零后数据会自动写入设备，下次使用就无需再调零。\n\r\n\r启动时自动调零：若在输出电源悬空，同时接入输入电源情况下，软件上输出的电流比较大，比如大于5uA级别，那么就需要勾选此项进行自动调零。自动调零后，调零数据会掉电保存，下次启动就不用再勾选了。\n\r\n\r设置好之后点击【OK】按钮即可启动电流电压监控。数据分析查看查看全部数据\n\r\n\r启动后，若在界面看不到数据曲线，可能是因为数据比较小，或者是太大，超出了波形显示的范围，可以在波形界面点击鼠标右键，然后再点击【全显】就能自动缩放数据，然后以最佳视图方式显示，如下图所示全显前后效果：\n\r\n\r\n\r\n\r\n\r\n\r&nbsp;\n\r\n\r将鼠标移动到波形窗口，然后滚动鼠标的滚轮，也可以对波形数据进行缩放。查看部分数据\n\r\n\r若想查看某一部分的数据细节，可以在波形窗口用鼠标左键框选需要显示的数据区域即可，如下图所示：\n\r\n\r\n\r\n\r释放鼠标左键后，会自动将框选区域内的数据填充到整个波形显示窗口，更易于查看数据细节。分析部分数据\n\r\n\r若想对某一部分的数据进行统计分析，比如需要分析一段数据的时间长度，数据最大值和最小值之差，数据的平均值，那么可以在需要分析的数据起始点点击鼠标左键，出现绿色十字光标，然后再在结束数据点点击鼠标左键，出现绿色十字光标，在波形界面左上角就会显示这段数据值，如下图所示：\n\r\n\r\n\r\n\rX2-X1为两个数据点的时间差，Y2-Y1为两个数据点的纵轴数据差，平均值为两个数据点之间的纵轴数据平均值，黄色十字光标会跟随鼠标移动，同时在曲线窗口左上角显示当前游标对应点的值。实时数据显示\n\r\n\r\n\r\n\r在实时数据栏目会实时显示当前检测到的最新数据，其中最大值和最小值是在开始监控后，所有数据的最大和最小值，平均值也是从启动监控开始的所有数据平均值。\n\r\n\r除了实时显示电压、电流、功率值外，还对当前耗电量进行统计，通过该值和设备供电电池容量，可以分析出当前电池能给当前设备供电的时间。实时记录数据到文件\n\r\n\r点击【功率分析视图】界面上的【自动保存】按钮，弹出自动记录数据到文件的设置对话框，如下图所示：\n\r\n\r\n\r\n\r数据保存方式可以设置为【定时保存】或者【定量保存】，【定时保存】是根据设置的定时时间自动保存文件，比如设置定时时间为1分钟，那么在1分钟内的数据就会保存到一个文件内，下一分钟内的数据自动保存到下一个文件中，以此类推。\n\r\n\r【定量保存】则是文件保存到一定量的数据量之后，自动将新的数据保存到新的文件中。\n\r\n\r启动自动保存文件后，只需要再次点击该按钮，就可以停止数据保存。数据平滑\n\r\n\r若使用的电源是常规的开关电源，那么在电源上就会有较大的纹波，使用数据平滑功能可以过滤掉这些纹波，方便对数据进行分析查看。\n\r\n\r数据平滑滑块拉倒最左边，为不使用数据平滑功能，若拉倒最右边，则是将2000个数据进行滑动滤波处理，使用数据平滑会导致数据瞬时变化失真，所以不建议设置到最大值，大家根据实际使用情况设置即可。&nbsp;","功耗分析仪软件使用教程","topics\\软件使用/功耗分析仪软件使用教程.htm","概述\n\r\n\r软件使用说明文档","软件使用","topics\\软件使用/软件使用.htm","不带外壳版本（UTA0101,UTA0201）\n\r\n\r接线说明：\n\r\n\r1，适配器大部分引脚都有多个功能，在使用不同的软件或者调用不同的接口函数后，就会自动分配成对应的功能；\n\r\n\r2，适配器上的电源输出最大电流为400mA，若外部设备功耗大于这个值，则不推荐用我们适配器上的电源供电，否则可能导致适配器工作不正常；\n\r\n\r3，跟其他任何设备进行连接，GND都是必须要接的，而且推荐先接GND，否则有可能会损坏适配器！带外壳版本(UTA0301,UTA0302)\n\r\n\r接线说明：\n\r\n\r1，请注意缺口的方向位置！将适配器接口正对着自己，缺口在左边；\n\r\n\r2，1.8V电源接口是一个可变电压输出接口，可以通过DEV_SetPowerLevel函数设置输出电压；\n\r\n\r3，P0到P7跟D0到D7是共用接口，比如在进行I2C监控功能的时候需要用到D0，D1接口，其实也是接到P0，P1接口上的；\n\r\n\r4，跟其他任何设备进行连接，GND都是必须要接的，而且推荐先接GND，否则有可能会损坏适配器！USB2CAN&amp;LIN基础版(UTA0401)接线说明：\n\r\n\r1，使用LIN总线功能时，接LIN和GND引脚即可，GND必须接，建议先接GND，否则有烧适配器的风险；\n\r\n\r2，12V引脚为12V电压输出，可以给外部设备供电，若外部设备自己有电源供电，则无需连接。12V电源输出电流最大100mA，所以外部设备功率较大，则不能使用我们适配器供电；\n\r\n\r3，使用CAN总线功能只需要接H和L即可，无需连接GND引脚；\n\r\n\r4，要接入CAN总线的120欧终端电阻，只需要在上位机软件上勾选“接入120欧终端电阻”选项即可。USB2CAN&amp;LIN增强版和升级版(UTA0402,UTA0403,UTA0503)\n\r\n\r接线说明：\n\r\n\r1，使用LIN总线功能时，接LIN和GND引脚即可，GND必须接，接口上的两个GND在内部是连通的；\n\r\n\r2，VBAT引脚为12V电压输出，可以给外部设备供电，若外部设备自己有电源供电，则无需连接。12V电源输出电流最大100mA，所以外部设备功率较大，则不能使用我们适配器供电；\n\r\n\r3，若LIN不是12V电压，可以在软件上关闭电压输出，然后将VBAT接到对应的电压电源上即可；\n\r\n\r4，使用CAN总线功能只需要接H和L即可，无需连接GND引脚；\n\r\n\r5，要接入CAN总线的120欧终端电阻，只需要在上位机软件上勾选“接入120欧终端电阻”选项即可。\n\r\n\rUSB2CAN&amp;LIN串口版（UTA0404）\n\r\n\r              \n\r\n\r引脚号          \n\r\n\r名称          \n\r\n\r说明            \n\r\n\r1          \n\r\n\rVBAT          \n\r\n\rLIN工作所需电压，可以软件控制输出12V，输出电流约100mA，若软件上不使能内部5V转12V，则需要外接LIN总线电压，LIN总线才能正常工作，电压范围为5~36V。            \n\r\n\r2          \n\r\n\rLIN2          \n\r\n\rLIN2数据线            \n\r\n\r3          \n\r\n\rGND          \n\r\n\rLIN总线负极            \n\r\n\r4          \n\r\n\rLIN1          \n\r\n\rLIN1数据线            \n\r\n\r5          \n\r\n\rGND          \n\r\n\rLIN总线负极            \n\r\n\r6          \n\r\n\rRS232_RX          \n\r\n\rRS232总线的数据接收引脚            \n\r\n\r7          \n\r\n\rRS232_TX          \n\r\n\rRS232总线的数据发送引脚            \n\r\n\r8          \n\r\n\rVIN-          \n\r\n\r外接电源负极            \n\r\n\r9          \n\r\n\rCAN1_H          \n\r\n\rCAN1总线H            \n\r\n\r10          \n\r\n\rCAN1_L          \n\r\n\rCAN1总线L            \n\r\n\r11          \n\r\n\rCAN2_H          \n\r\n\rCAN2总线H            \n\r\n\r12          \n\r\n\rCAN2_L          \n\r\n\rCAN2总线L            \n\r\n\r13          \n\r\n\rRS485_B          \n\r\n\rRS485总线B端            \n\r\n\r14          \n\r\n\rRS485_A          \n\r\n\rRS485总线A端            \n\r\n\r15          \n\r\n\rVIN+          \n\r\n\r外接电源正极，范围为7~18V，推荐使用9V或者12VUSB2CAN&amp;LIN按键版（UTA0405）\n\r\n\r              \n\r\n\r引脚号          \n\r\n\r名称          \n\r\n\r说明            \n\r\n\r1          \n\r\n\rVBAT          \n\r\n\rLIN工作所需电压，可以软件控制输出12V，输出电流约100mA，若软件上不使能内部5V转12V，则需要外接LIN总线电压，LIN总线才能正常工作，电压范围为5~36V。            \n\r\n\r2          \n\r\n\rLIN2          \n\r\n\rLIN2数据线            \n\r\n\r3          \n\r\n\rGND          \n\r\n\rLIN总线负极            \n\r\n\r4          \n\r\n\rLIN1          \n\r\n\rLIN1数据线            \n\r\n\r5          \n\r\n\rGND          \n\r\n\rLIN总线负极            \n\r\n\r6          \n\r\n\rKEY_P13          \n\r\n\r按键P13引脚，悬空为高电平            \n\r\n\r7          \n\r\n\rKEY_P14          \n\r\n\r按键P14引脚，悬空为高电平            \n\r\n\r8          \n\r\n\rVIN-          \n\r\n\r外接电源负极            \n\r\n\r9          \n\r\n\rCAN1_H          \n\r\n\rCAN1总线H            \n\r\n\r10          \n\r\n\rCAN1_L          \n\r\n\rCAN1总线L            \n\r\n\r11          \n\r\n\rCAN2_H          \n\r\n\rCAN2总线H            \n\r\n\r12          \n\r\n\rCAN2_L          \n\r\n\rCAN2总线L            \n\r\n\r13          \n\r\n\rKEY_P11          \n\r\n\r按键P11引脚，悬空为高电平            \n\r\n\r14          \n\r\n\rKEY_P10          \n\r\n\r按键P10引脚，悬空为高电平            \n\r\n\r15          \n\r\n\rVIN+          \n\r\n\r外接电源正极，范围为7~18V，推荐使用9V或者12V","引脚定义说明文档","topics\\引脚定义说明文档.htm","1.&nbsp;LIN总线控制1.1&nbsp;LIN写数据\n\r\n\r功能描述：\n\r\n\r若当前LIN配置为主机模式，使用该操作可以修改ID帧类型为主机写的数据，若当前 ID帧类型为主机读，则忽略该操作；                            \n\r\n\r若当前LIN配置为从机模式，使用该操作可以修改ID帧类型为从机写的数据，若当前ID帧类型为从机读，则忽略该操作；\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回操作执行状态；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r功能码          \n\r\n\r固定为0x10            \n\r\n\rByte2          \n\r\n\r起始地址高位          \n\r\n\rbit[7..3]-总线类型，固定为0x10，bit[2..0]-LIN通道号      \n\r\n\r写LIN1通道为：0x80      \n\r\n\r写LIN2通道为：0x81            \n\r\n\rByte3          \n\r\n\r起始地址低位          \n\r\n\rLIN通信ID，取值范围为：0x00~0x3F            \n\r\n\rByte4          \n\r\n\r寄存器数高位          \n\r\n\r固定为0x00            \n\r\n\rByte5          \n\r\n\r寄存器数低位          \n\r\n\r取值范围为1~5            \n\r\n\rByte6          \n\r\n\r数据字节数          \n\r\n\r为寄存器数的2倍，取值范围2~10，若数据字节数为基数，可用0xFF补齐为偶字节数。实际发送数据以后面有效数据位为准。            \n\r\n\rByte7          \n\r\n\r校验模式          \n\r\n\r0-标准校验，1-增强校验            \n\r\n\rByte8          \n\r\n\r有效数据字节数          \n\r\n\r取值范围：0x00~0x08            \n\r\n\rByte[8+N]          \n\r\n\rN字节数据          \n\r\n\r最多8字节数据            \n\r\n\rByte[10+N-1]          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte[11+N-1]          \n\r\n\rCRC16高位\n\r\n\r\n\r\n\r正常返回：\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回数据；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r功能码          \n\r\n\r固定为0x10            \n\r\n\rByte2          \n\r\n\r起始地址高位          \n\r\n\r跟接收到的数据一致            \n\r\n\rByte3          \n\r\n\r起始地址低位          \n\r\n\r跟接收到的数据一致            \n\r\n\rByte4          \n\r\n\r寄存器数高位          \n\r\n\r跟接收到的数据一致            \n\r\n\rByte5          \n\r\n\r寄存器数低位          \n\r\n\r跟接收到的数据一致            \n\r\n\rByte6          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte7          \n\r\n\rCRC16高位\n\r\n\r\n\r\n\r错误返回：\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回数据；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r差错码          \n\r\n\r固定为0x90            \n\r\n\rByte2          \n\r\n\r异常码          \n\r\n\r0x01-不支持该功能码      \n\r\n\r0x02-功能码和起始地址不匹配      \n\r\n\r0x03-数据字节数和寄存器数不匹配            \n\r\n\rByte3          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte4          \n\r\n\rCRC16高位\n\r\n\r\n\r\n\r示例1：修改ID=0x01帧发送的数据（该ID已经通过上位机配置为主机写模式）\n\r\n\r串口发送：01 10 80 01&nbsp;00 05&nbsp;0A&nbsp;00 08&nbsp;11 22 33 44 55 66 77 88&nbsp;07 D2\n\r\n\r正常响应：01 10 80 01 00 05 78 0A1.2&nbsp;LIN读数据\n\r\n\r功能描述：\n\r\n\r若当前LIN配置为主机模式，使用该操作可以读取到ID帧类型为主机读的数据，若当前ID帧类型为主机写，则返回主机写的数据；\n\r\n\r若当前LIN配置为从机模式，使用该操作可以读取到ID帧类型为从机读的数据，若当前ID帧类型为从机写，则返回从机写的数据；\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回数据；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r功能码          \n\r\n\r固定为0x03            \n\r\n\rByte2          \n\r\n\r起始地址高位          \n\r\n\rbit[7..3]-总线类型，固定为0x10，bit[2..0]-LIN通道号      \n\r\n\r读LIN1通道为：0x80      \n\r\n\r读LIN2通道为：0x81            \n\r\n\rByte3          \n\r\n\r起始地址低位          \n\r\n\rLIN通信ID，取值范围为：0x00~0x3F            \n\r\n\rByte4          \n\r\n\r寄存器数高位          \n\r\n\r固定为0x00            \n\r\n\rByte5          \n\r\n\r寄存器数低位          \n\r\n\r取值范围为1~5            \n\r\n\rByte6          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte7          \n\r\n\rCRC16高位\n\r\n\r正常返回\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回数据；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r功能码          \n\r\n\r固定为0x03            \n\r\n\rByte2          \n\r\n\r数据字节数          \n\r\n\r取值范围为2~10            \n\r\n\rByte3          \n\r\n\r数据校验模式          \n\r\n\r0-标准校验，1-增强校验            \n\r\n\rByte4          \n\r\n\r有效数据低位          \n\r\n\r取值范围0x00~0x08            \n\r\n\rByte[4+N]          \n\r\n\rN字节数据          \n\r\n\r最多8字节数据            \n\r\n\rByte[7+N-2]          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte[7+N-1]          \n\r\n\rCRC16高位\n\r\n\r错误返回：\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回数据；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r差错码          \n\r\n\r固定为0x83            \n\r\n\rByte2          \n\r\n\r异常码          \n\r\n\r0x01-不支持该功能码      \n\r\n\r0x02-功能码和起始地址不匹配      \n\r\n\r0x03-数据字节数和寄存器数不匹配            \n\r\n\rByte3          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte4          \n\r\n\rCRC16高位\n\r\n\r\n\r\n\r示例1：通过串口读取ID=0x02读取到的数据（该ID已经通过上位机配置为主机读操作）\n\r\n\r串口发送：01 03 80 02&nbsp;00 05&nbsp;0D C9\n\r\n\r正常响应：01 03 0A 00 08&nbsp;01 02 03 04 05 06 07 08&nbsp;B3 B22.&nbsp;CAN总线控制2.1&nbsp;CAN写数据\n\r\n\r功能描述：\n\r\n\r发送特定ID帧数据，或者修改循环执行调度表指定ID索引数据；\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回数据；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r功能码          \n\r\n\r固定为0x10            \n\r\n\rByte2          \n\r\n\r起始地址高位          \n\r\n\rbit[7..3]-总线类型，固定为0x11，bit[2..0]-CAN通道号      \n\r\n\r写CAN1通道为：0x88      \n\r\n\r写CAN2通道为：0x89            \n\r\n\rByte3          \n\r\n\r起始地址低位          \n\r\n\rCAN       ID索引号，取值范围为0x00到0x1F，后续数据不需要包含ID；若该值为0x80，表示发送指定ID的CAN数据，后续数据中需要包含ID            \n\r\n\rByte4          \n\r\n\r寄存器数高位          \n\r\n\r固定为0x00            \n\r\n\rByte5          \n\r\n\r寄存器数低位          \n\r\n\r取值范围为1~6            \n\r\n\rByte6          \n\r\n\r数据字节数          \n\r\n\r为寄存器数的2倍，取值范围2~12，若数据字节数为基数，可用0xFF补齐为偶字节数。实际发送数据自己数以调度表配置为准。            \n\r\n\rByte7          \n\r\n\rID.bit[31..24]          \n\r\n\rByte3为0x80时才有此项      \n\r\n\rID.bit[31]：帧类型，1-扩展帧，0-标准帧      \n\r\n\rID.bit[30]：帧格式，1-远程帧，0-数据帧      \n\r\n\rID.bit[29]：固定为0      \n\r\n\rID.bit[28..0]：CAN       ID值，若为标准帧，则低11位有效            \n\r\n\rByte8          \n\r\n\rID.bit[23..16]            \n\r\n\rByte9          \n\r\n\rID.bit[15..8]            \n\r\n\rByte10          \n\r\n\rID.bit[7..0]            \n\r\n\rByte11          \n\r\n\r有效数据高位          \n\r\n\r固定为0x00            \n\r\n\rByte12          \n\r\n\r有效数据低位          \n\r\n\r取值0~8            \n\r\n\rByte[12+N]          \n\r\n\rN字节数据          \n\r\n\r最多8字节数据            \n\r\n\rByte[15+N-2]          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte[15+N-1]          \n\r\n\rCRC16高位\n\r\n\r\n\r\n\r正常返回：\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回数据；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r功能码          \n\r\n\r固定为0x10            \n\r\n\rByte2          \n\r\n\r起始地址高位          \n\r\n\r跟接收到的数据一致            \n\r\n\rByte3          \n\r\n\r起始地址低位          \n\r\n\r跟接收到的数据一致            \n\r\n\rByte4          \n\r\n\r寄存器数高位          \n\r\n\r跟接收到的数据一致            \n\r\n\rByte5          \n\r\n\r寄存器数低位          \n\r\n\r跟接收到的数据一致            \n\r\n\rByte6          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte7          \n\r\n\rCRC16高位\n\r\n\r\n\r\n\r错误返回：\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回数据；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r差错码          \n\r\n\r固定为0x90            \n\r\n\rByte2          \n\r\n\r异常码          \n\r\n\r0x01-不支持该功能码      \n\r\n\r0x02-功能码和起始地址不匹配      \n\r\n\r0x03-数据字节数和寄存器数不匹配            \n\r\n\rByte3          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte4          \n\r\n\rCRC16高位\n\r\n\r\n\r\n\r示例1：已经配置好CAN发送表，通过串口发送数据更改表中第一个ID对应的数据\n\r\n\r串口发送：01 10&nbsp;88 00&nbsp;00 05&nbsp;0A&nbsp;00 08&nbsp;01 22 33 44 55 66 77 08&nbsp;0F B9\n\r\n\r正常返回：01 10 88 00 00 05&nbsp;2B AA\n\r\n\r\n\r\n\r示例2：通过串口控制CAN发送任意数据，此示例发送ID为0x456789的扩展帧数据\n\r\n\r串口发送：01 10 88 80&nbsp;00 07&nbsp;0E&nbsp;80 45 67 89&nbsp;00 08&nbsp;11 22 33 44 55 66 77 88&nbsp;E0 23\n\r\n\r正常返回：01 10 88 80&nbsp;00 07&nbsp;AB 83\n\r\n\r2.2 CAN读数据\n\r\n\r功能描述：\n\r\n\r读取指定ID索引接收到的数据；\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回数据；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r功能码          \n\r\n\r固定为0x03            \n\r\n\rByte2          \n\r\n\r起始地址高位          \n\r\n\rbit[7..3]-总线类型，固定为0x11，bit[2..0]-CAN通道号      \n\r\n\r读CAN1通道为：0x88      \n\r\n\r读CAN2通道为：0x89            \n\r\n\rByte3          \n\r\n\r起始地址低位          \n\r\n\rCAN       ID索引号，取值范围为：0x00~0x3F            \n\r\n\rByte4          \n\r\n\r寄存器数高位          \n\r\n\r固定为0x00            \n\r\n\rByte5          \n\r\n\r寄存器数低位          \n\r\n\r取值范围为3~7            \n\r\n\rByte6          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte7          \n\r\n\rCRC16高位\n\r\n\r正常返回\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回数据；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r功能码          \n\r\n\r固定为0x03            \n\r\n\rByte2          \n\r\n\r数据字节数          \n\r\n\r取值范围为7~15，0表示没能读到数据            \n\r\n\rByte3          \n\r\n\rID最高位          \n\r\n\r0x00到0x1F            \n\r\n\rByte4          \n\r\n\rID次高位          \n\r\n\r0x00到0xFF            \n\r\n\rByte5          \n\r\n\rID次低位          \n\r\n\r0x00到0xFF            \n\r\n\rByte6          \n\r\n\rID最低位          \n\r\n\r0x00到0xFF            \n\r\n\rByte7          \n\r\n\r有效数据高位          \n\r\n\r固定为0x00            \n\r\n\rByte8          \n\r\n\r有效数据低位          \n\r\n\r取值范围为：0x00~0x08            \n\r\n\rByte[8+N]          \n\r\n\rN字节数据          \n\r\n\r最多8字节            \n\r\n\rByte[11+N-2]          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte[11+N-1]          \n\r\n\rCRC16高位\n\r\n\r错误返回：\n\r\n\r              \n\r\n\r字节流          \n\r\n\r功能描述          \n\r\n\r取值说明            \n\r\n\rByte0          \n\r\n\r节点地址          \n\r\n\r0x00：广播地址，设备接收到广播数据后会处理数据，但是不会返回数据；      \n\r\n\r0x01~0xFF：节点地址，同一个总线上节点地址不能冲突；            \n\r\n\rByte1          \n\r\n\r差错码          \n\r\n\r固定为0x83            \n\r\n\rByte2          \n\r\n\r异常码          \n\r\n\r0x01-不支持该功能码      \n\r\n\r0x02-功能码和起始地址不匹配      \n\r\n\r0x03-数据字节数和寄存器数不匹配            \n\r\n\rByte3          \n\r\n\rCRC16低位          \n\r\n\rCRC16，通过前面数据计算            \n\r\n\rByte4          \n\r\n\rCRC16高位\n\r\n\r\n\r\n\r示例1：读取CAN接收表里面第一个ID对应的最新数据。\n\r\n\r串口发送数据：01 03 88 00&nbsp;00 07 2F A8\n\r\n\r正常返回数据：01 03 0E 00 00 01 11&nbsp;00 08&nbsp;00 11 22 33 44 55 66 77&nbsp;49 CB\n\r\n\r\n\r\n\r3.&nbsp;DB15引脚定义说明\n\r\n\r              \n\r\n\r引脚号          \n\r\n\r名称          \n\r\n\r说明            \n\r\n\r1          \n\r\n\rVBAT          \n\r\n\rLIN工作所需电压，可以软件控制输出12V，输出电流约100mA，若软件上不使能内部5V转12V，则需要外接LIN总线电压，LIN总线才能正常工作，电压范围为5~36V。            \n\r\n\r2          \n\r\n\rLIN2          \n\r\n\rLIN2数据线            \n\r\n\r3          \n\r\n\rGND          \n\r\n\rLIN总线负极/串口GND            \n\r\n\r4          \n\r\n\rLIN1          \n\r\n\rLIN1数据线            \n\r\n\r5          \n\r\n\rGND          \n\r\n\rLIN总线负极/串口GND            \n\r\n\r6          \n\r\n\rRS232_RX          \n\r\n\rRS232总线的数据接收引脚            \n\r\n\r7          \n\r\n\rRS232_TX          \n\r\n\rRS232总线的数据发送引脚            \n\r\n\r8          \n\r\n\rVIN-          \n\r\n\r外接电源负极            \n\r\n\r9          \n\r\n\rCAN1_H          \n\r\n\rCAN1总线H            \n\r\n\r10          \n\r\n\rCAN1_L          \n\r\n\rCAN1总线L            \n\r\n\r11          \n\r\n\rCAN2_H          \n\r\n\rCAN2总线H            \n\r\n\r12          \n\r\n\rCAN2_L          \n\r\n\rCAN2总线L            \n\r\n\r13          \n\r\n\rRS485_B          \n\r\n\rRS485总线B端            \n\r\n\r14          \n\r\n\rRS485_A          \n\r\n\rRS485总线A端            \n\r\n\r15          \n\r\n\rVIN+          \n\r\n\r外接电源正极，范围为7~18V，推荐使用9V或者12V\n\r\n\r\n\r\n\r注意：\n\r\n\r1，RS232和RS485总线是分时复用的，也就是说两个总线不能同时使用，某一时刻，只能使用其中的一种总线。\n\r\n\r2，为增加LIN总线数据传输稳定性，推荐奖VBAT接到外部电源上。\n\r\n\r3，VIN+和VIN-只有在没有USB供电的情况下才需要接，若有USB对适配器进行供电，不需要接。\n\r\n\r4，在使用LIN总线进行通信的时候，GND必须接，接3脚或者5脚都可以。\n\r\n\r5，RS485总线和RS232总线通信相关参数，在TCANLINPro软件的“工具集合”-&gt;“串行配置”里面进行配置，配置后适配器重新上电生效。\n\r\n\r","串口控制CAN和LIN数据收发协议","topics\\应用案例/串口控制CAN和LIN数据收发协议.htm","目录\n\r  概述  功能简介  使用步骤  CAN   Bootloader协议\n\r概述\n\r\n\r本文详细介绍了基于USB2XXX USB2CAN适配器实现的CAN Bootloader应用案例，该应用常用于基于CAN接口实现的产品中，在需要对产品进行在线固件升级更新的场合。阅读此文可以了解到CAN Bootloader实现的基本思想和具体的实现步骤以及详细的协议说明，同时也对用其他总线就行固件升级提供一定的参考价值。\n\r\n\r   此方案的上位机源码和单片机端源码都可以免费提供，有需要的可以联系作者QQ（188298598）。功能简介\n\r\n\rCAN Bootloader主要就是利用产品的CAN接口实现对产品内部固件进行升级更新，根据实际使用情况，目前我们提供的案例有以下几个功能：\n\r  单片机端固件存储区分为2个区域，一个区域存储CAN   Bootloader功能的固件程序（该区域在单片机上电或者复位后默认被执行），另外一个区域存储实现产品自身功能的固件程序（需要通过CAN接口实现固件查询，控制固件跳转功能）。   所有接入CAN总线上，需要进行固件升级的产品，都必须具备一个唯一的ID信息（可以用拨码开关或者写入固定值方式实现），利用此ID才能分别对每个产品节点进行单独控制。   CAN   Bootloader和用户App程序固件都具备通过CAN接口被动向CAN总线反馈固件信息的功能，利用此功能，上位机软件可以查询到当前CAN总线上每个节点的固件信息。   实现CAN Bootloader只需要占用1个或者2个CAN ID，这对于CAN   ID非常珍贵的应用场合是非常大的一个优势。   Bootloader代码具备擦除App程序，接收App程序数据，写入App程序数据到程序存储器，控制程序跳转到App程序执行的功能。   在实际使用情况下，由于产品固件是非常敏感的，不能随便给其他人，所以我们提供给客户的固件必须是经过加密之后的固件，所以CAN   Bootloader固件还具备固件文件解密的功能。\n\r\n\r\n\rCAN Bootloader上位机软件界面如下所示：\n\r\n\r\n\r\n\r此软件使用Qt编写，使用的C++语言，可以免费提供源码。使用步骤编译下载Bootloader\n\r\n\r目前我们提供有STM32F103，STM32F105/107，STM32F205/207，STM32F405/407，TMS320F2808，TMS320F28335版本的单片机源码，上位机是通用的，任何单片机都可以使用相同的上位机软件，后续我们也会提供更多种类的单片机程序源码。当然客户自己也可以参考我们提供的现成单片机程序实现支持自己用的单片机。\n\r\n\r加入我们使用的是STM32F103的单片机，大容量的打开stm32f103_HD目录，小容量的打开stm32f103_MD目录，目录下有2个文件夹，一个是bootloader，一个app，我们首先打开bootloader目录。STM32版本的固件我们使用的是KEIL MDK5版本的编译器，所以直接打开“RVMDK/Project.uvprojx”文件即可。\n\r\n\r打开工程中的“can_driver.c”文件，然后找到“CAN_GPIO_Configuration”函数，确认当前引脚配置跟自己的硬件是匹配的，若不匹配则需要进行修改，该函数实现如下所示：\n\r  /**&nbsp;  &nbsp;&nbsp;*&nbsp;@brief&nbsp;&nbsp;CAN引脚配置&nbsp;  &nbsp;&nbsp;*&nbsp;@param&nbsp;&nbsp;None&nbsp;  &nbsp;&nbsp;*&nbsp;@retval&nbsp;None&nbsp;  &nbsp;&nbsp;*/&nbsp;&nbsp;  void&nbsp;CAN_GPIO_Configuration(void)&nbsp;&nbsp;  {&nbsp;&nbsp;  &nbsp;&nbsp;GPIO_InitTypeDef&nbsp;GPIO_InitStructure;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;/*外设时钟设置*/&nbsp;&nbsp;  &nbsp;&nbsp;RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA&nbsp;|&nbsp;RCC_APB2Periph_AFIO,&nbsp;ENABLE);&nbsp;&nbsp;  &nbsp;&nbsp;RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1,&nbsp;ENABLE);&nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;/*&nbsp;Configure&nbsp;CAN&nbsp;pin:&nbsp;RX&nbsp;PA11*/&nbsp;&nbsp;  &nbsp;&nbsp;GPIO_InitStructure.GPIO_Pin&nbsp;=&nbsp;GPIO_Pin_11;&nbsp;&nbsp;  &nbsp;&nbsp;GPIO_InitStructure.GPIO_Mode&nbsp;=&nbsp;GPIO_Mode_IPU;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;上拉输入&nbsp;&nbsp;  &nbsp;&nbsp;GPIO_InitStructure.GPIO_Speed&nbsp;=&nbsp;GPIO_Speed_50MHz;&nbsp;&nbsp;  &nbsp;&nbsp;GPIO_Init(GPIOA,&nbsp;&amp;GPIO_InitStructure);&nbsp;&nbsp;  &nbsp;&nbsp;  &nbsp;&nbsp;/*&nbsp;Configure&nbsp;CAN&nbsp;pin:&nbsp;TX&nbsp;PA12&nbsp;*/&nbsp;&nbsp;  &nbsp;&nbsp;GPIO_InitStructure.GPIO_Pin&nbsp;=&nbsp;GPIO_Pin_12;&nbsp;&nbsp;  &nbsp;&nbsp;GPIO_InitStructure.GPIO_Mode&nbsp;=&nbsp;GPIO_Mode_AF_PP;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;复用推挽输出&nbsp;&nbsp;  &nbsp;&nbsp;GPIO_InitStructure.GPIO_Speed&nbsp;=&nbsp;GPIO_Speed_50MHz;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;GPIO_Init(GPIOA,&nbsp;&amp;GPIO_InitStructure);&nbsp;&nbsp;  }&nbsp;&nbsp;\n\r\n\r\n\r打开“can_bootloader.c”文件，找到“GetNAD”函数实现的地方，这个函数实现获取节点地址的功能，目前我们提供的代码是通过STM32芯片内部的唯一ID运算出的一个节点地址，这种方法没法保证多个单片机接入总线时每个节点的地址都是唯一的，所以这部分代码在做实际产品的时候需要进行修改，可以通过拨码开关或者从指定Flash地址获取节点地址，最终目的就是要保证接入同一个CAN总线网络的所有节点地址不能有重复的情况，节点地址最大值不能超过0x7E。\n\r\n\r打开“can_bootloader.h”文件，根据自己 工程实际使用情况修改如下的配置信息，初次验证基本功能的时候不建议修改配置值，除非你非常明确知道每个配置的作用，同时知道在其他地方也做相应的修改。\n\r  //固件传输是否加密，若将此项配置为1，那么需要在app工程中勾选\"After&nbsp;Build/Rebuild\"下的\"Run&nbsp;#1\"和\"Run&nbsp;#2\"选项&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;ENCRYPT&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //APP程序起始地址&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;APP_START_ADDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((uint32_t)0x08008000)&nbsp;&nbsp;&nbsp;&nbsp;  //APP程序运行标志存储地址，该标志在APP程序中写入和擦除&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;APP_EXE_FLAG_ADDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((uint32_t)0x08004000)&nbsp;&nbsp;&nbsp;&nbsp;  //对于CAN总线，数据收发ID可以定义为一个ID，也可以定义为不同的ID&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;MSG_RECEIVE_ID&nbsp;0x3C&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;MSG_SEND_ID&nbsp;&nbsp;&nbsp;0x3D&nbsp;&nbsp;&nbsp;&nbsp;  //定义数据收发帧ID类型,0-标准帧，1-扩展帧&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;MSG_ID_TYPE&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;\n\r\n\r\n\r打开“main.c”文件，在主函数里面找到“CAN_Configuration”函数调用的地方，此函数调用需要传入CAN总线波特率值，单位为Hz，可以将该值修改为产品最终需要的波特率值。\n\r\n\r修改完成后，就可以编译工程，然后利用调试下载器将固件下载到单片机中。\n\r\n\r此时打开上位机端的CAN Bootloader软件，将USB2CAN适配器接入电脑，同时将适配器的CAN总线跟产品的CAN总线进行连接，然后在上位机软件上点击“操作”-&gt;“扫描节点”就可以扫描到连接到当前CAN总线上的产品，且固件类型显示为“BOOT”。\n\r\n\r若扫描不到节点，可以从以下几点去寻找问题：\n\r  CAN总线连接是否正确？  CAN Bootloader上位机的波特率跟固件中设置的波特率是否一致？  固件下载到产品中后，是否正常运行了？  CAN总线上的终端电阻是否接好了？\n\r编译下载App编译App\n\r\n\r若能成功扫描到Bootloader固件节点后，我们就可以编译App工程，然后通过CAN Bootloader上位机软件给CAN总线上的节点下载App固件了，打开app目录下的“RVMDK/Project.uvprojx”文件，我们对可能需要修改的地方做一些简单的介绍。\n\r\n\r首先是根据\"can_bootloader.h\"文件中的APP_START_ADDR宏定义修改程序的起始地址，修改后如下图所示：\n\r\n\r\n\r\n\r该地址必须跟\"can_bootloader.h\"文件中的APP_START_ADDR宏定义一致，否则可能会出现App程序无法正常执行的问题。\n\r\n\r打开“can_app.h”文件，确认以下几个宏定义值跟bootloader工程下的“can_bootloader.h”文件中的宏定义值一致。\n\r  //固件传输是否加密，若将此项配置为1，那么需要在app工程中勾选\"After&nbsp;Build/Rebuild\"下的\"Run&nbsp;#1\"和\"Run&nbsp;#2\"选项&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;ENCRYPT&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  //APP程序起始地址&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;APP_START_ADDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((uint32_t)0x08008000)&nbsp;&nbsp;&nbsp;&nbsp;  //APP程序运行标志存储地址，该标志在APP程序中写入和擦除&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;APP_EXE_FLAG_ADDR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((uint32_t)0x08004000)&nbsp;&nbsp;&nbsp;&nbsp;  //对于CAN总线，数据收发ID可以定义为一个ID，也可以定义为不同的ID&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;MSG_RECEIVE_ID&nbsp;0x3C&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;MSG_SEND_ID&nbsp;&nbsp;&nbsp;0x3D&nbsp;&nbsp;&nbsp;&nbsp;  //定义数据收发帧ID类型,0-标准帧，1-扩展帧&nbsp;&nbsp;&nbsp;&nbsp;  #define&nbsp;MSG_ID_TYPE&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;\n\r\n\r\n\r若使能了固件加密功能，则还需要配置固件自动加密指令，如下图所示：\n\r\n\r\n\r\n\r1，Run #1，指令内容为“fromelf.exe --bin --output $L@L.bin $L@L.axf”，工程编译后，会自动输出未加密的bin文件；\n\r\n\r2，Run #2，指令内容为“file_encrypt.exe&nbsp; $L@L.bin&nbsp; $L@L_encrypt.bin&nbsp; 123456789abcdefggdfrthfgdfgefsse”，该指令是对第一步生成的bin文件进行加密处理，命令的最后一个参数为秘钥字符串，长度为32个字符，这个字符串必须跟bootloader工程中CAN_BOOT_ExecutiveCommand函数中的pKey变量定义一致，否则写入Flash中的App数据将会是错的，导致App程序无法正常执行。\n\r\n\r打开“system_stm32f10x.c”文件，找到里面的VECT_TAB_OFFSET宏定义，确认该值为正确的偏移值，其值为App程序起始地址减去Bootloader程序起始地址，若该值设置不正确，可能会导致App程序中断无法正常执行。\n\r\n\r打开“main.c”文件，确认CAN_Configuration函数传入的波特率参数是跟bootloader工程中配置的参数是一致的，否则可能会导致app正常执行后，在CAN Bootloader上位机软件中无法正确识别到App正常执行的问题。\n\r\n\r编译工程，若成功后，则会在编译输出目录下生成一个名字带“encrypt”的bin文件，这个就是经过加密后的bin文件，我们就可以将这个固件提供给客户实现对自己的产品进行固件升级。下载App\n\r\n\r在CAN Bootloader上位机软件中扫描到节点后，点击“打开文件”按钮，选择上一步生成的bin文件固件，设置好波特率，数据收发ID值，ID类型（必须跟bootloader固件中的配置一致），若有多个节点需要同时更新，还可以勾选“所有节点”复选框，然后再点击“更新固件”就可以开始实现对节点进行固件更新，固件更新成功后，在软件节点列表中的“固件类型”会变成“APP”，同时也会显示当前App的固件版本。CAN Bootloader协议 1，获取固件信息\n\r\n\r主发送：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x06          \n\r\n\r0xB2          \n\r\n\r0x80          \n\r\n\r0xFF          \n\r\n\r0xFF          \n\r\n\r0xFF          \n\r\n\r0xFF\n\r\n\rID：主节点给从节点发送数据的ID，可自定义值，其他命令也一样。\n\r\n\rNAD：从节点节点地址，正常的节点地址取值0x01~0x7D，0x7F为广播地址，其他值保留。\n\r\n\r从返回：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rRSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x06          \n\r\n\r0xF2          \n\r\n\rTYPE          \n\r\n\rVER3          \n\r\n\rVER2          \n\r\n\rVER1          \n\r\n\rVER0\n\r\n\rID：从节点返回数据的ID，可自定义值，其他命令也一样。\n\r\n\rTYPE：当前固件类型，0x55-当前为Bootloader，0xAA-当前为App\n\r\n\rVER3: 固件版本号 Major\n\r\n\rVER2: 固件版本号 Minor\n\r\n\rVER1: 固件版本号 Revision\n\r\n\rVER0: 固件版本号 Build2，进入BOOT模式\n\r\n\r主发送：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x06          \n\r\n\r0xB3          \n\r\n\r0xC1          \n\r\n\r0x42          \n\r\n\r0x4F          \n\r\n\r0x4F          \n\r\n\r0x54\n\r\n\r从返回：\n\r\n\r该命令不返回数据，是否成功进入BOOT模式可以通过“获取固件信息”命令来判断。3，擦除APP程序区数据\n\r\n\r主发送：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x06          \n\r\n\r0xB4          \n\r\n\r0x42          \n\r\n\rSIZE3          \n\r\n\rSIZE2          \n\r\n\rSIZE1          \n\r\n\rSIZE0\n\r\n\rSIZE3：擦除空间大小的bit[31..24]位\n\r\n\rSIZE2：擦除空间大小的bit[23..16]位\n\r\n\rSIZE1：擦除空间大小的bit[15..8]位\n\r\n\rSIZE0：擦除空间大小的bit[7..0]位\n\r\n\r\n\r\n\r从返回：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rRSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x06          \n\r\n\r0xF4          \n\r\n\rSTATUS          \n\r\n\r0xFF          \n\r\n\r0xFF          \n\r\n\r0xFF          \n\r\n\r0xFF\n\r\n\rSTATUS：固件擦除状态，0-固件擦除成功，1-固件擦除出错，2-当前模式为APP，不能擦除固件。4，发送固件数据\n\r\n\r主发送：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x06          \n\r\n\r0xB4          \n\r\n\r0x03          \n\r\n\rADDR3          \n\r\n\rADDR2          \n\r\n\rADDR1          \n\r\n\rADDR0\n\r\n\rADDR3：固件数据偏移地址bit[31..24]位\n\r\n\rADDR2：固件数据偏移地址bit[23..16]位\n\r\n\rADDR1：固件数据偏移地址bit[15..8]位\n\r\n\rADDR0：固件数据偏移地址bit[7..0]位\n\r\n\r从返回：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rRSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x06          \n\r\n\r0xF4          \n\r\n\rSTATUS          \n\r\n\rBUF_LEN1          \n\r\n\rBUF_LEN0          \n\r\n\r0xFF          \n\r\n\r0xFF\n\r\n\rSTATUS：0-准备好接收数据，3-当前地址超出了正常的地址范围，4-当前模式不能写入固件数据。\n\r\n\rBUF_LEN1：接收数据缓冲区大小bit[15..8]位\n\r\n\rBUF_LEN0：接收数据缓冲区大小bit[7..0]位\n\r\n\r注意：后续单次发送固件数据的长度不能大于缓冲区的大小减2。\n\r\n\r若数据小于等于4字节，则发送：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x0L          \n\r\n\r0xB4          \n\r\n\r0xC4          \n\r\n\rW0          \n\r\n\rW1          \n\r\n\rW2          \n\r\n\rW3\n\r\n\rL：固件有效数据长度加2的bit[3..0]位\n\r\n\r注意：若数据小于4字节，则以0xFF补全。\n\r\n\r\n\r\n\r否则发送：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rLEN          \n\r\n\rSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x1L          \n\r\n\rLEN          \n\r\n\r0xB4          \n\r\n\r0xC4          \n\r\n\rW0          \n\r\n\rW1          \n\r\n\rW2\n\r\n\rL：固件数据长度加2的bit[11..8]位\n\r\n\rLEN：固件数据长度加2的bit[7..0]位\n\r\n\r\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5          \n\r\n\rD6            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x2N          \n\r\n\rW3          \n\r\n\rW4          \n\r\n\rW5          \n\r\n\rW6          \n\r\n\rW7          \n\r\n\rW8\n\r\n\rN：包计数，从0到15循环\n\r\n\r注意：若最后一帧数据不够6字节，则以0xFF补全。\n\r\n\r主发送：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x06          \n\r\n\r0xB4          \n\r\n\r0x85          \n\r\n\rCRC1          \n\r\n\rCRC0          \n\r\n\r0xFF          \n\r\n\r0xFF\n\r\n\rCRC1：前面发送的APP数据的CRC16的bit[15..8]位\n\r\n\rCRC0：前面发送的APP数据的CRC16的bit[7..0]位\n\r\n\r\n\r\n\r从返回：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rRSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x06          \n\r\n\r0xF4          \n\r\n\rSTATUS          \n\r\n\r0xFF          \n\r\n\r0xFF          \n\r\n\r0xFF          \n\r\n\r0xFF\n\r\n\rSTATUS：0-数据成功写入程序存储器，4-当前模式不能写入固件数据，5-数据写入程序存储器出错，6-数据长度超出了程序存储器范围，7-数据传输CRC校验出错，8-数据写入芯片CRC校验出错。5，执行APP固件\n\r\n\r主发送：\n\r\n\r              \n\r\n\rID          \n\r\n\rNAD          \n\r\n\rPCI          \n\r\n\rSID          \n\r\n\rD1          \n\r\n\rD2          \n\r\n\rD3          \n\r\n\rD4          \n\r\n\rD5            \n\r\n\rID          \n\r\n\rNAD          \n\r\n\r0x06          \n\r\n\r0xB4          \n\r\n\r0x06          \n\r\n\r0x41          \n\r\n\r0x50          \n\r\n\r0x50          \n\r\n\r0xFF\n\r\n\r返回：\n\r\n\r该命令不返回数据，是否成功执行APP可以通过“获取固件信息”命令来判断。\n\r\n\r","基于USB2CAN适配器实现的CAN Bootloader","topics\\应用案例/基于USB2CAN适配器实现的CAN_Bootloader.htm","1.&nbsp;编辑需要发送的CAN&amp;LIN数据1.1&nbsp;编辑CAN数据\n\r\n\r打开TCANLINPro软件后，若需要通过CAN1发送数据，则启动CAN1，若需要CAN2发送数据，则启动CAN2，若需要2通道同时发送数据，那么就分别启动2个通道。点击启动时会弹出CAN相关配置参数，比如波特率值，选择是否接入终端电阻，这些设置必须正确，在写入CAN数据到设备的时候，这些初始化配置值也会写入设备。\n\r\n\r启动CAN通道后，点击【发送CAN数据】-&gt;【普通发送】，弹出如下界面：\n\r\n\r&nbsp;\n\r\n\r将要发送的数据添加到列表里面，每帧后面的延时就是控制当前帧跟下一帧之间的时间间隔。编辑好发送的数据后，点击【列表操作】-&gt;【导出】，将列表文件导出为.canlist格式文件备用。1.2&nbsp;编辑 LIN数据\n\r\n\r打开TCANLINPro软件后，若需要通过LIN1发送数据，则启动LIN1，若需要LIN2发送数据，则启动LIN2，若需要2通道同时发送数据，那么就分别启动2个通道。点击启动时会弹出LIN相关配置参数，比如波特率值，选择是否使能12V输出，选择主机模式，这些设置必须正确，在写入LIN数据到设备的时候，这些初始化配置值也会写入设备。\n\r\n\r启动LIN通道后，点击【发送LIN数据】-&gt;【普通发送】，弹出如下界面：\n\r\n\r&nbsp;\n\r\n\r将要发送的数据添加到列表里面，每帧后面的延时就是控制当前帧跟下一帧之间的时间间隔。编辑好发送的数据后，点击【列表操作】-&gt;【导出】，将列表文件导出为.linlist格式文件备用。\n\r\n\r2.&nbsp;将编辑好的数据写入设备\n\r\n\r数据编辑好之后，关闭发送数据对话框，点击软件菜单【工具集合】-&gt;【按键功能配置】，弹出如下对话框：\n\r\n\r&nbsp;\n\r\n\r软件会根据产品型号自动添加支持的按键，并添加到列表里面，比如要发送CAN数据，那么就在【数据类型】栏选择CAN，若要发送LIN数据，那么就在【数据类型】栏选择LIN，【发送通道】根据自己实际硬件连接选择即可，【触发类型】可以选择下降沿触发或者低电平触发，下降沿触发是在按键引脚跟GND短接的时候发送一次数据，数据发送完毕后就停止发送，再次短接的时候就再发送一次，低电平触发是检测到按键引脚跟GND短接后就一直发送数据，直到按键引脚跟GND断开为止，按键引脚内部有上拉电阻，空闲不接的时候是高电平。\n\r\n\r配置好发送数据类型和发送通道后，点击【选择文件】选择第一步编辑到的数据文件，然后点击【写入设备】按钮即可。3.&nbsp;按键控制发送CAN&amp;LIN数据\n\r\n\r将数据写入设备后，将适配器通过USB充电器供电（不能接电脑，否则无法进入离线发送数据模式），上电后，蓝色灯会闪烁大概10秒，然后若长亮了，那么就成功进入离线模式了，按照软件上的配置将按键引脚跟GND接通后就可以控制数据发送了。","使用按键控制CAN和LIN实现数据发送","topics\\应用案例/使用按键控制CAN和LIN实现数据发送.htm","目录\n\r  概述\n\r  串口控制LIN配置\n\r  串口控制CAN配置\n\r  串口控制举例\n\r概述\n\r\n\rUTA0404可以通过串口模式控制CAN/LIN数据收发，串口可以使用RS232或者RS485总线，它们使用的引脚不一样，具体使用的引脚可以参考《引脚定义说明文档》，控制协议使用的是Modebus RTU，可以使用PLC等带Modbus协议的设备进行控制。在通过串口控制之前，需要使用TCANLINPro软件对串口，CAN口，LIN口进行一些配置，比如配置串口的波特率，节点地址等，CAN口的波特率，LIN口的波特率，主从模式，调度表等。本文档后续会对这些配置进行详细介绍。串口控制LIN配置\n\r\n\r先将设备通过USB数据线接入电脑，打开TCANLINPro软件，若软件识别到了设备，会在软件的设备管理界面显示对应的设备，如下图所示：\n\r\n\r\n\r\n\r若在软件的设备管理里面没有显示设备，则有可能是设备驱动没安装好，或者是设备没有正确的连接到电脑。\n\r\n\r点击软件的【工具集合】-&gt;【LIN串口控制配置】，弹出如下界面：\n\r\n\r\n\r\n\r根据自己串口相关信息配置好串口参数，主要是节点地址和波特率配置，打开软件后默认LIN是从机模式，从机模式下可以监控LIN总线上数据，适配器内部包含一个LIN接收数据表，该表会存储对应ID接收到的最新数据，该数据可以通过串口读取到。\n\r\n\r若需要实现从机模式响应主机的读操作，那么可以将帧类型配置为【从机写】，然后再数据栏填入默认响应数据，该响应数据也可以通过串口实时修改。\n\r\n\r若LIN口要配置为主机模式，将主从模式选择【主机】即可，选择后如下图所示：\n\r\n\r\n\r\n\r将需要发送数据的ID勾选上，帧类型配置为【主机写】，在数据栏填入默认要发送的数据。若某个ID需要向从机读数据，需要勾选该ID，然后将帧类型配置为【主机读】即可。\n\r\n\r配置好串口参数，LIN口参数，LIN调度表之后，点击【写入】按钮，相关配置数据就会写入适配器内部，然后重新给适配器上电就可以通过串口进行控制了，这些参数会掉电保存。串口控制CAN配置\n\r\n\r参考上一步骤，确认设备连接正常，点击软件的【工具集合】-&gt;【CAN串口控制配置】，弹出如下界面：\n\r\n\r\n\r\n\r根据自己需求，设置好串口参数和CAN总线参数，这里也需要配置2个表，一个是发送数据表，一个是接收数据表。发送数据表就是配置自动发送CAN数据的表，发送的数据可以通过串口进行修改，当然串口也可以发送不在这个表里面的其他ID数据。\n\r\n\r串口修改发送数据的时候，是根据已经勾选的ID在表中的索引号来进行访问的，具体怎么操作，可以参考《串口控制CAN和LIN数据收发协议》。\n\r\n\r若想要监控某些ID的数据，可以配置好CAN接收调度表，填好需要监控数据的ID，这样就可以通过串口获取到对应ID接收到的最新数据了。串口控制举例\n\r\n\r示例1：修改ID=0x01帧发送的数据（该ID已经通过上位机配置为主机写模式）\n\r\n\r串口发送：01 10 80 01&nbsp;00 05&nbsp;0A&nbsp;00 08&nbsp;11 22 33 44 55 66 77 88&nbsp;07 D2\n\r\n\r正常响应：01 10 80 01 00 05 78 0A\n\r\n\r&nbsp;\n\r\n\r示例2：通过串口读取ID=0x02读取到的数据（该ID已经通过上位机配置为主机读操作）\n\r\n\r串口发送：01 03 80 02&nbsp;00 05&nbsp;0D C9\n\r\n\r正常响应：01 03 0A 00 08&nbsp;01 02 03 04 05 06 07 08&nbsp;B3 B2\n\r\n\r&nbsp;\n\r\n\r示例3：已经配置好CAN发送表，通过串口发送数据更改表中第一个ID对应的数据\n\r\n\r串口发送：01 10&nbsp;88 00&nbsp;00 05&nbsp;0A&nbsp;00 08&nbsp;01 22 33 44 55 66 77 08&nbsp;0F B9\n\r\n\r正常返回：01 10 88 00 00 05&nbsp;2B AA\n\r\n\r&nbsp;\n\r\n\r示例4：通过串口控制CAN发送任意数据，此示例发送ID为0x456789的扩展帧数据\n\r\n\r串口发送：01 10 88 80&nbsp;00 07&nbsp;0E&nbsp;80 45 67 89&nbsp;00 08&nbsp;11 22 33 44 55 66 77 88&nbsp;E0 23\n\r\n\r正常返回：01 10 88 80&nbsp;00 07&nbsp;AB 83\n\r\n\r&nbsp;\n\r\n\r示例5：读取CAN接收表里面第一个ID对应的最新数据。\n\r\n\r串口发送数据：01 03 88 00&nbsp;00 07 2F A8\n\r\n\r正常返回数据：01 03 0E 00 00 01 11&nbsp;00 08&nbsp;00 11 22 33 44 55 66 77&nbsp;49 CB\n\r\n\r","使用串口控制CAN和LIN实现数据收发","topics\\应用案例/使用串口控制CAN和LIN实现数据收发.htm","概述\n\r\n\r此目录下罗列一些基于USB2XXX的一些应用案例文档","应用案例","topics\\应用案例/应用案例.htm");